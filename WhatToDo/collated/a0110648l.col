//@author: a0110648l



	/**
	 * origin: ./\Command.cpp
	 */



#include "Command.h"

Command::Command(void) {
	_commandTaskIndex = INITIAL_VALUE_COMMAND_TASK_INDEX;
	_isCommandValid = INITIAL_VALUE_IS_COMMAND_VALID;
	_isParsedCorrectly = INITIAL_VALUE_IS_PARSED_CORRECTLY;
	_searchKeyword = INITIAL_VALUE_SEARCH_KEYWORD;
	_isDoneStatusToSet = INITIAL_VALUE_IS_DONE_STATUS;
	_userMessage = INITIAL_VALUE_USER_MESSAGE;
	_actionMessage = INITIAL_VALUE_ACTION_MESSAGE;
	_currentTask = NULL;
	_currentState = NULL;
	_logFileName = INITIAL_VALUE_LOG_FILE_NAME;
	_loggingModeOn = INITIAL_VALUE_LOGGING_MODE_ON;
	_doneFilter = Status::STATUS_NOT_SET;
	_typeFilter = Type::TYPE_NOT_SET;
}

void Command::execute() {
	return;
}

int Command::getTaskIndex() {
	return _commandTaskIndex;
}

bool Command::getParsedStatus() {
	return _isParsedCorrectly;
}

string Command::getSearchKeyword() {
	return _searchKeyword;
}

string Command::getUserMessage() {
	return _userMessage;
}

Task Command::getCurrentTask() {
	return *_currentTask;
}

bool Command::getIsDoneStatus() {
	return _isDoneStatusToSet;
}

int Command::getDoneFilter(void) {
	return _doneFilter;
}

int Command::getTypeFilter(void) {
	return _typeFilter;
}

date Command::getStartDateFilter(void) {
	return _startDateFilter;
}

date Command::getEndDateFilter(void) {
	return _endDateFilter;
}



void Command::setTaskIndex(int commandTaskIndexToSet) {
	_commandTaskIndex = commandTaskIndexToSet;
	return;
}

void Command::setParsedStatus(bool parsedStatus) {
	_isParsedCorrectly = parsedStatus;
	return;
}

void Command::setSearchKeyword(string searchKeywordToSet) {
	_searchKeyword = searchKeywordToSet;
	return;
}

void Command::setUserMessage(string userMessageToSet) {
	_userMessage = userMessageToSet;
	return;
}

void Command::setCurrentTask(Task currentTaskToSet) {
	_currentTask = new Task;
	*_currentTask = currentTaskToSet;
	return;
}

void Command::setIsDoneStatus(bool isDoneStatusToSet) {
	_isDoneStatusToSet = isDoneStatusToSet;
	return;
}

void Command::setDoneFilter(int doneFilter) {
	_doneFilter = doneFilter;
}

void Command::setTypeFilter(int typeFilter) {
	_typeFilter = typeFilter;
}

void Command::setStartDateFilter(date startDateFilter) {
	_startDateFilter = startDateFilter;
}

void Command::setEndDateFilter(date endDateFilter) {
	_endDateFilter = endDateFilter;
}

bool Command::checkIsParsedCorrectly() {
	if (!_isParsedCorrectly) {
		throw _userMessage;
	}

	sprintf_s(buffer, MSG_LOGGING_CHECK_IS_PARSED_CORRECTLY.c_str(), 
		_userMessage.c_str());
	log(buffer);

	return _isParsedCorrectly;
}

void Command::retrieveExistingViewState() {
	_currentState = new State;
	*_currentState = LogicData::getViewState();

	sprintf_s(buffer, 
		MSG_LOGGING_RETRIEVE_EXISTING_VIEW_STATE.c_str());
	log(buffer);

	return;
}

void Command::retrieveExistingCurrentState() {
	_currentState = new State;
	*_currentState = LogicData::getCurrentState();

	sprintf_s(buffer, 
		MSG_LOGGING_RETRIEVE_EXISTING_CURRENT_STATE.c_str());
	log(buffer);

	return;
}

void Command::setNewCurrentState() {
	LogicData::setCurrentState(*_currentState);

	sprintf_s(buffer, MSG_LOGGING_SET_NEW_CURRENT_STATE.c_str());
	log(buffer);

	return;
}

void Command::setNewViewState() {
	LogicData::setViewState(*_currentState);

	sprintf_s(buffer, MSG_LOGGING_SET_NEW_VIEW_STATE.c_str());
	log(buffer);

	return;
}

void Command::addThisCommandToHistory(Command* commandToAdd) {
	LogicData::addCommandToHistory(commandToAdd);

	sprintf_s(buffer, 
		MSG_LOGGING_ADD_THIS_COMMAND_TO_HISTORY.c_str());
	log(buffer);

	return;
}

void Command::addUserMessageToCurrentState() {
	_currentState->setUserMessage(_userMessage);

	sprintf_s(buffer, 
		MSG_LOGGING_ADD_USER_MESSAGE_TO_CURRENT_STATE.c_str(), 
		_userMessage.c_str());
	log(buffer);

	return;
}

void Command::addActionMessageToCurrentState() {
	_currentState->setActionMessage(_actionMessage);
	return;
}

void Command::resetLogicDataSettings() {
	LogicData::resetToInitialSettings();

	sprintf_s(buffer, MSG_LOGGING_RESET_LOGIC_DATA_SETTINGS.c_str());
	log(buffer);

	return;
}

void Command::log(string stringToLog) {
	if (!_loggingModeOn) {
		return;
	}

	ofstream writeToLog;
	writeToLog.open(_logFileName, ios::app);
	writeToLog << stringToLog;
	writeToLog.close();

	return;
}
	// End of segment: ./\Command.cpp





	/**
	 * origin: ./\Command.h
	 */

//
// This is the parent Command superclass, which contains certain concrete methods 
// that will be used by its children, as well a virtual execute function that
// should be implemented by its concrete children Command classes. This class
// should be used in accordance with the Command Pattern framework.
//
// Amongst its getters and setters, most are made such that details of a command
// can be altered when a command subclass is created. These details include
// (but are not limited to) the task index, the task itself, the search keyword,
// and the user message.
//
// Apart from these public methods, it contains protected functions that its
// children may inherit that implement functions that perform required interactions
// with LogicData such as (but are not limited to) retrieving and setting 
// LogicData's view or current states, and adding a task to the LogicData's
// command history.
//
// Logging: Amongst its protected functions includes a function that allows for
// easy logging amongst its child classes, which may be turned on and off through
// the initialization logging mode parameter.
//
//****************************************************************************

#ifndef COMMAND_H
#define COMMAND_H

#include <string>
#include <vector>
#include <fstream>
#include <assert.h>
#include "Task.h"
#include "State.h"
#include "LogicData.h"

using namespace std;

const int INITIAL_VALUE_COMMAND_TASK_INDEX = 0;
const bool INITIAL_VALUE_IS_PARSED_CORRECTLY = true;
const bool INITIAL_VALUE_IS_COMMAND_VALID = true;
const bool INITIAL_VALUE_IS_DONE_STATUS = false;
const bool INITIAL_VALUE_LOGGING_MODE_ON = false;
const string INITIAL_VALUE_SEARCH_KEYWORD = "";
const string INITIAL_VALUE_USER_MESSAGE = "";
const string INITIAL_VALUE_ACTION_MESSAGE = "";
const string INITIAL_VALUE_LOG_FILE_NAME = "CommandLog.txt";

const string STRING_EMPTY = "";

const string MSG_LOGGING_CHECK_IS_PARSED_CORRECTLY = 
	"Function called: checkIsParsedCorrectly(): _userMessage set as:"
	"%s\n";
const string MSG_LOGGING_RETRIEVE_EXISTING_VIEW_STATE = 
	"Function called: retrieveExistingViewState()\n";
const string MSG_LOGGING_RETRIEVE_EXISTING_CURRENT_STATE = 
	"Function called: retrieveExistingCurrentState()\n";
const string MSG_LOGGING_SET_NEW_CURRENT_STATE = 
	"Function called: setNewCurrentState()\n";
const string MSG_LOGGING_SET_NEW_VIEW_STATE = 
	"Function called: setNewViewState()\n";
const string MSG_LOGGING_ADD_THIS_COMMAND_TO_HISTORY = 
	"Function called: addThisCommandToHistory()\n";
const string MSG_LOGGING_ADD_USER_MESSAGE_TO_CURRENT_STATE = 
	"Function called: addUserMessageToCurrentState(): _userMessage wr"
	"itten: %s\n";
const string MSG_LOGGING_RESET_LOGIC_DATA_SETTINGS = 
	"Function called: resetLogicDataSettings()\n";

const string MSG_ERROR_NOT_PARSED_CORRECTLY = 
	"Cannot perform command";


class Command {
	public:
		Command(void);
		virtual void execute();

		// All Getter Functions

		int getTaskIndex();
		bool getParsedStatus();
		string getSearchKeyword();
		string getUserMessage();
		Task getCurrentTask();
		bool getIsDoneStatus();
		int getDoneFilter(void);
		int getTypeFilter(void);
		date getStartDateFilter(void);
		date getEndDateFilter(void);

		// All Setter Functions

		void setTaskIndex(int commandTaskIndexToSet);
		void setParsedStatus(bool parsedStatus);
		void setSearchKeyword(string searchKeywordToSet);
		void setUserMessage(string userMessageToSet);
		void setCurrentTask(Task currentTaskToSet);
		void setIsDoneStatus(bool isDoneStatusToSet);
		void setDoneFilter(int doneFilter);
		void setTypeFilter(int typeFilter);
		void setStartDateFilter(date startDateFilter);
		void setEndDateFilter(date endDateFilter);

	protected:

		// Attributes For Execution

		bool _isParsedCorrectly;
		bool _isCommandValid;
		int _commandTaskIndex;
		string _searchKeyword;
		bool _isDoneStatusToSet;
		string _userMessage;
		string _actionMessage;
		Task* _currentTask;
		State* _currentState;
		int _doneFilter;
		int _typeFilter;
		date _startDateFilter;
		date _endDateFilter;
		char buffer[255];

		// Attributes For Logging

		string _logFileName;
		bool _loggingModeOn;

		// Functions For Execution

		bool checkIsParsedCorrectly();

		// The following functions implement interactions with
		// LogicData by calling LogicData's APIs to obtain existing
		// data for the execution of various commands. The function
		// names ought to be self-explanatory.

		void retrieveExistingViewState();
		void retrieveExistingCurrentState();
		void setNewCurrentState();
		void setNewViewState();
		void addThisCommandToHistory(Command* commandToAdd);
		void addUserMessageToCurrentState();
		void addActionMessageToCurrentState();
		void resetLogicDataSettings();

		// Function For Logging

		void log(string stringToLog);
};

#endif
	// End of segment: ./\Command.h





	/**
	 * origin: ./\CommandAdd.cpp
	 */


#include "CommandAdd.h"

CommandAdd::CommandAdd(void)
{
}

void CommandAdd::execute() {
	sprintf_s(buffer, MSG_LOGGING_EXECUTE_COMMAND_ADD.c_str());
	log(buffer);
	
	try {
		checkIsParsedCorrectly();
		assert(_currentTask != NULL);

		retrieveExistingCurrentState();

		checkIsCommandValid();
		checkIsInputTimeNotOccupied();
		performAddOperation();
		addThisCommandToHistory(this);

		addUserMessageToCurrentState();
		addActionMessageToCurrentState();
		setNewCurrentState();
		setNewViewState();
	}
	catch (string errorMsg) {
		_userMessage = errorMsg;
		retrieveExistingViewState();
		addUserMessageToCurrentState();
		setNewViewState();
	}

	return;
}

bool CommandAdd::checkIsCommandValid() {
	bool isOrderOfDateTimesValid = checkIfOrderOfDateTimesValid();
	bool isCommandValid = isOrderOfDateTimesValid;
	_isCommandValid = isCommandValid;
	return isCommandValid;
}

bool CommandAdd::checkIfOrderOfDateTimesValid() {
	bool isOrderOfDateTimesValid = true;

	if (_currentTask->isTaskHasStartAndEnd()) {
		bool isEndAfterStart = checkIsEndAfterStart();
		isOrderOfDateTimesValid = isEndAfterStart;
	}

	sprintf_s(buffer, MSG_LOGGING_IS_ORDER_DATETIMES_VALD.c_str(), 
		to_string(isOrderOfDateTimesValid).c_str());
	log(buffer);

	return isOrderOfDateTimesValid;
}

bool CommandAdd::checkIsEndAfterStart() {
	bool isEndAfterStart = 
		_currentTask->getTaskStartTime() <= 
		_currentTask->getTaskEndTime();

	if (!isEndAfterStart) {
		throw MSG_ERROR_ENDTIME_BEFORE_STARTTIME;
	}
	return isEndAfterStart;
}

bool CommandAdd::checkIsInputTimeNotOccupied() {
	vector<Task> listOfTimedTasks = _currentState->getTimedTasks();
	int currentTaskType = _currentTask->getTaskType();
	bool isInputTimeNotOccupied = true;
	int i;

	for (i=0; unsigned(i)<listOfTimedTasks.size(); i++) {
		if ((_currentTask->isTaskHasStartAndEnd()) 
			&& (listOfTimedTasks[i].isTaskHasStartAndEnd()) 
			&& (listOfTimedTasks[i].getTaskIsDone() == false)) {

			if (_currentTask->isTaskOverlapWith(listOfTimedTasks[i])) {
				isInputTimeNotOccupied = false;
				_userMessage = MSG_USER_INPUT_TIME_OCCUPIED;
				break;
			}
		}
	}
	
	sprintf_s(buffer, MSG_LOGGING_IS_INPUT_TIME_ALR_OCCUPIED.c_str(), 
		to_string(isInputTimeNotOccupied).c_str());
	log(buffer);

	return isInputTimeNotOccupied;
}

void CommandAdd::performAddOperation() {
	_currentState->addTask(*_currentTask, true);
	_actionMessage = MSG_ACTION_ADDED;

	sprintf_s(buffer, MSG_LOGGING_PERFORM_ADD.c_str());
	log(buffer);
	return;
}

	// End of segment: ./\CommandAdd.cpp





	/**
	 * origin: ./\CommandAdd.h
	 */

//
// This is the concrete CommandAdd class, which is reponsible for executing 
// an "add" command specified by the user.
//
// It works by (i) checking for the validity of the command; (ii) retrieving 
// the current state from LogicData; (iii) performing the add operation;
// (iv) rewriting the current and view states in LogicData; and (v) adding 
// itself to LogicData's command history.
//
// If the command is invalid either due to (i) a false parsed status indicating
// it has been parsed incorrectly; or (ii) incorrect date orderings, an error 
// message will be added to the current state to be shown to the user eventually.
//
//****************************************************************************

#pragma once

#include "Command.h"
#include "boost\date_time.hpp"

using namespace std;
using namespace boost::gregorian;
using namespace boost::posix_time;

const string MSG_LOGGING_EXECUTE_COMMAND_ADD = 
	"\nCommand Add Initiated:\n";
const string MSG_LOGGING_IS_ORDER_DATETIMES_VALD = 
	"Function called: checkIsCommandValid(): isOrderOfDateTimesValid"
	": %s\n";
const string MSG_LOGGING_IS_INPUT_TIME_ALR_OCCUPIED = 
	"Function called: checkIsCommandValid(): isInputTimeAlreadyOccup"
	"ied: %s\n";
const string MSG_LOGGING_IS_COMMAND_VALID = 
	"Function called: checkIsCommandValid(): _isCommandValid: %s\n";
const string MSG_LOGGING_PERFORM_ADD = 
	"Function called: performAddOperation()\n";

const string MSG_ERROR_ENDTIME_BEFORE_STARTTIME = 
	"The end time cannot be before the start time!";
const string MSG_USER_INPUT_TIME_OCCUPIED = 
	"Task Added! Note: Beware task overlap!";
const string MSG_ACTION_ADDED = "Task Added!";

class CommandAdd: public Command {
	public:
		CommandAdd(void);

		/*
		// This API function executes the Add Command when called.
		//
		// Pre-conditions:
		//     (i) There should be a proper task set as the current
		//     task in the command instance before execute is called.
		//     (ii) The _isParsedCorrectly variable in the command 
		//     should be true.
		//
		// Post-Conditions:
		//     (i) The specified task will be added to LogicData unless
		//     there are logic errors with the task (such as if the
		//     specified task start time is after the end time)
		//
		// Sample usage:
		//     CommandAdd* anAddCommand = new CommandAdd;
		//     anAddCommand->setCurrentTask(taskToAdd);
		//     anAddCommand->execute();
		*/

		void execute();

	protected:

		// Functions For Execution

		bool checkIsCommandValid();
		void performAddOperation();

		// These functions check for the validity of the add 
		// operation. If there are serious logic errors with the
		// specified command, the add operation will not be completed
		// and errors will be written into the state. If there are 
		// warnings then the add operation will be completed but these
		// warnings will still be written into the state (to be shown
		// to the user eventually.

		bool checkIfOrderOfDateTimesValid();
		bool checkIsInputTimeNotOccupied();
		bool checkIsEndAfterStart();

};


	// End of segment: ./\CommandAdd.h





	/**
	 * origin: ./\CommandClear.cpp
	 */


#include "CommandClear.h"

CommandClear::CommandClear(void) {
}

void CommandClear::execute() {
	sprintf_s(buffer, MSG_LOGGING_EXECUTE_COMMAND_CLEAR.c_str());
	log(buffer);
	
	try {
		checkIsParsedCorrectly();
		retrieveExistingCurrentState();
		resetLastActionType();
		resetUserMessage();
		setNewViewState();
	}
	catch (string errorMsg) {
		_userMessage = errorMsg;
		retrieveExistingViewState();
		addUserMessageToCurrentState();
		setNewViewState();
	}

	return;
}

void CommandClear::resetLastActionType() {
	_currentState->setLastActionType(State::NONE);
	return;
}

void CommandClear::resetUserMessage() {
	_currentState->setUserMessage(STRING_EMPTY);
	return;
}
	// End of segment: ./\CommandClear.cpp





	/**
	 * origin: ./\CommandClear.h
	 */

//
// This is the concrete CommandClear class, which is reponsible for executing 
// an "clear" command specified by the user.
//
// It works by (i) checking for the validity of the command; (ii) retrieving 
// the current state from LogicData; and (iii) rewriting the view state in 
// LogicData.
//
// If the command is invalid due to a false parsed status indicating
// it has been parsed incorrectly an error message will be added to the current\
// state to be shown to the user eventually.
//
//****************************************************************************

#pragma once

#include "Command.h"

using namespace std;

const string MSG_LOGGING_EXECUTE_COMMAND_CLEAR = 
	"\nCommand Clear Initiated:\n";

class CommandClear: public Command {
	public:
		CommandClear(void);

		/*
		// This API function executes the Clear Command when called.
		//
		// Pre-conditions:
		//     (i) The LogicData should already be initialized with
		//     a load command beforehand.
		//     (ii) The _isParsedCorrectly variable in the command 
		//     should be true.
		//
		// Post-Conditions:
		//     (i) All the view state in LogicData will be overwritten
		//     by the current state in LogicData
		//
		// Sample usage:
		//     CommandClear* aClearCommand = new CommandClear;
		//     aClearCommand->execute();
		*/

		void execute();

	protected:

		// Functions For Execution
		
		void resetLastActionType();
		void resetUserMessage();
};


	// End of segment: ./\CommandClear.h





	/**
	 * origin: ./\CommandDelete.cpp
	 */


#include "CommandDelete.h"

CommandDelete::CommandDelete(void) {
}

void CommandDelete::execute() {
	sprintf_s(buffer, LOGGING_MSG_EXECUTE_COMMAND_DELETE.c_str());
	log(buffer);
	
	try {
		checkIsParsedCorrectly();
		assert(_commandTaskIndex >= 0);

		retrieveExistingCurrentState();

		performDeleteOperation();
		addThisCommandToHistory(this);

		addUserMessageToCurrentState();
		addActionMessageToCurrentState();
		setNewCurrentState();
		setNewViewState();
	}
	catch (string errorMsg) {
		_userMessage = errorMsg;
		retrieveExistingViewState();
		addUserMessageToCurrentState();
		setNewViewState();
	}
	
	return;
}

void CommandDelete::performDeleteOperation() {
	_currentState->deleteTask(_commandTaskIndex, true);
	_actionMessage = ACTION_MSG_DELETED;
	_currentState->setUserMessage(STRING_EMPTY);

	sprintf_s(buffer, LOGGING_MSG_PERFORM_DELETE.c_str(), 
		to_string(_commandTaskIndex).c_str());
	log(buffer);
	return;
}

	// End of segment: ./\CommandDelete.cpp





	/**
	 * origin: ./\CommandDelete.h
	 */

//
// This is the concrete CommandDelete class, which is reponsible for executing 
// a "delete" command specified by the user.
//
// It works by (i) checking for the validity of the command; (ii) retrieving 
// the current state from LogicData; (iii) performing the delete operation;
// (iv) rewriting the current and view states in LogicData; and (v) adding 
// itself to LogicData's command history.
//
// If the command is invalid due to a false parsed status indicating
// it has been parsed incorrectly, an error message will be added to the 
// current state to be shown to the user eventually.
//
//****************************************************************************

#pragma once

#include "Command.h"

using namespace std;

const string LOGGING_MSG_EXECUTE_COMMAND_DELETE = 
	"\nCommand Delete Initiated:\n";
const string LOGGING_MSG_PERFORM_DELETE = 
	"Function called: performDeleteOperation(): _commandTaskIndex de"
	"leted: %s\n";
const string ACTION_MSG_DELETED = 
	"Task Deleted!";

class CommandDelete: public Command {
	public:
		CommandDelete(void);
		
		/*
		// This API function executes the Delete Command when called.
		//
		// Pre-conditions:
		//     (i) There should be a proper task index (and not just a display
		//     task index set as the current task index in the command instance
		//     before execute is called.
		//     (ii) The _isParsedCorrectly variable in the command 
		//     should be true.
		//
		// Post-Conditions:
		//     (i) The specified task will be deleted to LogicData
		//
		// Sample usage:
		//     CommandDelete* aDeleteCommand = new CommandDelete;
		//     aDeleteCommand->setTaskIndex(taskIndexToDelete);
		//     aDeleteCommand->execute();
		*/

		void execute();

	protected:
		
		// Functions For Execution

		void performDeleteOperation();
};


	// End of segment: ./\CommandDelete.h





	/**
	 * origin: ./\CommandDone.cpp
	 */


#include "CommandDone.h"

CommandDone::CommandDone(void) {
}

void CommandDone::execute() {
	sprintf_s(buffer, LOGGING_MSG_EXECUTE_COMMAND_DONE.c_str());
	log(buffer);
	
	try {
		checkIsParsedCorrectly();
		assert(_commandTaskIndex >= 0);

		retrieveExistingCurrentState();

		performDoneOperation();
		addThisCommandToHistory(this);

		addUserMessageToCurrentState();
		addActionMessageToCurrentState();
		setNewCurrentState();
		setNewViewState();
	}
	catch (string errorMsg) {
		_userMessage = errorMsg;
		retrieveExistingViewState();
		addUserMessageToCurrentState();
		setNewViewState();
	}

	return;
}

void CommandDone::performDoneOperation() {
	_currentState->doneTask(_commandTaskIndex, _isDoneStatusToSet);

	if (_isDoneStatusToSet) {
		_actionMessage = ACTION_MSG_DONE;
	}
	else {
		_actionMessage = ACTION_MSG_UNDONE;
	}

	_userMessage = STRING_EMPTY;

	sprintf_s(buffer, LOGGING_MSG_PERFORM_DONE.c_str(), 
		to_string(_commandTaskIndex).c_str());
	log(buffer);
	return;
}
	// End of segment: ./\CommandDone.cpp





	/**
	 * origin: ./\CommandDone.h
	 */

//
// This is the concrete CommandDone class, which is reponsible for executing 
// an "done" command specified by the user.
//
// It works by (i) checking for the validity of the command; (ii) retrieving 
// the current state from LogicData; (iii) marking a task as done; (iv) 
// rewriting the current and view states in LogicData; and (v) adding 
// itself to LogicData's command history.
//
// If the command is invalid due to a false parsed status indicating
// it has been parsed incorrectly, an error message will be added to the
// current state to be shown to the user eventually.
//
//****************************************************************************

#pragma once

#include "Command.h"

using namespace std;

const string LOGGING_MSG_EXECUTE_COMMAND_DONE = 
	"\nCommand Done Initiated:\n";
const string LOGGING_MSG_PERFORM_DONE = 
	"Function called: performDoneOperation(): _commandTaskIndex mark"
	"ed as done: %s\n";
const string ACTION_MSG_DONE = 
	"Task marked as Done!";
const string ACTION_MSG_UNDONE = 
	"Task marked as Undone!";

class CommandDone: public Command {
	public:
		CommandDone(void);
		
		/*
		// This API function executes the Done Command when called.
		//
		// Pre-conditions:
		//     (i) There should be a proper task index (and not just a display
		//     task index set as the current task index in the command instance
		//     before execute is called.
		//     (ii) The _isParsedCorrectly variable in the command 
		//     should be true.
		//
		// Post-Conditions:
		//     (i) The specified task will be marked either as done
		//     or undone in LogicData
		//
		// Sample usage:
		//     CommandDone* aDoneCommand = new CommandDone;
		//     aDoneCommand->setTaskIndex(taskIndexToDone);
		//     aDoneCommand->execute();
		*/
		
		void execute();

	protected:

		// Functions For Execution

		void performDoneOperation();
};


	// End of segment: ./\CommandDone.h





	/**
	 * origin: ./\CommandEdit.cpp
	 */


#include "CommandEdit.h"

CommandEdit::CommandEdit(void) {
}

void CommandEdit::execute() {
	sprintf_s(buffer, MSG_LOGGING_EXECUTE_COMMAND_EDIT.c_str());
	log(buffer);
	
	try {
		checkIsParsedCorrectly();
		assert(_currentTask != NULL);
		assert(_commandTaskIndex >= 0);

		retrieveExistingCurrentState();

		checkIsCommandValid();
		deleteExistingTask();
		performAddOperation();
		addThisCommandToHistory(this);

		addUserMessageToCurrentState();
		addActionMessageToCurrentState();
		setNewCurrentState();
		setNewViewState();
	}
	catch (string errorMsg) {
		_userMessage = errorMsg;
		retrieveExistingViewState();
		addUserMessageToCurrentState();
		setNewViewState();
	}

	return;
}

void CommandEdit::deleteExistingTask() {
	_currentState->deleteTask(_commandTaskIndex);

	sprintf_s(buffer, MSG_LOGGING_DELETE_EXISTING_TASK.c_str(), 
		to_string(_commandTaskIndex).c_str());
	log(buffer);
	return;
}

void CommandEdit::performAddOperation() {
	_currentState->addTask(*_currentTask, true, _commandTaskIndex);
	_actionMessage = MSG_ACTION_EDIT;

	sprintf_s(buffer, MSG_LOGGING_PERFORM_ADD.c_str());
	log(buffer);
	return;
}

	// End of segment: ./\CommandEdit.cpp





	/**
	 * origin: ./\CommandEdit.h
	 */

//
// This is the concrete CommandEdit class, which is reponsible for executing 
// an "edit" command specified by the user.
//
// It works by (i) checking for the validity of the command; (ii) retrieving 
// the current state from LogicData; (iii) editing a particular task; (iv) 
// rewriting the current and view states in LogicData; and (v) adding 
// itself to LogicData's command history.
//
// If the command is invalid either due to (i) a false parsed status indicating
// it has been parsed incorrectly; or (ii) incorrect date orderings, an error 
// message will be added to the current state to be shown to the user eventually.
//
//****************************************************************************

#pragma once

#include "CommandAdd.h"

using namespace std;

const string MSG_LOGGING_EXECUTE_COMMAND_EDIT = 
	"\nCommand Edit Initiated:\n";
const string MSG_LOGGING_DELETE_EXISTING_TASK = 
	"Function called: deleteExistingTask(): _commandTaskIndex "
	"deleted: %s\n";
const string MSG_ACTION_EDIT = 
	"Task Edited!";

class CommandEdit: public CommandAdd {
	public:
		CommandEdit(void);
		
		/*
		// This API function executes the Edit Command when called.
		//
		// Pre-conditions:
		//     (i) There should be a proper task set as the current
		//     task in the command instance before execute is called.
		//     (ii) There should be a proper task index to edit set
		//     as the task index in the command instance before execute
		//     is called.
		//     (iii) The _isParsedCorrectly variable in the command 
		//     should be true.
		//
		// Post-Conditions:
		//     (i) The task with the specified task index will be deleted
		//     and replaced with the specified task unless there are logic
		//     errors with the task (such as if the specified task start 
		//     ime is after the end time)
		//
		// Sample usage:
		//     CommandEdit* anEditCommand = new CommandEdit;
		//     anEditCommand->setCurrentTask(taskToEdit);
		//     anEditCommand->setTaskIndex(taskIndexToEdit);
		//     anEditCommand->execute();
		*/
		
		void execute();

	protected:
		
		// Functions For Execution

		void deleteExistingTask();
		void performAddOperation();
};


	// End of segment: ./\CommandEdit.h





	/**
	 * origin: ./\CommandFilter.cpp
	 */


#include "CommandFilter.h"

CommandFilter::CommandFilter(void) {
}

void CommandFilter::execute() {
	sprintf_s(buffer, LOGGING_MSG_EXECUTE_COMMAND_FILTER.c_str());
	log(buffer);
	
	try {
		checkIsParsedCorrectly();
		performFilterOperation();
		retrieveExistingViewState();
		_currentState->setActionMessage(STRING_EMPTY);
		_currentState->setUserMessage(STRING_EMPTY);
		setNewViewState();
	}
	catch (string errorMsg) {
		_userMessage = errorMsg;
		retrieveExistingViewState();
		addUserMessageToCurrentState();
		setNewViewState();
	}

	return;
}

void CommandFilter::performFilterOperation() {
	
	if(_doneFilter != Status::STATUS_NOT_SET) {
		LogicData::setDoneFilter(_doneFilter);
	}
	if(_typeFilter != Type::TYPE_NOT_SET) {
		LogicData::setTypeFilter(_typeFilter);
	}
	if(!_startDateFilter.is_not_a_date() 
			&& !_endDateFilter.is_not_a_date()) {
		LogicData::setDateFilter(_startDateFilter, _endDateFilter);
	}

	retrieveExistingCurrentState();
	_currentState->setLastActionType(State::NONE);
	setNewViewState();
	return;
}
	// End of segment: ./\CommandFilter.cpp





	/**
	 * origin: ./\CommandFilter.h
	 */

//
// This is the concrete CommandFilter class, which is reponsible for executing 
// an "filter" command specified by the user.
//
// It works by (i) checking for the validity of the command; (ii) altering the
// filter settings in LogicData so subsequent filters will be performed as 
// specified by the filter command parameters.
//
// If the command is invalid due to a false parsed status indicating
// it has been parsed incorrectly, an error message will be added to the
// current state to be shown to the user eventually.
//
//****************************************************************************

#pragma once

#include "Command.h"
#include "boost\date_time.hpp"

using namespace std;
using namespace boost::gregorian;
using namespace boost::posix_time;

const string LOGGING_MSG_EXECUTE_COMMAND_FILTER = 
	"\nCommand Filter Initiated:\n";

class CommandFilter: public Command {
	public:
		CommandFilter(void);
		
		/*
		// This API function executes the Filter Command when called.
		//
		// Pre-conditions:
		//     (i) The _isParsedCorrectly variable in the command 
		//     should be true.
		//
		// Post-Conditions:
		//     (i) The done, type, and date filters in LogicData will
		//     be changed according to the _doneFilter, _typeFilter, 
		//     _startDateFilter, and _endDateFilter values in the Command
		//     instance.
		//
		// Sample usage:
		//     CommandFilter* aFilterCommand = new CommandFilter;
		//     aFilterCommand->setDoneFilter(LogicData::DONE_BOTH);
		//     aFilterCommand->execute();
		*/
		
		void execute();

	protected:
		// Functions For Execution

		void performFilterOperation();
};


	// End of segment: ./\CommandFilter.h





	/**
	 * origin: ./\CommandLoad.cpp
	 */


#include "CommandLoad.h"

CommandLoad::CommandLoad(void) {
}

void CommandLoad::execute() {
	sprintf_s(buffer, MSG_LOGGING_EXECUTE_COMMAND_LOAD.c_str());
	log(buffer);
	
	try {
		checkIsParsedCorrectly();
		loadLogicDataSettings();
		retrieveExistingCurrentState();
		resetLastActionType();
		setNewViewState();
	}
	catch (string errorMsg) {
		_userMessage = errorMsg;
		retrieveExistingViewState();
		addUserMessageToCurrentState();
		setNewViewState();
	}

	return;
}

void CommandLoad::loadLogicDataSettings() {
	LogicData::loadInitialSettings();
	sprintf_s(buffer, MSG_LOGGING_LOAD_LOGIC_DATA_SETTINGS.c_str());
	log(buffer);
	return;
}

void CommandLoad::resetLastActionType() {
	_currentState->setLastActionType(State::NONE);
	return;
}
	// End of segment: ./\CommandLoad.cpp





	/**
	 * origin: ./\CommandLoad.h
	 */

//
// This is the concrete CommandLoad class, which is reponsible for executing 
// an "load" command.
//
// It works by calling LogicData to load all its internal data states and
// specifications from the existing external storage.
//
// If the command is invalid either due to a false parsed status indicating
// it has been parsed incorrectly, an error message will be added to the
// current state to be shown to the user eventually.
//
//****************************************************************************

#pragma once

#include "Command.h"

using namespace std;

const string MSG_LOGGING_EXECUTE_COMMAND_LOAD = 
	"\nCommand Load Initiated:\n";
const string MSG_LOGGING_LOAD_LOGIC_DATA_SETTINGS = 
	"Function called: loadLogicDataSettings()\n";

class CommandLoad: public Command {
	public:
		CommandLoad(void);
		
		/*
		// This API function executes the Load Command when called.
		//
		// Pre-conditions: 
		//     (i) The _isParsedCorrectly variable in the command 
		//     should be true.
		//
		// Post-Conditions:
		//     (i) The loadInitialSettings() function in LogicData will 
		//     be called
		//
		// Sample usage:
		//     CommandLoad* aLoadCommand = new CommandLoad;
		//     aLoadCommand->execute();
		*/
		
		void execute();

	protected:
		
		// Functions For Execution

		void loadLogicDataSettings();
		void resetLastActionType();
};


	// End of segment: ./\CommandLoad.h





	/**
	 * origin: ./\CommandRedo.cpp
	 */


#include "CommandRedo.h"

CommandRedo::CommandRedo(void) {
}

void CommandRedo::execute() {
	sprintf_s(buffer, MSG_LOGGING_EXECUTE_COMMAND_REDO.c_str());
	log(buffer);
	retrieveCommandHistory();
	retrieveCommandHistoryIndex();
	
	try {
		checkIsParsedCorrectly();
		assert(_currentCommandHistoryIndex >= 0);
		assert(_currentCommandHistoryIndex <= 
			_commandHistory.size());

		checkIsCommandValid();
		resetLogicDataSettings();
		runAllRelevantCommandsAgain();
		storeRemainingCommandsInHistory();
	}
	catch (string errorMsg) {
		_userMessage = errorMsg;
		retrieveExistingViewState();
		addUserMessageToCurrentState();
		setNewViewState();
	}

	return;
}

bool CommandRedo::checkIsCommandValid() {
	bool isRedoPossible;
	if ((_currentCommandHistoryIndex < 0) 
			|| (_currentCommandHistoryIndex >= 
			_commandHistory.size())) {
		throw MSG_ERROR_CANNOT_REDO_ANYMORE;
		isRedoPossible = false;
	}
	else {
		isRedoPossible = true;
		_currentCommandHistoryIndex++;
	}

	sprintf_s(buffer, MSG_LOGGING_CHECK_IS_COMMAND_VALID.c_str(), 
		to_string(_currentCommandHistoryIndex).c_str(), 
		to_string(isRedoPossible).c_str());
	log(buffer);
	return isRedoPossible;
}
	// End of segment: ./\CommandRedo.cpp





	/**
	 * origin: ./\CommandRedo.h
	 */

//
// This is the concrete CommandRedo class, which is reponsible for executing 
// a "redo" command specified by the user.
//
// It works by (i) checking for the validity of the command; (ii) resetting
// all LogicData's state settings; and (iii) running all the commands from the
// beginning all over again till the correct existing command to simulate a
// redo operation.
//
// If the command is invalid either due to (i) a false parsed status indicating
// it has been parsed incorrectly; or (ii) lack of commands to redo, an error 
// message will be added to the current state to be shown to the user eventually.
//
//****************************************************************************

#pragma once

#include "CommandUndo.h"

using namespace std;

const string MSG_LOGGING_EXECUTE_COMMAND_REDO = 
	"\nCommand Redo Initiated:\n";
const string MSG_ERROR_CANNOT_REDO_ANYMORE = 
	"Cannot redo anymore!";

class CommandRedo: public CommandUndo {
	public:
		CommandRedo(void);
		
		/*
		// This API function executes the Redo Command when called.
		//
		// Pre-conditions: 
		//     (i) LogicData's command history index must be between
		//     one and the size of the command history vector (LogicData
		//     must store a valid command history index.
		//     (ii) The _isParsedCorrectly variable in the command 
		//     should be true.
		//
		// Post-Conditions:
		//     (i) The latest undone action in LogicData's command history 
		//     will be redone. If there is no such action, redo will 
		//     not be performed.
		//
		// Sample usage:
		//     CommandRedo* aRedoCommand = new CommandRedo;
		//     aRedoCommand->execute();
		*/
		
		void execute();

	protected:

		// Functions For Execution

		bool checkIsCommandValid();
};


	// End of segment: ./\CommandRedo.h





	/**
	 * origin: ./\CommandSearch.cpp
	 */


#include "CommandSearch.h"

CommandSearch::CommandSearch(void) {
	_myPowerSearch = new CommandSearchPowerSearch;
}

void CommandSearch::execute() {
	sprintf_s(buffer, MSG_LOGGING_EXECUTE_COMMAND_SEARCH.c_str());
	log(buffer);

	try {
		checkIsParsedCorrectly();
		retrieveExistingCurrentState();
		performSearchOperation();
		setNewViewState();
	}
	catch (string errorMsg) {
		_userMessage = errorMsg;
		retrieveExistingViewState();
		addUserMessageToCurrentState();
		setNewViewState();
	}
	
	return;
}

void CommandSearch::performSearchOperation() {
	getTagsToSearchFor();
	getNameToSearchFor();
	getListOfTaskIndexesNotMatchingSearch();
	deleteListOfTaskIndexesNotMatchingSearch();
	_currentState->setLastActionType(State::NONE);
	_currentState->setUserMessage(STRING_EMPTY);
	return;
}

void CommandSearch::getTagsToSearchFor() {
	int posOfNextTag = 0;
	int posOfCurrentTag = 0;
	int startPos;
	int endPos;
	string currentTag;

	while (_searchKeyword.find(TAG_DELIMITER, posOfNextTag) != 
			string::npos) {
		posOfCurrentTag = _searchKeyword.find(TAG_DELIMITER, 
			posOfNextTag);
		posOfNextTag = _searchKeyword.find(TAG_DELIMITER, 
			posOfCurrentTag+1);

		if (posOfNextTag != string::npos) {
			startPos = posOfCurrentTag + 1;
			endPos = posOfNextTag-posOfCurrentTag - 1;
			currentTag = _searchKeyword.substr(startPos, endPos);
			_tagsToSearchFor.push_back(currentTag);
		}
		else {
			startPos = posOfCurrentTag + 1;
			currentTag = _searchKeyword.substr(startPos);
			_tagsToSearchFor.push_back(currentTag);
			break;
		}
	}

	return;
}

void CommandSearch::getNameToSearchFor() {
	int firstTagPos = _searchKeyword.find(TAG_DELIMITER);
	_stringToSearchFor = _searchKeyword.substr(0,firstTagPos);
	return;
}

void CommandSearch::getListOfTaskIndexesNotMatchingSearch() {
	int i;
	vector<Task> listOfAllTasks = _currentState->getAllTasks();
	
	for (i=0; unsigned(i)<listOfAllTasks.size(); i++) {
		if (!checkIsFitsSearchCriteria(listOfAllTasks[i])) {
			int taskIndexToDelete = listOfAllTasks[i].getTaskIndex();
			_listOfTaskIndexesToDelete.push_back(taskIndexToDelete);
		}
	}
	return;
}

void CommandSearch::deleteListOfTaskIndexesNotMatchingSearch() {
	int i;

	for (i=0; unsigned(i)<_listOfTaskIndexesToDelete.size(); i++) {
		_currentState->deleteTask(_listOfTaskIndexesToDelete[i]);
	}
	return;
}

bool CommandSearch::checkIsFitsSearchCriteria(Task taskToCheck) {
	bool isFitsTagSearchCriteria = 
		checkIsFitsTagSearchCriteria(taskToCheck);
	bool isFitsNameSearchCriteria = 
		checkIsFitsNameSearchCriteria(taskToCheck);
	bool isFitsSearchCriteria = 
		isFitsTagSearchCriteria && isFitsNameSearchCriteria;
	return isFitsSearchCriteria;
}

bool CommandSearch::checkIsFitsTagSearchCriteria(Task taskToCheck) {
	int i;
	int j;
	string taskTag;
	bool isFitsTagSearchCriteria = true;
	bool currentTagFound = false;
	vector<string> listOfTagsForTask = taskToCheck.getTaskTags();

	for (j=0; unsigned(j)<_tagsToSearchFor.size(); j++) {
		for (i=0; unsigned(i)<listOfTagsForTask.size(); i++) {
			taskTag = listOfTagsForTask[i];
			if (convertToLower(taskTag).find(_tagsToSearchFor[j]) 
					!= string::npos) {
				currentTagFound = true;
			}
		}

		if (!currentTagFound) {
			isFitsTagSearchCriteria = false;
			break;
		}
		else {
			currentTagFound = false;
		}
	}

	return isFitsTagSearchCriteria;
}

bool CommandSearch::checkIsFitsNameSearchCriteria(Task taskToCheck) {
	string taskName = taskToCheck.getTaskName();
	bool isFitsNameSearchCriteria = 
		_myPowerSearch->checkIsFound(convertToLower(taskName), 
		_stringToSearchFor);

	return isFitsNameSearchCriteria;
}

string CommandSearch::convertToLower(string toConvert) {
	int i;
	for (i=0; unsigned(i)<toConvert.size(); i++) {
		toConvert[i] = tolower(toConvert[i]);
	}
	return toConvert;
}
	// End of segment: ./\CommandSearch.cpp





	/**
	 * origin: ./\CommandSearch.h
	 */

//
// This is the concrete CommandSearch class, which is reponsible for executing 
// an "search" command specified by the user.
//
// It works by (i) checking for the validity of the command; (ii) retrieving 
// the current state from LogicData; (iii) performing the search operation;
// and (iv) rewriting only the view state in LogicData.
//
// If the command is invalid due to a false parsed status indicating
// it has been parsed incorrectly, an error message will be added to the
// current state to be shown to the user eventually.
//
//****************************************************************************

#pragma once

#include <sstream>
#include "Command.h"
#include "CommandSearchPowerSearch.h"

using namespace std;

const string TAG_DELIMITER = "#";
const string MSG_LOGGING_EXECUTE_COMMAND_SEARCH = 
	"\nCommand Search Initiated:\n";

class CommandSearch: public Command {
	public:
		CommandSearch(void);
		
		/*
		// This API function executes the Search Command when called.
		//
		// Pre-conditions: 
		//     (i) The search keyword should be specified in this particular
		//     format for the separate search of task names and tags to work
		//     properly: "homework #one#two".
		//     (ii) The _isParsedCorrectly variable in the command 
		//     should be true.
		//
		// Post-Conditions:
		//     (i) The current state in LogicData will be filtered according to
		//     the search and the filtered state will beplace the view state in
		//     LogicData.
		//
		// Sample usage:
		//     CommandSearch* aSearchCommand = new CommandSearch;
		//     aSearchCommand->setSearchKeyword("homework #one#two")
		//     aSearchCommand->execute();
		*/
		
		void execute();

	private:
		
		// Attributes For Execution
		
		string _stringToSearchFor;
		vector<string> _tagsToSearchFor;
		vector<int> _listOfTaskIndexesToDelete;
		CommandSearchPowerSearch* _myPowerSearch;
		
		// Functions For Execution
		
		void performSearchOperation();

		// Divides the search string into the multiple tags that
		// may be present so as to search for tags in the program
		// database separately from the task names

		void getTagsToSearchFor();

		// Obtains the task name search string from the entire
		// search string provided in the command

		void getNameToSearchFor();

		// Determine which tasks are to be deleted subsequently
		// as they do not satisfy the search criteria

		void getListOfTaskIndexesNotMatchingSearch();

		// Deletes the tasks which have been marked for deleting
		// because they do not satisfy the search criteria

		void deleteListOfTaskIndexesNotMatchingSearch();

		bool checkIsFitsSearchCriteria(Task taskToCheck);
		bool checkIsFitsTagSearchCriteria(Task taskToCheck);
		bool checkIsFitsNameSearchCriteria(Task taskToCheck);

		string convertToLower(string toConvert);
};


	// End of segment: ./\CommandSearch.h





	/**
	 * origin: ./\CommandSearchPowerSearch.cpp
	 */


#include "CommandSearchPowerSearch.h"

CommandSearchPowerSearch::CommandSearchPowerSearch(void) {
}

CommandSearchPowerSearch::~CommandSearchPowerSearch(void) {
}

bool CommandSearchPowerSearch::checkIsFound(string mainString, 
		string searchString) {
	bool isFound = false;
	_mainString = mainString;
	_remainingString = mainString;
	_searchString = searchString;
	_tokenizedSearchString = tokenizeString(searchString);

	if (checkIsFoundByNormalSearch()) {
		isFound = true;
	}
	else if (checkIsFoundbyPowerSearch()) {
		isFound = true;
	}

	return isFound;
}

bool CommandSearchPowerSearch::checkIsFoundByNormalSearch() {
	bool isFound = false;
	isFound = (_mainString.find(_searchString) != string::npos);
	return isFound;
}

bool CommandSearchPowerSearch::checkIsFoundbyPowerSearch() {
	bool isFound = true;
	bool isTokenFound;
	int i;

	if (checkIsFoundByFuzzySearch(_searchString)) {
		return true;
	}

	// If a match was not found by fuzzysearch, continue to search
	// every token of the search string with acronym search and
	// shorthand search.

	for (i=0; unsigned(i)<_tokenizedSearchString.size(); i++) {
		isTokenFound = 
			powerSearchRemainingString(_tokenizedSearchString[i]);

		if (!isTokenFound) {
			isFound = false;
			break;
		}
	}

	return isFound;
}

bool CommandSearchPowerSearch::powerSearchRemainingString(
		string searchToken) {
	bool isFound = false;

	if (checkIsFoundByShorthandSearch(searchToken)) {
		isFound = true;
	}
	else if (checkIsFoundByAcronymSearch(searchToken)) {
		isFound = true;
	}

	if (isFound) {
		_remainingString = _newRemainingString;
	}

	return isFound;
}

bool CommandSearchPowerSearch::checkIsFoundByFuzzySearch(
		string searchToken) {
	string mainString = _mainString;
	bool isFound = false;
	int mainStringSize = mainString.size();
	int i=0;
	
	for (i=0; unsigned(i)<mainStringSize; i++) {
		if (checkIsMatchesFuzzySearch(mainString, searchToken)) {
			isFound = true;
			break;
		}
		mainString.erase(mainString.begin());
	}
	return isFound;
}

bool CommandSearchPowerSearch::checkIsFoundByShorthandSearch(
		string searchToken) {
	vector<string> tokenizedMainString = 
		tokenizeString(_remainingString);
	bool isFound;
	int indexShorthandLastFound = 0;
	int i;
	int j;

	for (i=0; unsigned(i)<tokenizedMainString.size(); i++) {
		string currentMainToken = tokenizedMainString[i];
		int indexPartialShorthandLastFound = 
			INITIAL_VALUE_PARTIAL_SHORT_HAND_INDEX;
		isFound = true;
		
		for (j=0; unsigned(j)<searchToken.size(); j++) {
			bool isPartialSearchTokenFound = false;

			// If the first character of each word of the search string is 
			// found, set the partial search token to be true. 

			if ((j==0) && (searchToken[0] == currentMainToken[0])) {
				currentMainToken = 
					currentMainToken.substr(
					indexPartialShorthandLastFound);
				isPartialSearchTokenFound = true;
			}

			// If the non-first character of each word of the search string 
			// is found, set the partial search token to be true.

			else if ((j!=0) 
					&& (currentMainToken.find(
					searchToken[j]) != string::npos)){
				indexPartialShorthandLastFound = 
					currentMainToken.find(searchToken[j]);
				currentMainToken = 
					currentMainToken.substr(
					indexPartialShorthandLastFound+1);
				isPartialSearchTokenFound = true;
			}

			if (!isPartialSearchTokenFound) {
				isFound = false;
				break;
			}
		}
		
		// If a particular word in the search string has been found, 
		// craft the remaining main string for subsequent searches
		// and return true as the search token has been found.

		if (isFound) {
			int k;
			indexShorthandLastFound = i;
			for (k=0; unsigned(k)<=indexShorthandLastFound; k++) {
				tokenizedMainString.erase(
					tokenizedMainString.begin());
			}
			_newRemainingString =
				untokenizeString(tokenizedMainString);
			return true;
		}
		
	}

	return false;
}

bool CommandSearchPowerSearch::checkIsFoundByAcronymSearch(
		string searchToken) {
	vector<string> tokenizedMainString = 
		tokenizeString(_remainingString);
	string stringOfMainStringFirstChars = 
		getFirstCharacters(tokenizedMainString);
	string remainingMainStringFirstChars = 
		stringOfMainStringFirstChars;
	bool isFound = true;
	int indexAcronymLastFound = 0;
	int charIndex = 0;
	int i;

	for (i=0; unsigned(i)<searchToken.size(); i++) {
		
		// If a search character is not found, mark isFound 
		// as false.
		
		if (remainingMainStringFirstChars.find(
				searchToken[i]) == string::npos) {
			isFound = false;
			break;
		}

		// Get the remaining main string first characters to
		// search within for the next search character.

		charIndex = 
			remainingMainStringFirstChars.find(searchToken[i]);
		remainingMainStringFirstChars = 
			remainingMainStringFirstChars.substr(charIndex+1);
	}

	indexAcronymLastFound = 
		stringOfMainStringFirstChars.size() - 
		remainingMainStringFirstChars.size();
	for (i=0; unsigned(i)<indexAcronymLastFound; i++) {
		tokenizedMainString.erase(tokenizedMainString.begin());
	}
	_newRemainingString = untokenizeString(tokenizedMainString);

	return isFound;
}



vector<string> CommandSearchPowerSearch::tokenizeString(
		string stringToTokenize) {
	istringstream inputString(stringToTokenize);
	string tokenString;
	vector<string> tokenizedString;

	while (inputString >> tokenString) {
		tokenizedString.push_back(tokenString);
	}

	return tokenizedString;
}

string CommandSearchPowerSearch::untokenizeString(
		vector<string> stringTokens) {
	ostringstream outputString;
	int i;
	
	if (stringTokens.size() > 0) {
		outputString << stringTokens[0];
	}

	for (i=1; unsigned(i)<stringTokens.size(); i++) {
		outputString << " " << stringTokens[i];
	}

	return outputString.str();
}

string CommandSearchPowerSearch::getFirstCharacters(
		vector<string> tokenizedMainString) {
	string listOfFirstCharacters;
	int i;

	for (i=0; unsigned(i)<tokenizedMainString.size(); i++) {
		if (tokenizedMainString[i].size() > 0) {
			listOfFirstCharacters.push_back(
				tokenizedMainString[i][0]);
		}
	}

	return listOfFirstCharacters;
}

bool CommandSearchPowerSearch::checkIsMatchesFuzzySearch(
		string mainToken, string searchToken) {
	vector<int> matchRecord;
	vector<int> errorRecord;
	int defaultError = INITIAL_VALUE_FUZZYSEARCH_DEFAULT_ERROR;
	int idealFoundIndex = 
		INITIAL_VALUE_FUZZYSEARCH_IDEAL_FOUND_INDEX;
	int actualFoundIndex;
	int lowerBound;
	int upperBound;
	int i;
	bool isFound;

	for(i=0; unsigned(i)<searchToken.size(); i++) {
		idealFoundIndex = i;
		lowerBound = idealFoundIndex - defaultError;
		upperBound = idealFoundIndex + defaultError;
		actualFoundIndex = mainToken.find(searchToken[i], 
			toZeroIfNegative(lowerBound));

		if (actualFoundIndex == string::npos) {
			matchRecord.push_back(NOTFOUND);
		}
		else {
			if (isInRange(lowerBound, upperBound, 
					actualFoundIndex)) {
				matchRecord.push_back(FOUND);
			}
			else {
				matchRecord.push_back(NOTFOUND);
			}
		}
	}

	isFound = detIfmatchRecordAcceptable(matchRecord);

	return isFound;
}



bool CommandSearchPowerSearch::isInRange(int lowerBound, 
		int upperBound, int toCheckRange) {

	if (toCheckRange < lowerBound) {
		return false;
	}
	else if (toCheckRange > upperBound) {
		return false;
	}
	return true;
}

int CommandSearchPowerSearch::toZeroIfNegative(int toConvert) {
	if (toConvert >= 0) {
		return toConvert;
	}
	return 0;
}

bool CommandSearchPowerSearch::detIfmatchRecordAcceptable(
		vector<int> matchRecord) {
	double percentageFit;
	double totalSum = 0;
	int i;

	for (i=0; unsigned(i)<matchRecord.size(); i++) {
		totalSum += matchRecord[i];
	}

	percentageFit = totalSum / matchRecord.size();

	if (percentageFit >= FUZZY_SEARCH_MATCH_REORD_TOLERANCE) {
		return true;
	}
	else {
		return false;
	}
}

	// End of segment: ./\CommandSearchPowerSearch.cpp





	/**
	 * origin: ./\CommandSearchPowerSearch.h
	 */

//
// This is powersearch class, which is reponsible for the more detailed logic 
// processing steps which are required for advanced search operations in the
// CommandSearch concrete command class.
//
// It allows for (i) fuzzy searches - not all text need to match in order for 
// a search term to match a task; (ii) shorthand searches - search keywords 
// comprised of the first characters of a task name will match; and (iii) acronym
// searches - search keywords which are fragments of a task name will match.
//
// Sample usage:
//     checkIsFound("i am coding cs2103", "2103");
//
//****************************************************************************

#pragma once

#include <string>
#include <vector>
#include <sstream>

using namespace std;

const int INITIAL_VALUE_PARTIAL_SHORT_HAND_INDEX = 1;
const int INITIAL_VALUE_FUZZYSEARCH_IDEAL_FOUND_INDEX = 0;
const int INITIAL_VALUE_FUZZYSEARCH_DEFAULT_ERROR = 1;
const double FUZZY_SEARCH_MATCH_REORD_TOLERANCE = 0.75;

class CommandSearchPowerSearch {
	public:
		CommandSearchPowerSearch(void);
		~CommandSearchPowerSearch(void);

		bool checkIsFound(string mainString, string searchString);

	private:

		// Attributes For Execution

		string _mainString;
		string _remainingString;
		string _newRemainingString;
		string _searchString;
		vector<string> _tokenizedSearchString;

		enum FoundType{
			FOUND = 1, NOTFOUND = 0
		};
		
		// Functions For Execution

		bool checkIsFoundByNormalSearch();
		bool checkIsFoundbyPowerSearch();

		// Performs a shorthand and acronym search on the mainstring
		// according to the substring to determine if the mainstring
		// matches the search criteria.

		bool powerSearchRemainingString(string remainingString);
		bool checkIsMatchesFuzzySearch(string mainToken, 
			string searchToken);
		bool checkIsFoundByFuzzySearch(string searchToken);
		bool checkIsFoundByShorthandSearch(string searchToken);
		bool checkIsFoundByAcronymSearch(string searchToken);
		
		// Breaks a given string delimited by spaces into individual
		// words stored in a vector of strings and returns the vector

		vector<string> tokenizeString(string stringToTokenize);

		// Recombines a given vector of strings (each containing a word)
		// back into a single string with spaces separating the words 
		// and returns the string

		string untokenizeString(vector<string> stringTokens);

		// Returns a string comprised of the first characters of each
		// word in a given tokenized string (in a vector of strings)

		string getFirstCharacters(vector<string>tokenizedMainString);

		bool isInRange(int lowerBound, int upperBound, 
			int toCheckRange);
		int toZeroIfNegative(int toConvert);

		// Determines if a match record containing information on whether
		// each letter in the mainstring has been successfully matched 
		// with the substring is acceptable according to predefined
		// tolerance limits

		bool detIfmatchRecordAcceptable(vector<int> matchRecord);
};


	// End of segment: ./\CommandSearchPowerSearch.h





	/**
	 * origin: ./\CommandUndo.cpp
	 */


#include "CommandUndo.h"

CommandUndo::CommandUndo(void) {
}

void CommandUndo::execute() {
	sprintf_s(buffer, MSG_LOGGING_EXECUTE_COMMAND_UNDO.c_str());
	log(buffer);
	retrieveCommandHistory();
	retrieveCommandHistoryIndex();
	
	try {
		checkIsParsedCorrectly();
		assert(_currentCommandHistoryIndex >= 0);
		assert(_currentCommandHistoryIndex <= _commandHistory.size());

		checkIsCommandValid();
		resetLogicDataSettings();
		runAllRelevantCommandsAgain();
		storeRemainingCommandsInHistory();
	}
	catch (string errorMsg) {
		_userMessage = errorMsg;
		retrieveExistingViewState();
		addUserMessageToCurrentState();
		setNewViewState();
	}

	return;
}

void CommandUndo::runAllRelevantCommandsAgain() {
	int i;
	for (i=0; i<_currentCommandHistoryIndex; i++) {
		_commandHistory[i]->execute();
	}

	sprintf_s(buffer, 
		MSG_LOGGING_RUN_RELEVANT_COMMANDS_AGAIN.c_str(), 
		to_string(_currentCommandHistoryIndex).c_str());
	log(buffer);
	return;
}

void CommandUndo::storeRemainingCommandsInHistory() {
	int i;
	for (i=_currentCommandHistoryIndex; 
			unsigned(i)<_commandHistory.size(); i++) {
		LogicData::addCommandToHistory(_commandHistory[i]);
	}
	LogicData::setCommandHistoryIndex(_currentCommandHistoryIndex);

	sprintf_s(buffer, MSG_LOGGING_STORE_REMAINING_COMMANDS.c_str(), 
		to_string(_commandHistory.size()).c_str(), 
		to_string(_currentCommandHistoryIndex).c_str());
	log(buffer);
	return;
}

bool CommandUndo::checkIsCommandValid() {
	bool isUndoPossible;
	if ((_currentCommandHistoryIndex <= 0) 
			|| (_currentCommandHistoryIndex > _commandHistory.size())) {
		throw MSG_ERROR_CANNOT_UNDO_ANYMORE;
		isUndoPossible = false;
	}
	else {
		isUndoPossible = true;
		_currentCommandHistoryIndex--;
	}

	sprintf_s(buffer, MSG_LOGGING_CHECK_IS_COMMAND_VALID.c_str(), 
		to_string(_currentCommandHistoryIndex).c_str(), 
		to_string(isUndoPossible).c_str());
	log(buffer);
	return isUndoPossible;
}

void CommandUndo::retrieveCommandHistory() {
	_commandHistory = LogicData::getCommandHistory();

	sprintf_s(buffer, MSG_LOGGING_RETRIEVE_COMMAND_HISTORY.c_str(), 
		to_string(_commandHistory.size()).c_str());
	log(buffer);
	return;
}

void CommandUndo::retrieveCommandHistoryIndex() {
	_currentCommandHistoryIndex = 
		LogicData::getCurrentCommandHistoryIndex();

	sprintf_s(buffer, 
		MSG_LOGGING_RETRIEVE_COMMAND_HISTORY_INDEX.c_str(), 
		to_string(_currentCommandHistoryIndex).c_str());
	log(buffer);
	return;
}

	// End of segment: ./\CommandUndo.cpp





	/**
	 * origin: ./\CommandUndo.h
	 */

// 
// This is the concrete CommandUndo class, which is reponsible for executing 
// a "undo" command specified by the user.
//
// It works by (i) checking for the validity of the command; (ii) resetting
// all LogicData's state settings; and (iii) running all the commands from the
// beginning all over again till the correct existing command to simulate an
// undo operation.
//
// If the command is invalid either due to (i) a false parsed status indicating
// it has been parsed incorrectly; or (ii) lack of past commands to undo, an error 
// message will be added to the current state to be shown to the user eventually.
//
//****************************************************************************

#pragma once

#include "Command.h"

using namespace std;

const string MSG_LOGGING_EXECUTE_COMMAND_UNDO = 
	"\nCommand Add Initiated:\n";
const string MSG_LOGGING_RUN_RELEVANT_COMMANDS_AGAIN = 
	"Function called: runAllRelevantCommandsAgain(): _currentCommand"
	"HistoryIndex: %s\n";
const string MSG_LOGGING_STORE_REMAINING_COMMANDS = 
	"Function called: storeRemainingCommandsInHistory(): size of _co"
	"mmandHistory: %s\nFunction called: storeRemainingCommandsInHist"
	"ory(): _currentCommandHistoryIndex: %s\n";
const string MSG_LOGGING_CHECK_IS_COMMAND_VALID = 
	"Function called: checkIsCommandValid(): updated _currentCommand"
	"HistoryIndex: %s\nFunction called: checkIsCommandValid(): isUnd"
	"o/RedoPossible: %s\n";
const string MSG_LOGGING_RETRIEVE_COMMAND_HISTORY = 
	"Function called: retrieveCommandHistory(): size of CommandHisto"
	"ry: %s\n";
const string MSG_LOGGING_RETRIEVE_COMMAND_HISTORY_INDEX = 
	"Function called: retrieveCommandHistoryIndex(): _currentCommand"
	"HistoryIndex: %s\n";

const string MSG_ERROR_CANNOT_UNDO_ANYMORE = 
	"Cannot undo anymore!";

class CommandUndo: public Command {
	public:
		CommandUndo(void);
		
		/*
		// This API function executes the Undo Command when called.
		//
		// Pre-conditions: 
		//     (i) LogicData's command history index must be between
		//     one and the size of the command history vector (LogicData
		//     must store a valid command history index.
		//     (ii) The _isParsedCorrectly variable in the command 
		//     should be true.
		//
		// Post-Conditions:
		//     (i) The latest done action in LogicData's command history 
		//     will be undone. If there is no such action, undo will 
		//     not be performed.
		//
		// Sample usage:
		//     CommandUndo* aUndoCommand = new CommandUndo;
		//     aUndoCommand->execute();
		*/
		
		void execute();

	protected:

		// Attributes For Execution

		int _currentCommandHistoryIndex;
		vector<Command*> _commandHistory;
		
		// Functions For Execution

		bool checkIsCommandValid();
		void runAllRelevantCommandsAgain();
		void storeRemainingCommandsInHistory();
		void retrieveCommandHistory();
		void retrieveCommandHistoryIndex();
};


	// End of segment: ./\CommandUndo.h





	/**
	 * origin: ./\KeyPressEater.cpp
	 */


#include "KeyPressEater.h"


KeyPressEater::KeyPressEater() {
}

KeyPressEater::~KeyPressEater(void) {
}

bool KeyPressEater::eventFilter(QObject *obj, QEvent *event) {
	if (event->type() == QEvent::KeyPress) {
		QKeyEvent *keyEvent = static_cast<QKeyEvent*>(event);
		if (keyEvent->key() == Qt::Key_Return) {
			emit enterPressed(obj);
			return true;
		}
		else if (keyEvent->key() == Qt::Key_Tab) {
			emit tabPressed();
			return true;
		}
		else {
			return QObject::eventFilter(obj, event);
		}
	}
	else {
		return QObject::eventFilter(obj, event);
	}
}

	// End of segment: ./\KeyPressEater.cpp





	/**
	 * origin: ./\KeyPressEater.h
	 */

// 
// This is the KeyPressEater class, which is reponsible for intercepting all 
// key events for certain QWidgets for which it is installed, and determining if
// certain keys have been entered.
//
// It intercepts only the "Key_Return" and the "Key_Tab" keypress, and emits a 
// signal when this happens. Otherwise, all other key presses are ignored.
//
//****************************************************************************

#pragma once
#include <QObject>
#include <QEvent>
#include <QKeyEvent>

class KeyPressEater : public QObject {
	
	Q_OBJECT

	public:
		KeyPressEater();
		~KeyPressEater(void);
		bool eventFilter(QObject *obj, QEvent *event);

	signals:
		void enterPressed(QObject *obj);
		void tabPressed();

};

	// End of segment: ./\KeyPressEater.h





	/**
	 * origin: ./\LogicExecutor.cpp
	 */


#include "LogicExecutor.h"


LogicExecutor::LogicExecutor(void)
{
}

State LogicExecutor::getNewState(string commandLineInput) {
	LogicParser parser;
 	Command* currentCommand = 
		parser.getCommandFromUserInput(commandLineInput);
	currentCommand->execute();
	State stateToReturn = LogicData::getViewState();
	return stateToReturn;
}
	// End of segment: ./\LogicExecutor.cpp





	/**
	 * origin: ./\LogicExecutor.h
	 */

// 
//This is the interface class to the entire Logic component. When called with 
// the getNewState(string commandString) method, it is guaranteed to return an 
// updated view state which may be used to update the GUI (for example).
//
// This class works by (i) obtaining a command object from the LogicParser with  
// the commandString; (ii) executing the concrete command object; and (iii) 
// retrieving the updated viewState from LogicData which is returned in its
// function call.
//
// If an error has occurred during the processing of the commandString, the 
// concrete command objects will terminate execution midway and store details 
// of the failed execution in the returned state, which may be used for 
// subsequent update purposes.
//
// If a warning (not serious but worthy of note) occurs instead, the concrete
// command objects will continue execution as per normal but still store details
// of the warning in the returned state, which may also be used for subsequent 
// update purposes.
//
// Sample usage:
//    State newState = LogicExecutor::getNewState("/load");
//
//****************************************************************************

#pragma once

#include "State.h"
#include "Task.h"
#include "LogicParser.h"
#include "Command.h"

using namespace std;

class LogicExecutor {
	public:
		LogicExecutor(void);
		
		/*
		// This API function returns a new state when given a string
		// variable - commandLineInput.
		//
		// Pre-conditions:
		//     (i) If the user command contains a task index, it should
		//     be the true task index instead of the GUI's display task
		//     index.
		//     (ii) The _isParsedCorrectly variable in the command 
		//     should be true.
		//
		// Post-Conditions:
		//     (i) The command implied by the commandLineInput will be
		//     executed and the new updated state will be returned.
		//     (ii) If there are any warnings or errors arising from
		//     the command implied by the commandLine Input, there will
		//     be an error message returned in the updated state.
		//
		// Sample usage:
		//     LogicExecutor::getNewState("Do hw tmr");
		*/
		
		static State getNewState(string commandLineInput);


};


	// End of segment: ./\LogicExecutor.h





	/**
	 * origin: ./\main.cpp
	 */


#include "whattodo.h"
#include <QtWidgets/QApplication>
#include <string>

using namespace std;

int main(int argc, char *argv[])
{
	string exeDirectory;
	QApplication mainApplication(argc, argv);
	exeDirectory = mainApplication.applicationDirPath().toStdString();
	WhatToDo mainWindow(exeDirectory);
	mainWindow.show();
	return mainApplication.exec();
}

	// End of segment: ./\main.cpp





	/**
	 * origin: ./\whattodo.cpp
	 */


#include "whattodo.h"


WhatToDo::WhatToDo(string exeDirectory, QWidget *parent)
	: QMainWindow(parent) {
	_exeDirectory = exeDirectory;
	_ui.setupUi(this);
	setupOtherUIConfigs();
	setupCalendar();
	setupKeyPressEater();
	defineAllHotkeys();
	connectAllOtherSignalAndSlots();
	loadSavedSettings();
}

WhatToDo::~WhatToDo() {
}



void WhatToDo::handleKeyPressEvents(QObject* obj) {
	if (obj == _ui.commandSearch) {
		updateGUIFromSearchBar();
	}
	else if (obj == _ui.commandLine) {
		updateGUIFromCommandLine();
	}
	return;
}

void WhatToDo::handleEntryFieldTab() {
	if (_ui.commandLine->hasFocus()) {
		_ui.commandSearch->setFocus();
	}
	else {
		_ui.commandLine->setFocus();
	}
	return;
}

void WhatToDo::handleEntryIntoSearchBar() {
	_ui.commandSearch->setFocus();
	_ui.commandSearch->selectAll();
	return;
}

void WhatToDo::handleSearchBarChange() {
	updateGUIFromSearchBar();
	return;
}


void WhatToDo::handleHotkeyMinimize() {
	this->showMinimized();
	return;
}

void WhatToDo::handleHotkeyEdit() {
	_ui.commandLine->setFocus();

	// Add the command parameter into the command entry field

	_ui.commandLine->setPlainText(
		QString::fromStdString(COMMAND_PARAM_EDIT + 
		STRING_SPACE_CHAR));
	
	// Move cursor to the end of the command entry field

	QTextCursor cursor = _ui.commandLine->textCursor();
	cursor.movePosition(QTextCursor::End, QTextCursor::MoveAnchor);
	_ui.commandLine->setTextCursor(cursor);
	return;
}

void WhatToDo::handleHotkeyDelete() {
	_ui.commandLine->setFocus();

	// Add the command parameter into the command entry field

	_ui.commandLine->setPlainText(
		QString::fromStdString(COMMAND_PARAM_DELETE + 
		STRING_SPACE_CHAR));
	
	// Move cursor to the end of the command entry field

	QTextCursor cursor = _ui.commandLine->textCursor();
	cursor.movePosition(QTextCursor::End, QTextCursor::MoveAnchor);
	_ui.commandLine->setTextCursor(cursor);
	return;
}

void WhatToDo::handleHotkeyDone() {
	_ui.commandLine->setFocus();
	
	// Add the command parameter into the command entry field

	_ui.commandLine->setPlainText(
		QString::fromStdString(COMMAND_PARAM_DONE + 
		STRING_SPACE_CHAR));
	
	// Move cursor to the end of the command entry field

	QTextCursor cursor = _ui.commandLine->textCursor();
	cursor.movePosition(QTextCursor::End, QTextCursor::MoveAnchor);
	_ui.commandLine->setTextCursor(cursor);
	return;
}

void WhatToDo::handleHotkeyUndone() {
	_ui.commandLine->setFocus();
	
	// Add the command parameter into the command entry field

	_ui.commandLine->setPlainText(
		QString::fromStdString(COMMAND_PARAM_UNDONE + 
		STRING_SPACE_CHAR));
	
	// Move cursor to the end of the command entry field

	QTextCursor cursor = _ui.commandLine->textCursor();
	cursor.movePosition(QTextCursor::End, QTextCursor::MoveAnchor);
	_ui.commandLine->setTextCursor(cursor);
	return;
}

void WhatToDo::handleHotkeyFilter() {
	_ui.commandLine->setFocus();
	
	// Add the command parameter into the command entry field

	_ui.commandLine->setPlainText(
		QString::fromStdString(COMMAND_PARAM_FILTER + 
		STRING_SPACE_CHAR));
	
	// Move cursor to the end of the command entry field

	QTextCursor cursor = _ui.commandLine->textCursor();
	cursor.movePosition(QTextCursor::End, QTextCursor::MoveAnchor);
	_ui.commandLine->setTextCursor(cursor);
	return;
}

void WhatToDo::handleHotkeyClear() {
	updateGUIWithCommandString(COMMAND_PARAM_CLEAR);
	return;
}

void WhatToDo::handleHotkeyHelp() {
	updateGUIWithCommandString(COMMAND_PARAM_HELP);
	return;
}


void WhatToDo::handleButtonUndo() {
	updateGUIWithCommandString(COMMAND_PARAM_UNDO);
	return;
}

void WhatToDo::handleButtonRedo() {
	updateGUIWithCommandString(COMMAND_PARAM_REDO);
	return;
}

void WhatToDo::handleButtonToggleCalendar() {
	updateCalendarView();
	
	// Move the calendar to a viewable position in the GUi
	
	_ui.calendarframe->move(20, 70);
	_ui.calendarbtn_next->move(290, 10);
	_ui.calendarbtn_prev->move(220, 10);

	// Bring the calendar to the front of all elements in the GUi
	// so it may be visible to the user

	_ui.calendarframe->raise();
	_ui.calendarbtn_next->raise();
	_ui.calendarbtn_prev->raise();
	return;
}

void WhatToDo::handleButtonCalendarPrev(){
	_SFMLView->prevPage();
}

void WhatToDo::handleButtonCalendarNext(){
	_SFMLView->nextPage();
}

void WhatToDo::handleButtonToggleAgenda() {
	updateAgendaView();
	
	// Move the calendar to an out-of-sight position in the GUi
	
	_ui.calendarframe->move(9999, 9999);
	_ui.calendarbtn_next->move(9999, 9999);
	_ui.calendarbtn_prev->move(9999, 9999);
}

void WhatToDo::handleCalendarCommands(string command) {
	updateGUIWithCommandString(command);
}



void WhatToDo::setupCalendar() {
	
	// Move the calendar frame to an out-of-sight position 
	// in the GUi initially
	
	_ui.calendarframe->move(9999, 9999);
	_ui.calendarbtn_next->move(9999, 9999);
	_ui.calendarbtn_prev->move(9999, 9999);
	_ui.calendarframe->setAttribute(Qt::WA_TransparentForMouseEvents);

	// Create the calendar view and show it to the user

	_SFMLView = new CalendarCanvas(this, _ui.calendarframe, 
		QPoint(0, 0), QSize(921, 501));
	_SFMLView->show();
	_b_calender_init_complete = true;
	return;
}

void WhatToDo::setupKeyPressEater() {
	_myKeyPressEater = new KeyPressEater();
	_ui.commandLine->installEventFilter(_myKeyPressEater);
	_ui.commandSearch->installEventFilter(_myKeyPressEater);
	return;
}

void WhatToDo::setupOtherUIConfigs() {
	setupInitialGUIFocusConfigs();
	setupInitialGUISizeConfigs();
	setupMessageBoxConfigs();
	setupTextSizeConfigs();
	return;
}

void WhatToDo::connectAllOtherSignalAndSlots() {
	QObject* decViewPointer;

	decViewPointer = _ui.buttonUndo->rootObject();
	connect(decViewPointer, SIGNAL(buttonClick()), 
		this, SLOT(handleButtonUndo()));
	decViewPointer = _ui.buttonRedo->rootObject();
	connect(decViewPointer, SIGNAL(buttonClick()), 
		this, SLOT(handleButtonRedo()));
	decViewPointer = _ui.buttonAgendaview->rootObject();
	connect(decViewPointer, SIGNAL(buttonClick()), 
		this, SLOT(handleButtonToggleAgenda()));
	decViewPointer = _ui.buttonCalendarview->rootObject();
	connect(decViewPointer, SIGNAL(buttonClick()), 
		this, SLOT(handleButtonToggleCalendar()));
	connect(_myKeyPressEater, SIGNAL(enterPressed(QObject*)), 
		this, SLOT(handleKeyPressEvents(QObject*)));
	connect(_myKeyPressEater, SIGNAL(tabPressed()), 
		this, SLOT(handleEntryFieldTab()));
	connect(_ui.commandSearch, SIGNAL(textChanged()), 
		this, SLOT(handleSearchBarChange()));
	connect(_ui.calendarbtn_prev, SIGNAL(released()),
		this, SLOT(handleButtonCalendarPrev()));
	connect(_ui.calendarbtn_next, SIGNAL(released()),
		this, SLOT(handleButtonCalendarNext()));

	return;
}

void WhatToDo::defineAllHotkeys() {
	
	// Define the QAction objects used to define hotkeys

	QAction *hotkeyUndo = new QAction(this);
	QAction *hotkeyRedo = new QAction(this);
	QAction *hotkeyFind = new QAction(this);
	QAction *hotkeyMinimize = new QAction(this);
	QAction *hotkeyDelete = new QAction(this);
	QAction *hotkeyEdit = new QAction(this);
	QAction *hotkeyDone = new QAction(this);
	QAction *hotkeyUndone = new QAction(this);
	QAction *hotkeyFilter = new QAction(this);
	QAction *hotkeyClear = new QAction(this);
	QAction *hotkeyHelp = new QAction(this);

	// Define the hotkeys available to the user

	hotkeyUndo->setShortcut(Qt::Key_S | Qt::CTRL | Qt::SHIFT);
	hotkeyRedo->setShortcut(Qt::Key_D | Qt::CTRL | Qt::SHIFT);
	hotkeyFind->setShortcut(Qt::Key_F | Qt::CTRL);
	hotkeyMinimize->setShortcut(Qt::Key_Space | Qt::CTRL);
	hotkeyDelete->setShortcut(Qt::Key_W | Qt::CTRL);
	hotkeyEdit->setShortcut(Qt::Key_E | Qt::CTRL);
	hotkeyDone->setShortcut(Qt::Key_D | Qt::CTRL);
	hotkeyUndone->setShortcut(Qt::Key_R | Qt::CTRL);
	hotkeyFilter->setShortcut(Qt::Key_Q | Qt::CTRL);
	hotkeyClear->setShortcut(Qt::Key_Escape);
	hotkeyHelp->setShortcut(Qt::Key_H | Qt::CTRL);

	// Connect the defined hotkeys to the relevant event handlers

	connect(hotkeyUndo, SIGNAL(triggered()), 
		this, SLOT(handleButtonUndo()));
	connect(hotkeyRedo, SIGNAL(triggered()), 
		this, SLOT(handleButtonRedo()));
	connect(hotkeyFind, SIGNAL(triggered()), 
		this, SLOT(handleEntryIntoSearchBar()));
	connect(hotkeyMinimize, SIGNAL(triggered()), 
		this, SLOT(handleHotkeyMinimize()));
	connect(hotkeyDelete, SIGNAL(triggered()), 
		this, SLOT(handleHotkeyDelete()));
	connect(hotkeyEdit, SIGNAL(triggered()), 
		this, SLOT(handleHotkeyEdit()));
	connect(hotkeyDone, SIGNAL(triggered()), 
		this, SLOT(handleHotkeyDone()));
	connect(hotkeyUndone, SIGNAL(triggered()), 
		this, SLOT(handleHotkeyUndone()));
	connect(hotkeyFilter, SIGNAL(triggered()), 
		this, SLOT(handleHotkeyFilter()));
	connect(hotkeyClear, SIGNAL(triggered()), 
		this, SLOT(handleHotkeyClear()));
	connect(hotkeyHelp, SIGNAL(triggered()), 
		this, SLOT(handleHotkeyHelp()));

	// Add these defined hotkeys to the GUI

	_ui.centralWidget->addAction(hotkeyUndo);
	_ui.centralWidget->addAction(hotkeyRedo);
	_ui.centralWidget->addAction(hotkeyFind);
	_ui.centralWidget->addAction(hotkeyMinimize);
	_ui.centralWidget->addAction(hotkeyDelete);
	_ui.centralWidget->addAction(hotkeyEdit);
	_ui.centralWidget->addAction(hotkeyDone);
	_ui.centralWidget->addAction(hotkeyUndone);
	_ui.centralWidget->addAction(hotkeyFilter);
	_ui.centralWidget->addAction(hotkeyClear);
	_ui.centralWidget->addAction(hotkeyHelp);

	return;
}

void WhatToDo::loadSavedSettings() {
	refreshCurrStateWithCommand(COMMAND_PARAM_LOAD);
	updateAgendaView();
	updateCalendarView();
	return;
}


void WhatToDo::setupInitialGUIFocusConfigs() {
	_ui.commandLine->setFocus();
	return;
}

void WhatToDo::setupInitialGUISizeConfigs() {
	this->setFixedSize(GUI_PARAM_SIZE_WIDTH, GUI_PARAM_SIZE_HEIGHT);
	return;
}

void WhatToDo::setupMessageBoxConfigs() {

	// Set the message box view as transparent to the user and 
	// transparent to mouse events

	_ui.messageFeedback->setAttribute(Qt::WA_TranslucentBackground);
	_ui.messageFeedback->setStyleSheet(
		QString::fromStdString(QTSTYLESHEET_TRANSPARENT_BACKGROUND));
	_ui.messageFeedback->setAttribute(Qt::WA_TransparentForMouseEvents);
	return;
}

void WhatToDo::setupTextSizeConfigs() {
	_ui.displayAgendaviewFloat->setTextSizeMultiplier(
		GUI_PARAM_TEXT_MULTIPLIER);
	_ui.displayAgendaviewTimed->setTextSizeMultiplier(
		GUI_PARAM_TEXT_MULTIPLIER);
	return;
}



void WhatToDo::showLogicUserFeedback() {
	string userMessage = _currState.getUserMessage();
	string actionMessage = _currState.getActionMessage();

	// If there is a user-message to display, set the user message
	// in the popup and start the animation for the popup.
	//
	// Otherwise, if there is no user message to display, update the
	// statusbar with the correct user action message

	if (userMessage != STRING_EMPTY) {
		QObject* decViewPointer = _ui.messageFeedback->rootObject();
		decViewPointer->setProperty(
			GUI_PARAM_POPUP_PROPERTY_MESSAGE.c_str(), 
			QString::fromStdString(userMessage));
		decViewPointer->setProperty(
			GUI_PARAM_POPUP_PROPERTY_OPACITY.c_str(), 1.0);
		decViewPointer->setProperty(
			GUI_PARAM_POPUP_PROPERTY_ISANIMATE.c_str(), false);
		decViewPointer->setProperty(
			GUI_PARAM_POPUP_PROPERTY_ISANIMATE.c_str(), true);
		_currState.setUserMessage(STRING_EMPTY);
		_ui.statusBar->setPlainText(
			QString::fromStdString(GUI_PARAM_STATUS_TITLE + 
			userMessage));
	}
	else {
		_ui.statusBar->setPlainText(
			QString::fromStdString(GUI_PARAM_STATUS_TITLE + 
			actionMessage));
	}
	return;
}

void WhatToDo::showGUIUserFeedback(string guiUserFeedback) {
	
	// Set the user message in the popup and start the animation 
	// for the popup, taking the input parameter guiUserFeedback
	// as the user message to be displayed.

	QObject* decViewPointer = _ui.messageFeedback->rootObject();
	decViewPointer->setProperty(
		GUI_PARAM_POPUP_PROPERTY_MESSAGE.c_str(), 
		QString::fromStdString(guiUserFeedback));
	decViewPointer->setProperty(
		GUI_PARAM_POPUP_PROPERTY_OPACITY.c_str(), 1.0);
	decViewPointer->setProperty(
		GUI_PARAM_POPUP_PROPERTY_ISANIMATE.c_str(), false);
	decViewPointer->setProperty(
		GUI_PARAM_POPUP_PROPERTY_ISANIMATE.c_str(), true);
	_currState.setActionMessage(STRING_EMPTY);
	_ui.statusBar->setPlainText(
		QString::fromStdString(
		GUI_PARAM_STATUS_TITLE + guiUserFeedback));
	return;
}


void WhatToDo::updateGUIFromSearchBar() {
	string userSearchString;
	string logicComandString;

	userSearchString = 
		_ui.commandSearch->toPlainText().toStdString();
	userSearchString = removeUnwantedChars(userSearchString);
	
	// Only construct and process a search command for the user 
	// automatically when the search bar's contents are not empty.
	//
	// If the search bar's contents are empty, construct and process
	// a clear command for the user automatically.

	if (userSearchString == STRING_EMPTY) {
		logicComandString = COMMAND_PARAM_CLEAR;
	}
	else {
		logicComandString = COMMAND_PARAM_SEARCH + STRING_SPACE_CHAR + 
			userSearchString;
	}

	updateGUIWithCommandString(logicComandString);
	return;
}

void WhatToDo::updateGUIFromCommandLine() {
	bool isUserCommandValid;
	string usercommandString;
	string logicComandString;

	usercommandString = 
		_ui.commandLine->toPlainText().toStdString();
	usercommandString = 
		removeUnwantedChars(usercommandString);

	_ui.commandLine->setHtml(QString::fromStdString(STRING_EMPTY));
	
	// Only process the user's command when it is valid. Otherwise,
	// show any error message that was created because of invalid commands.

	try {
		checkIsUserCommandInputValid(usercommandString);
		updateGUIWithCommandString(usercommandString);
	}
	catch (string errMsg) {
		showGUIUserFeedback(errMsg);
	}

	return;
}

void WhatToDo::updateGUIWithCommandString(string commandString) {
	int commandType;

	try {
		commandType = determineCommandType(commandString);
	}
	catch (string errorMsg) {
		return;
	}

	switch (commandType) {
		case COMMAND_DONE_WITH_REAL_INDEX: {
			try {
				processCommandDone(commandString, true);
			}
			catch (string errorMsg) {
				showGUIUserFeedback(errorMsg);
			}
			break;
		}
		case COMMAND_UNDONE_WITH_REAL_INDEX: {
			try {
				processCommandUndone(commandString, true);
			}
			catch (string errorMsg) {
				showGUIUserFeedback(errorMsg);
			}
			break;
		}
		case COMMAND_DELETE_WITH_REAL_INDEX: {
			try {
				processCommandDelete(commandString, true);
			}
			catch (string errorMsg) {
				showGUIUserFeedback(errorMsg);
			}
			break;
		}
		case COMMAND_EDIT: {
			try {
				processCommandEdit(commandString);
			}
			catch (string errorMsg) {
				showGUIUserFeedback(errorMsg);
			}
			break;
		}
		case COMMAND_DONE: {
			try {
				processCommandDone(commandString, false);
			}
			catch (string errorMsg) {
				showGUIUserFeedback(errorMsg);
			}
			break;
		}
		case COMMAND_UNDONE: {
			try {
				processCommandUndone(commandString, false);
			}
			catch (string errorMsg) {
				showGUIUserFeedback(errorMsg);
			}
			break;
		}
		case COMMAND_DELETE: {
			try {
				processCommandDelete(commandString, false);
			}
			catch (string errorMsg) {
				showGUIUserFeedback(errorMsg);
			}
			break;
		}
		case COMMAND_UNDO: {
			try {
				processCommandOthers(commandString);
				processCommandOthers(COMMAND_PARAM_CLEAR);
			}
			catch (string errorMsg) {
				showGUIUserFeedback(errorMsg);
			}
			break;
		}
		case COMMAND_OTHERS: {
			try {
				processCommandOthers(commandString);
			}
			catch (string errorMsg) {
				return;
			}
			break;
		}
		case COMMAND_HELP: {
			string fullHelpDirectory = 
				_exeDirectory + RESOURCE_PATHS_HELP_CONTENT;
			_ui.displayAgendaviewTimed->load(
				QUrl::fromLocalFile(
				QString::fromStdString(fullHelpDirectory)));
			break;
		}
		case COMMAND_HELP_ADD: {
			string fullHelpDirectory = 
				_exeDirectory + RESOURCE_PATHS_HELP_ADD;
			_ui.displayAgendaviewTimed->load(
				QUrl::fromLocalFile(
				QString::fromStdString(fullHelpDirectory)));
			break;
		}
		case COMMAND_HELP_EDIT: {
			string fullHelpDirectory = 
				_exeDirectory + RESOURCE_PATHS_HELP_EDIT;
			_ui.displayAgendaviewTimed->load(
				QUrl::fromLocalFile(
				QString::fromStdString(fullHelpDirectory)));
			break;
		}
		case COMMAND_HELP_DONE: {
			string fullHelpDirectory = 
				_exeDirectory + RESOURCE_PATHS_HELP_DONE;
			_ui.displayAgendaviewTimed->load(
				QUrl::fromLocalFile(
				QString::fromStdString(fullHelpDirectory)));
			break;
		}
		case COMMAND_HELP_DELETE: {
			string fullHelpDirectory = 
				_exeDirectory + RESOURCE_PATHS_HELP_DELETE;
			_ui.displayAgendaviewTimed->load(
				QUrl::fromLocalFile(
				QString::fromStdString(fullHelpDirectory)));
			break;
		}
		case COMMAND_HELP_SEARCH: {
			string fullHelpDirectory = 
				_exeDirectory + RESOURCE_PATHS_HELP_SEARCH;
			_ui.displayAgendaviewTimed->load(
				QUrl::fromLocalFile(
				QString::fromStdString(fullHelpDirectory)));
			break;
		}
		case COMMAND_HELP_CLEAR: {
			string fullHelpDirectory = 
				_exeDirectory + RESOURCE_PATHS_HELP_CLEAR;
			_ui.displayAgendaviewTimed->load(
				QUrl::fromLocalFile(
				QString::fromStdString(fullHelpDirectory)));
			break;
		}
		case COMMAND_HELP_UNDO: {
			string fullHelpDirectory = 
				_exeDirectory + RESOURCE_PATHS_HELP_UNDO;
			_ui.displayAgendaviewTimed->load(
				QUrl::fromLocalFile(
				QString::fromStdString(fullHelpDirectory)));
			break;
		}
		case COMMAND_HELP_REDO: {
			string fullHelpDirectory = 
				_exeDirectory + RESOURCE_PATHS_HELP_REDO;
			_ui.displayAgendaviewTimed->load(
				QUrl::fromLocalFile(
				QString::fromStdString(fullHelpDirectory)));
			break;
		}
		case COMMAND_HELP_FILTER: {
			string fullHelpDirectory = 
				_exeDirectory + RESOURCE_PATHS_HELP_FILTER;
			_ui.displayAgendaviewTimed->load(
				QUrl::fromLocalFile(
				QString::fromStdString(fullHelpDirectory)));
			break;
		}
	}
	return;
}

void WhatToDo::updateAgendaView() {
	string newAgendaTimedViewHtml;
	string newAgendaFloatViewHtml;
	int timedViewScrollPos;
	int floatViewScrollPos;
	
	// Set the display as the help menu when there are no tasks
	// to display

	if (checkIsCurrentStateEmpty()) {
		updateGUIWithCommandString(COMMAND_PARAM_HELP);
		_ui.displayAgendaviewFloat->setHtml(
			QString::fromStdString(STRING_EMPTY));
		return;
	}

	// Get the new html strings for both agenda views according to the 
	// current state in this particular whattodo instance.

	newAgendaTimedViewHtml = getAgendaTimedViewHtml();
	newAgendaFloatViewHtml = getAgendaFloatViewHtml();
	
	// Get the initial scroll positions for both the agenda floating 
	// and agenda timed views

	timedViewScrollPos = 
		_ui.displayAgendaviewTimed->page()->mainFrame()->
		scrollBarValue(Qt::Vertical);
	floatViewScrollPos = 
		_ui.displayAgendaviewFloat->page()->mainFrame()->
		scrollBarValue(Qt::Vertical);
	
	_ui.displayAgendaviewTimed->setHtml(
		QString::fromStdString(newAgendaTimedViewHtml));
	_ui.displayAgendaviewFloat->setHtml(
		QString::fromStdString(newAgendaFloatViewHtml));
	
	markLastActionForUser(timedViewScrollPos, floatViewScrollPos);
	
	return;
}

void WhatToDo::updateCalendarView() {
	if (_b_calender_init_complete)
		_SFMLView->readFromState(_currState);
}

void WhatToDo::markLastActionForUser(int timedViewScrollPos, int floatViewScrollPos) {
	int newtimedViewScrollPos;
	int newfloatViewScrollPos;
	int lastActionTaskIndex = _currState.getLastActionTaskIndex();
	int lastActionType = _currState.getLastActionType();
	string lastActionElementID;
	QWebElement theChangedTaskElement;
	QWebElement tempTaskElement;
	QWebFrame* floatViewWebFrame = 
		_ui.displayAgendaviewFloat->page()->mainFrame();
	QWebFrame* timedViewWebFrame = 
		_ui.displayAgendaviewTimed->page()->mainFrame();
	
	// If there is was no last action to highlight, set the scroll 
	// bar to the original state it was in before updating the view

	if (lastActionType == State::NONE) {
		floatViewWebFrame->setScrollBarValue(
			Qt::Vertical, floatViewScrollPos);
		timedViewWebFrame->setScrollBarValue(
			Qt::Vertical, timedViewScrollPos);
		return;
	}

	// Otherwise, if there is a last action to highlight, 
	// continue to highlight the given task.

	else {
		
		// Get the scroll positions of the text to highlight so they can
		// be set later.

		_ui.displayAgendaviewFloat->findText(
			QString::fromStdString(HTMLTAGS_CHANGED_TASK_TEXT));
		_ui.displayAgendaviewTimed->findText(
			QString::fromStdString(HTMLTAGS_CHANGED_TASK_TEXT));
		newfloatViewScrollPos = 
			_ui.displayAgendaviewFloat->page()->mainFrame()->
			scrollBarValue(Qt::Vertical);
		newtimedViewScrollPos = 
			_ui.displayAgendaviewTimed->page()->mainFrame()->
			scrollBarValue(Qt::Vertical);
		floatViewWebFrame->setScrollBarValue(
			Qt::Vertical, newfloatViewScrollPos);
		timedViewWebFrame->setScrollBarValue(
			Qt::Vertical, newtimedViewScrollPos);
		
		// Find the new task which was changed

		tempTaskElement = 
			floatViewWebFrame->findFirstElement(
			QString::fromStdString(HTMLTAGS_CHANGED_TASK_ID));
		
		if (!tempTaskElement.isNull()) {
			theChangedTaskElement = tempTaskElement;
		}
		else {
			theChangedTaskElement = 
				timedViewWebFrame->findFirstElement(
				QString::fromStdString(HTMLTAGS_CHANGED_TASK_ID));
		}

		// For the new task which was changed, remove its visible tags
		// which were added previously for finding its scroll position

		theChangedTaskElement.setAttribute(
			QString::fromStdString(HTMLTAGS_STYLE_PROPERTY), 
			QString::fromStdString(HTMLTAGS_STYLE_PROPERTY_HIDE));
		
		// Find the new task html tag which was changed

		tempTaskElement = 
			floatViewWebFrame->findFirstElement(
			QString::fromStdString(HTMLTAGS_CHANGED_TASK_TEXT_ID));
		
		if (!tempTaskElement.isNull()) {
			theChangedTaskElement = tempTaskElement;
		}
		else {
			theChangedTaskElement = 
				timedViewWebFrame->findFirstElement(
				QString::fromStdString(
				HTMLTAGS_CHANGED_TASK_TEXT_ID));
		}

		// For the new task html tag which was changed, highlight
		// it according to the last action which was made.

		if (lastActionType == State::CHANGED) {
			theChangedTaskElement.setAttribute(
				QString::fromStdString(HTMLTAGS_STYLE_PROPERTY), 
				QString::fromStdString(
				HTMLTAGS_BACKGROUND_CHANGED_TASK));
		}
		else {
			theChangedTaskElement.setAttribute(
				QString::fromStdString(HTMLTAGS_STYLE_PROPERTY), 
				QString::fromStdString(
				HTMLTAGS_BACKGROUND_DELETED_TASK));
		}
	}

	return;
}

void WhatToDo::refreshCurrStateWithCommand(string commandString) {
	State incomingNewState = 
		LogicExecutor::getNewState(commandString);
	int lastActionType = 
		incomingNewState.getLastActionType();
	int lastActionTaskIndex = 
		incomingNewState.getLastActionTaskIndex();

	if ((lastActionType == State::CHANGED) 
			|| (lastActionType == State::NONE)){
		_currState = incomingNewState;
		_tempFutureState = incomingNewState;
	}
	else if (lastActionType == State::DELETED) {
		_currState = _tempFutureState;
		_currState.setLastActionTaskIndex(
			incomingNewState.getLastActionTaskIndex());
		_currState.setLastActionType(
			incomingNewState.getLastActionType());
		_currState.setActionMessage(
			incomingNewState.getActionMessage());
		_currState.setUserMessage(
			incomingNewState.getUserMessage());
		_tempFutureState = incomingNewState;
		
		/*
		incomingNewState = LogicExecutor::getNewState(COMMAND_PARAM_CLEAR);
		_currState = incomingNewState;
		_currState.setLastActionTaskIndex(
			incomingNewState.getLastActionTaskIndex());
		_currState.setLastActionType(
			incomingNewState.getLastActionType());
		_currState.setActionMessage(
			incomingNewState.getActionMessage());
		_currState.setUserMessage(
			incomingNewState.getUserMessage());
		_tempFutureState = incomingNewState;
		*/
	}	

	return;
}



bool WhatToDo::checkIsUserCommandInputValid(	string usercommandString) {
	bool isUserCommandValid = false;
	usercommandString = removeUnwantedChars(usercommandString);

	if (checkIsContainStrangeChars(usercommandString)) {
		throw MSG_ERR_UNACCEPTED_CHARS_ENTERED;
	}

	if (usercommandString != STRING_EMPTY) {
		isUserCommandValid = true;
	}
	return isUserCommandValid;
}

int WhatToDo::determineCommandType(string usercommandString) {
	istringstream inputString(usercommandString);
	string userCommand;
	string userCommandSpecs;

	assert(usercommandString != STRING_EMPTY);
	if (!(inputString >> userCommand)) {
		throw MSG_ERROR_INSUFFICIENT_INPUT;
	}
	if (userCommand == COMMAND_PARAM_DELETE_WITH_REAL_INDEX) {
		return COMMAND_DELETE_WITH_REAL_INDEX;
	}
	else if (userCommand == COMMAND_PARAM_DONE_WITH_REAL_INDEX) {
		return COMMAND_DONE_WITH_REAL_INDEX;
	}
	else if (userCommand == COMMAND_PARAM_UNDONE_WITH_REAL_INDEX) {
		return COMMAND_UNDONE_WITH_REAL_INDEX;
	}
	else if (userCommand == COMMAND_PARAM_EDIT) {
		return COMMAND_EDIT;
	}
	else if (userCommand == COMMAND_PARAM_DONE) {
		return COMMAND_DONE;
	}
	else if (userCommand == COMMAND_PARAM_UNDONE) {
		return COMMAND_UNDONE;
	}
	else if (userCommand == COMMAND_PARAM_DELETE) {
		return COMMAND_DELETE;
	}
	else if (userCommand == COMMAND_PARAM_UNDO) {
		return COMMAND_UNDO;
	}
	else if (userCommand == COMMAND_PARAM_HELP) {
		
		if (inputString >> userCommandSpecs) {
			if (userCommandSpecs == COMMAND_PARAM_HELP_ADD) {
				return COMMAND_HELP_ADD;
			}
			else if (userCommandSpecs == COMMAND_PARAM_HELP_EDIT) {
				return COMMAND_HELP_EDIT;
			}
			else if (userCommandSpecs == COMMAND_PARAM_HELP_DELETE) {
				return COMMAND_HELP_DELETE;
			}
			else if (userCommandSpecs == COMMAND_PARAM_HELP_DONE) {
				return COMMAND_HELP_DONE;
			}
			else if (userCommandSpecs == COMMAND_PARAM_HELP_SEARCH) {
				return COMMAND_HELP_SEARCH;
			}
			else if (userCommandSpecs == COMMAND_PARAM_HELP_UNDO) {
				return COMMAND_HELP_UNDO;
			}
			else if (userCommandSpecs == COMMAND_PARAM_HELP_REDO) {
				return COMMAND_HELP_REDO;
			}
			else if (userCommandSpecs == COMMAND_PARAM_HELP_CLEAR) {
				return COMMAND_HELP_CLEAR;
			}
			else {
				return COMMAND_HELP;
			}
		}
		else {
			return COMMAND_HELP;
		}
	}
	else {
		return COMMAND_OTHERS;
	}
	return COMMAND_OTHERS;
}

void WhatToDo::processCommandEdit(string commandString) {
	istringstream inputString(commandString);
	vector<Task> allCurrentTasks = _currState.getAllTasks();
	int displayIndexToEdit;
	int actualIndexToEdit;
	string userCommand;
	string newEditContents;
	string commandToPassLogic;
	string textToFillCommandLine;

	assert(commandString != STRING_EMPTY);

	if (inputString >> userCommand >> displayIndexToEdit) {
		
		// Update the GUI with the edit command if the user
		// entered the details of the new task to replace the old one.

		if (getline(inputString, newEditContents)) {
			
			// If the user entered a valid display index to edit, 
			// replace the display index with the actual task index
			// and update the GUi with the edit command.
			
			if ((displayIndexToEdit >= 1) 
				&& (displayIndexToEdit <= allCurrentTasks.size())) {
				
				actualIndexToEdit = 
					allCurrentTasks[displayIndexToEdit-1].getTaskIndex();
				commandToPassLogic = 
					COMMAND_PARAM_EDIT + STRING_SPACE_CHAR + 
					to_string(actualIndexToEdit) + 
					STRING_SPACE_CHAR + newEditContents;

				refreshCurrStateWithCommand(commandToPassLogic);
				updateAgendaView();
				updateCalendarView();
				showLogicUserFeedback();
			}
			
			// If the display task index is invalid, throw an error.

			else {
				throw MSG_ERROR_USER_WRONG_INDEX;
			}
		}
		
		// If the user did not enter the details of the new task to replace
		// the old one, fill in the command entry field with details
		// of the current task.

		else {
			if ((displayIndexToEdit >= 1) 
				&& (displayIndexToEdit <= allCurrentTasks.size())) {

				newEditContents = 
					convertTaskToEditText(
					allCurrentTasks[displayIndexToEdit-1]);
				textToFillCommandLine = 
					COMMAND_PARAM_EDIT + STRING_SPACE_CHAR + 
					to_string(displayIndexToEdit) + 
					STRING_SPACE_CHAR + newEditContents;
				_ui.commandLine->setPlainText(
					QString::fromStdString(textToFillCommandLine));
				QTextCursor cursor = _ui.commandLine->textCursor();
				cursor.movePosition(QTextCursor::End, 
					QTextCursor::MoveAnchor);
				_ui.commandLine->setTextCursor(cursor);
			}
			
			// If the display task index is invalid, throw an error.

			else {
				throw MSG_ERROR_USER_WRONG_INDEX;
			}
		}
	}
	return;
}

void WhatToDo::processCommandDone(string commandString, bool b_usingRealIndex) {
	istringstream inputString(commandString);
	vector<Task> allCurrentTasks = _currState.getAllTasks();
	int displayIndexToDone;
	int actualIndexToDone;
	string userCommand;
	string commandToPassLogic;

	assert(commandString != STRING_EMPTY);

	if (inputString >> userCommand >> displayIndexToDone) {
		
		// if the done command has been crafted with the true
		// task index (meaning b_usingRealIndex is true), directly
		// update the GUi with the task index in the user command.
		
		if (b_usingRealIndex) {
			commandToPassLogic = COMMAND_PARAM_DONE + 
				STRING_SPACE_CHAR + to_string(displayIndexToDone);
			refreshCurrStateWithCommand(commandToPassLogic);
			updateAgendaView();
			updateCalendarView();
			showLogicUserFeedback();
		}

		// if the done command has not been crafted with the true
		// task index, replace the display task index with the true
		// task index before sending the command to Logic.

		else if ((displayIndexToDone >= 1) 
			&& (displayIndexToDone <= allCurrentTasks.size())) {
			
			actualIndexToDone = 
				allCurrentTasks[displayIndexToDone-1].getTaskIndex();
			commandToPassLogic = 
				COMMAND_PARAM_DONE + STRING_SPACE_CHAR + 
				to_string(actualIndexToDone);

			refreshCurrStateWithCommand(commandToPassLogic);
			updateAgendaView();
			updateCalendarView();
			showLogicUserFeedback();
		}
		
		// If the display task index is invalid, throw an error.

		else {
			throw MSG_ERROR_USER_WRONG_INDEX;
		}
	}
	else {
		throw MSG_ERROR_USER_WRONG_PARAMS;
	}
	return;
}

void WhatToDo::processCommandUndone(string commandString, bool b_usingRealIndex) {
	istringstream inputString(commandString);
	vector<Task> allCurrentTasks = _currState.getAllTasks();
	int displayIndexToUndone;
	int actualIndexToUndone;
	string userCommand;
	string commandToPassLogic;

	assert(commandString != STRING_EMPTY);

	if (inputString >> userCommand >> displayIndexToUndone) {
		
		// if the undone command has been crafted with the true
		// task index (meaning b_usingRealIndex is true), directly
		// update the GUi with the task index in the user command.
		
		if (b_usingRealIndex){
			commandToPassLogic = COMMAND_PARAM_UNDONE + STRING_SPACE_CHAR + to_string(displayIndexToUndone);
			refreshCurrStateWithCommand(commandToPassLogic);
			updateAgendaView();
			updateCalendarView();
			showLogicUserFeedback();
		}

		// if the undone command has not been crafted with the true
		// task index, replace the display task index with the true
		// task index before sending the command to Logic.

		else if ((displayIndexToUndone >= 1) 
			&& (displayIndexToUndone <= allCurrentTasks.size())) {
			
			actualIndexToUndone = 
				allCurrentTasks[displayIndexToUndone-1].getTaskIndex();
			commandToPassLogic = 
				COMMAND_PARAM_UNDONE + STRING_SPACE_CHAR + 
				to_string(actualIndexToUndone);

			refreshCurrStateWithCommand(commandToPassLogic);
			updateAgendaView();
			updateCalendarView();
			showLogicUserFeedback();
		}
		
		// If the display task index is invalid, throw an error.

		else {
			throw MSG_ERROR_USER_WRONG_INDEX;
		}
	}
	else {
		throw MSG_ERROR_USER_WRONG_PARAMS;
	}
	return;
}

void WhatToDo::processCommandDelete(string commandString, bool b_usingRealIndex) {
	istringstream inputString(commandString);
	vector<Task> allCurrentTasks = _currState.getAllTasks();
	int displayIndexToDelete;
	int actualIndexToDelete;
	string userCommand;
	string commandToPassLogic;

	assert(commandString != STRING_EMPTY);

	if (inputString >> userCommand >> displayIndexToDelete) {
		
		// if the delete command has been crafted with the true
		// task index (meaning b_usingRealIndex is true), directly
		// update the GUi with the task index in the user command.
		
		if (b_usingRealIndex){
			commandToPassLogic = COMMAND_PARAM_DELETE + STRING_SPACE_CHAR + to_string(displayIndexToDelete);
			refreshCurrStateWithCommand(commandToPassLogic);
			updateAgendaView();
			updateCalendarView();
			showLogicUserFeedback();
		}

		// if the delete command has not been crafted with the true
		// task index, replace the display task index with the true
		// task index before sending the command to Logic.

		else if ((displayIndexToDelete >= 1) 
			&& (displayIndexToDelete <= allCurrentTasks.size())) {
			
			actualIndexToDelete = 
				allCurrentTasks[displayIndexToDelete-1].getTaskIndex();
			commandToPassLogic = 
				COMMAND_PARAM_DELETE + STRING_SPACE_CHAR + 
				to_string(actualIndexToDelete);

			refreshCurrStateWithCommand(commandToPassLogic);
			updateAgendaView();
			updateCalendarView();
			showLogicUserFeedback();
		}
		
		// If the display task index is invalid, throw an error.

		else {
			throw MSG_ERROR_USER_WRONG_INDEX;
		}
	}
	else {
		throw MSG_ERROR_USER_WRONG_PARAMS;
	}

	return;
}

void WhatToDo::processCommandOthers(string commandString) {
	assert(commandString != STRING_EMPTY);
	refreshCurrStateWithCommand(commandString);
	updateAgendaView();
	updateCalendarView();
	showLogicUserFeedback();
	return;
}



string WhatToDo::getAgendaTimedViewHtml() {
	string newAgendaTimedViewHtml;
	vector<Task> listOfTasks = _currState.getAllTasks();
	ptime currentptime = not_a_date_time;
	ptime nextptime = not_a_date_time;
	int i;

	newAgendaTimedViewHtml += HTMLTAGS_BEGIN;

	for (i=0; unsigned(i)<listOfTasks.size(); i++) {
		
		// Only get html for non-floating tasks to only display
		// non-floating tasks.
		
		if (!(listOfTasks[i].getTaskType() == Task::FLOATING)) {
			nextptime = getTaskOrderingDate(listOfTasks[i]);
			if (nextptime.date() != currentptime.date()) {
				newAgendaTimedViewHtml += 
					createDateTitleHtml(nextptime);
				newAgendaTimedViewHtml += 
					createPreNumberingHtml(i+1);
				currentptime = nextptime;
			}
			newAgendaTimedViewHtml += 
				createNonFloatingTaskHtml(listOfTasks[i]);
		}
	}

	newAgendaTimedViewHtml += HTMLTAGS_END;
	return newAgendaTimedViewHtml;
}

string WhatToDo::getAgendaFloatViewHtml() {
	string newAgendaFloatViewHtml;
	vector<Task> listOfTasks = _currState.getAllTasks();
	ptime currentptime = not_a_date_time;
	ptime nextptime = not_a_date_time;
	bool isExistFloatingTasks = false;
	int i;

	newAgendaFloatViewHtml += HTMLTAGS_BEGIN;

	for (i=0; unsigned(i)<listOfTasks.size(); i++) {
		
		// Only get html for floating tasks to only display
		// floating tasks.
		
		if (listOfTasks[i].getTaskType() == Task::FLOATING) {
			if (!isExistFloatingTasks) {
				newAgendaFloatViewHtml += HTMLTAGS_TITLE_FLOATING;
			}
			newAgendaFloatViewHtml += 
				createFloatingTaskHtml(listOfTasks[i]);
			isExistFloatingTasks = true;
		}
		else {
			break;
		}
	}

	newAgendaFloatViewHtml += HTMLTAGS_END;
	return newAgendaFloatViewHtml;
}

string WhatToDo::createDateTitleHtml(ptime titleDate){
	string titleHtml;
	string formattedDate;
	string dayOfWeek = 
		changeDayToDayOfWeek(titleDate.date().day_of_week());
	string monthOfYear = 
		changeMonthToMonthOfYear(titleDate.date().month());

	// If the date is already past, display the title of the date with
	// a different background.

	if (titleDate.date() < second_clock::local_time().date()) {
		formattedDate += dayOfWeek;
		formattedDate += STRING_COMMA_CHAR + STRING_SPACE_CHAR + 
			to_string(titleDate.date().day()) + STRING_SPACE_CHAR + 
			monthOfYear + STRING_SPACE_CHAR + 
			to_string(titleDate.date().year());
		titleHtml = HTMLTAGS_TITLE_DATE_PRE + 
			HTMLTAGS_BACKGROUND_PAST_PRE + formattedDate + 
			HTMLTAGS_BACKGROUND_PAST_POST + HTMLTAGS_TITLE_DATE_POST;
	}

	// If the date is today, display the title of the date with 
	// an indication that its today's date.

	else if (titleDate.date() == second_clock::local_time().date()) {
		formattedDate += GUI_PARAM_DISPLAY_DATE_TODAY;
		formattedDate += STRING_COMMA_CHAR + STRING_SPACE_CHAR + 
			to_string(titleDate.date().day()) + STRING_SPACE_CHAR + 
			monthOfYear + STRING_SPACE_CHAR + 
			to_string(titleDate.date().year());
		titleHtml = HTMLTAGS_TITLE_DATE_PRE + formattedDate + 
			HTMLTAGS_TITLE_DATE_POST;
	}

	// If the date is in the future, display the day and date of the
	// date-title.

	else {
		formattedDate += dayOfWeek;
		formattedDate += STRING_COMMA_CHAR + STRING_SPACE_CHAR + 
			to_string(titleDate.date().day()) + STRING_SPACE_CHAR + 
			monthOfYear + STRING_SPACE_CHAR + 
			to_string(titleDate.date().year());
		titleHtml = HTMLTAGS_TITLE_DATE_PRE + formattedDate + 
			HTMLTAGS_TITLE_DATE_POST;
	}

	return titleHtml;
}

string WhatToDo::createPreNumberingHtml(int startNumber) {
	string preNumberingHtml;
	preNumberingHtml = HTMLTAGS_NUMBERING_PRE + 
		to_string(startNumber) + HTMLTAGS_NUMBERING_POST;
	return preNumberingHtml;
}

string WhatToDo::createFloatingTaskHtml(Task taskToProcess) {
	string fullTaskHtml;
	string taskNameTagsHtml = getTaskNameTagsHtml(taskToProcess);
	fullTaskHtml += getHtmlPreTaskTags(taskToProcess);
	fullTaskHtml += getLastActionTextIndexHtml(taskToProcess);
	
	// Add the done tag in front of done tasks to indicate that they
	// are done.

	if (taskToProcess.getTaskIsDone()) {
		fullTaskHtml += 
			HTMLTAGS_TASK_DONE_PRE + HTMLTAGS_TASK_DONE_POST + 
			taskNameTagsHtml;
	}
	else {
		fullTaskHtml += taskNameTagsHtml + HTMLTAGS_TASK_POST;
	}
	return fullTaskHtml;
}

string WhatToDo::createNonFloatingTaskHtml(Task taskToProcess) {
	string fullTaskHtml;
	string partialTaskHtml;
	string taskNameTagsHtml;
	ptime taskFirstDisplayTime;
	ptime taskSecondDisplayTime;

	fullTaskHtml += getHtmlPreTaskTags(taskToProcess);
	fullTaskHtml += getLastActionTextIndexHtml(taskToProcess);
	
	// Add the done tag in front of done tasks to indicate that they
	// are done.

	if (taskToProcess.getTaskIsDone()) {
		fullTaskHtml += 
			HTMLTAGS_TASK_DONE_PRE + HTMLTAGS_TASK_DONE_POST;
	}

	taskNameTagsHtml = getTaskNameTagsHtml(taskToProcess);

	// Different kinds of tasks will be displayed differently in the 
	// GUI with different tags.

	if (taskToProcess.getTaskType() == Task::DEADLINE_ALLDAY) {
		partialTaskHtml = 
			HTMLTAGS_TASK_NAMETAGS_PRE_DEADLINE_ALLDAY + 
			HTMLTAGS_TASK_NAMETAGS_POST + taskNameTagsHtml;
	}
	else if (taskToProcess.getTaskType() == Task::DEADLINE_TIME) {
		taskFirstDisplayTime = taskToProcess.getTaskDeadline();
		partialTaskHtml = 
			HTMLTAGS_TASK_NAMETAGS_POST_DEADLINE_TIMED + 
			getDisplayTime(taskFirstDisplayTime) + 
			HTMLTAGS_TASK_NAMETAGS_POST + taskNameTagsHtml;
	}
	else if (taskToProcess.getTaskType() == Task::FIXED_ALLDAY) {
		partialTaskHtml = HTMLTAGS_TASK_NAMETAGS_POST_FIXED_ALLDAY + 
			HTMLTAGS_TASK_NAMETAGS_POST + taskNameTagsHtml;
	}
	else if (taskToProcess.getTaskType() == Task::FIXED_START) {
		taskFirstDisplayTime = taskToProcess.getTaskStartTime();
		partialTaskHtml = HTMLTAGS_TASK_NAMETAGS_POST_FIXED_START + 
			getDisplayTime(taskFirstDisplayTime) + 
			HTMLTAGS_TASK_NAMETAGS_POST + taskNameTagsHtml;
	}
	else if (taskToProcess.isTaskHasStartAndEnd()) {
		taskFirstDisplayTime = taskToProcess.getTaskStartTime();
		taskSecondDisplayTime = taskToProcess.getTaskEndTime();
		if (taskToProcess.getTaskType() == Task::FIXED_TIME_WITHIN_DAY) {
			partialTaskHtml = 
				HTMLTAGS_TASK_NAMETAGS_POST_FIXED_TIMED + 
				getDisplayTime(taskFirstDisplayTime) + 
				HTMLTAGS_TASK_NAMETAGS_MID_FIXED_START + 
				getDisplayTime(taskSecondDisplayTime) + 
				HTMLTAGS_TASK_NAMETAGS_POST + taskNameTagsHtml;
		}
		else if (taskToProcess.getTaskType() == Task::FIXED_TIME_ACROSS_DAY) {
			partialTaskHtml = 
				HTMLTAGS_TASK_NAMETAGS_POST_FIXED_TIMED + 
				getDisplayTime(taskFirstDisplayTime) + 
				HTMLTAGS_TASK_NAMETAGS_MID_FIXED_START + 
				getDisplayDay(taskSecondDisplayTime) + 
				HTMLTAGS_TASK_NAMETAGS_POST + taskNameTagsHtml;
		}
		else if (taskToProcess.getTaskType() == Task::FIXED_DAY_TO_DAY) {
			partialTaskHtml = 
				HTMLTAGS_TASK_NAMETAGS_POST_FIXED_TIMED + 
				STRING_ALL_DAY + HTMLTAGS_TASK_NAMETAGS_MID_FIXED_START + 
				getDisplayDayWithoutTime(taskSecondDisplayTime) + 
				HTMLTAGS_TASK_NAMETAGS_POST + taskNameTagsHtml;
		}
		else if (taskToProcess.getTaskType() == Task::FIXED_TIME_TO_DAY) {
			partialTaskHtml = 
				HTMLTAGS_TASK_NAMETAGS_POST_FIXED_TIMED + 
				getDisplayTime(taskFirstDisplayTime) + 
				HTMLTAGS_TASK_NAMETAGS_MID_FIXED_START + 
				getDisplayDayWithoutTime(taskSecondDisplayTime) + 
				HTMLTAGS_TASK_NAMETAGS_POST + taskNameTagsHtml;
		}
		else if (taskToProcess.getTaskType() == Task::FIXED_DAY_TO_TIME) {
			partialTaskHtml = 
				HTMLTAGS_TASK_NAMETAGS_POST_FIXED_TIMED + 
				STRING_ALL_DAY + HTMLTAGS_TASK_NAMETAGS_MID_FIXED_START + 
				getDisplayDay(taskSecondDisplayTime) + 
				HTMLTAGS_TASK_NAMETAGS_POST + taskNameTagsHtml;
		}
	}

	fullTaskHtml += partialTaskHtml + HTMLTAGS_TASK_POST;
	return fullTaskHtml;
}

string WhatToDo::getTaskNameTagsHtml(Task myTask) {
	string taskNameTagsHtml;
	int i;

	taskNameTagsHtml += myTask.getTaskName();
	taskNameTagsHtml += HTMLTAGS_TASK_TAGS_PRE;

	for (i=0; unsigned(i)<myTask.getTaskTags().size(); i++) {
		taskNameTagsHtml += 
			myTask.getTaskTags()[i] + STRING_SPACE_CHAR;
	}

	taskNameTagsHtml += HTMLTAGS_TASK_TAGS_POST;

	return taskNameTagsHtml;
}

string WhatToDo::getLastActionTextIndexHtml(Task taskToProcess) {
	string lastActionTextIndexHtml = STRING_EMPTY;
	int lastActionType = _currState.getLastActionType();
	int lastActionTaskIndex = _currState.getLastActionTaskIndex();

	// Add a special text marker to the task if it was changed or
	// deleted in the previous action.

	if ((lastActionType == State::CHANGED) 
			|| (lastActionType == State::DELETED)) {
		if (lastActionTaskIndex == taskToProcess.getTaskIndex()) {
			lastActionTextIndexHtml += 
				HTMLTAGS_TASK_INDEX_SPECIAL_MARKER;
		}
	}

	return lastActionTextIndexHtml;
}

string WhatToDo::getHtmlPreTaskTags(Task taskToProcess) {
	string htmlPreTaskTags = STRING_EMPTY;
	int lastActionTaskIndex = _currState.getLastActionTaskIndex();
	int lastActionType = _currState.getLastActionType();
	
	if (lastActionType != State::NONE) {
		if (taskToProcess.getTaskIndex() == lastActionTaskIndex) {
			htmlPreTaskTags = HTMLTAGS_TASK_PRE_CHANGED;
		}
		else {
			htmlPreTaskTags = HTMLTAGS_TASK_PRE_UNCHANGED;
		}
	}
	else {
		htmlPreTaskTags = HTMLTAGS_TASK_PRE_UNCHANGED;
	}

	return htmlPreTaskTags;
}



ptime WhatToDo::getTaskOrderingDate(Task myTask) {
	if (myTask.getTaskType() == Task::FLOATING) {
		return not_a_date_time;
	}
	else if (myTask.getTaskType() == Task::DEADLINE_ALLDAY) {
		return myTask.getTaskDeadline();
	}
	else if (myTask.getTaskType() == Task::DEADLINE_TIME) {
		return myTask.getTaskDeadline();
	}
	else if (myTask.getTaskType() == Task::FIXED_ALLDAY) {
		return myTask.getTaskStartTime();
	}
	else if (myTask.getTaskType() == Task::FIXED_START) {
		return myTask.getTaskStartTime();
	}
	else if (myTask.isTaskHasStartAndEnd()) {
		return myTask.getTaskStartTime();
	}
	return not_a_date_time;
}

string WhatToDo::getDisplayTime(ptime myTime) {
	string hours = STRING_EMPTY;
	string minutes = STRING_EMPTY;
	string displayTime = STRING_EMPTY;
	string pmOrAm = STRING_EMPTY;

	if (myTime.time_of_day().minutes() == 0) {
		minutes = STRING_EMPTY;
	}
	else if (myTime.time_of_day().minutes() < 10) {
		minutes = STRING_DOT_CHAR + STRING_ZERO_CHAR + 
			to_string(myTime.time_of_day().minutes());
	}
	else {
		minutes = STRING_DOT_CHAR + 
			to_string(myTime.time_of_day().minutes());
	}

	if (myTime.time_of_day().hours() == 0) {
		pmOrAm = STRING_AM;
		hours = to_string(12);
	}
	else if (myTime.time_of_day().hours() < 12) {
		pmOrAm = STRING_AM;
		hours = to_string(myTime.time_of_day().hours());
	}
	else if (myTime.time_of_day().hours() == 12) {
		pmOrAm = STRING_PM;
		hours = to_string(12);
	}
	else if (myTime.time_of_day().hours() >= 12) {
		pmOrAm = STRING_PM;
		hours = to_string(myTime.time_of_day().hours()-12);
	}

	displayTime = hours + minutes + pmOrAm;

	return displayTime;
}

string WhatToDo::getDisplayDay(ptime myTime) {
	string displayDay;
	displayDay += to_string(myTime.date().day());
	displayDay += STRING_SPACE_CHAR + 
		changeMonthToMonthOfYear(myTime.date().month());
	displayDay += STRING_SPACE_CHAR + getDisplayTime(myTime);
	return displayDay;
}

string WhatToDo::getDisplayDayWithoutTime(ptime myTime) {
	string displayDayWithoutTime;
	displayDayWithoutTime += to_string(myTime.date().day());
	displayDayWithoutTime += STRING_SPACE_CHAR + 
		changeMonthToMonthOfYear(myTime.date().month());
	return displayDayWithoutTime;
}

string WhatToDo::removeUnwantedChars(string stringToProcess) {
	boost::replace_all(stringToProcess, 
		STRING_NEWLN_CHAR, STRING_EMPTY);
	boost::replace_all(stringToProcess, 
		STRING_RETURN_CHAR, STRING_EMPTY);
	return stringToProcess;
}

string WhatToDo::changeDayToDayOfWeek(int day) {
	if (day == 1) {
		return ABBREV_WEEK_MON;
	}
	else if (day == 2) {
		return ABBREV_WEEK_TUE;
	}
	else if (day == 3) {
		return ABBREV_WEEK_WED;
	}
	else if (day == 4) {
		return ABBREV_WEEK_THU;
	}
	else if (day == 5) {
		return ABBREV_WEEK_FRI;
	}
	else if (day == 6) {
		return ABBREV_WEEK_SAT;
	}
	else if (day == 0) {
		return ABBREV_WEEK_SUN;
	}
	
	return STRING_EMPTY;
}

string WhatToDo::changeMonthToMonthOfYear(int month) {
	if (month == 1) {
		return ABBREV_MONTH_JAN;
	}
	else if (month == 2) {
		return ABBREV_MONTH_FEB;
	}
	else if (month == 3) {
		return ABBREV_MONTH_MAR;
	}
	else if (month == 4) {
		return ABBREV_MONTH_APR;
	}
	else if (month == 5) {
		return ABBREV_MONTH_MAY;
	}
	else if (month == 6) {
		return ABBREV_MONTH_JUN;
	}
	else if (month == 7) {
		return ABBREV_MONTH_JUL;
	}
	else if (month == 8) {
		return ABBREV_MONTH_AUG;
	}
	else if (month == 9) {
		return ABBREV_MONTH_SEP;
	}
	else if (month == 10) {
		return ABBREV_MONTH_OCT;
	}
	else if (month == 11) {
		return ABBREV_MONTH_NOV;
	}
	else if (month == 12) {
		return ABBREV_MONTH_DEC;
	}

	return STRING_EMPTY;
}

string WhatToDo::convertTaskToEditText(Task taskToConvert) {
	string taskEditText;
	vector<string> taskTags = taskToConvert.getTaskTags();
	int i;
	
	taskEditText += taskToConvert.getTaskName();
	taskEditText += STRING_SPACE_CHAR + 
		getTaskDateAsEditText(taskToConvert);
	for (i=0; unsigned(i)<taskTags.size();  i++) {
		if (i==0) {
			taskEditText += taskTags[i];
		}
		else {
			taskEditText += STRING_SPACE_CHAR + taskTags[i];
		}
	}
	return taskEditText;
}

string WhatToDo::getTaskDateAsEditText(Task taskToConvert) {
	string taskDateEditText;
	if (taskToConvert.getTaskType() == Task::FLOATING) {
		taskDateEditText = STRING_EMPTY;
	}
	else if (taskToConvert.getTaskType() == Task::DEADLINE_ALLDAY) {
		taskDateEditText = COMMAND_PARAM_ADD_DATE_DEADLINE + 
			convertDateToEditText(taskToConvert.getTaskDeadline());
	}
	else if (taskToConvert.getTaskType() == Task::DEADLINE_TIME) {
		taskDateEditText = COMMAND_PARAM_ADD_DATE_DEADLINE + 
			convertDateTimeToEditText(taskToConvert.getTaskDeadline());
	}
	else if (taskToConvert.getTaskType() == Task::FIXED_ALLDAY) {
		taskDateEditText = COMMAND_PARAM_ADD_DATE_TIMED_ALLDAY + 
			convertDateToEditText(taskToConvert.getTaskStartTime());
	}
	else if (taskToConvert.getTaskType() == Task::FIXED_START) {
		taskDateEditText = COMMAND_PARAM_ADD_DATE_TIMED_START + 
			convertDateTimeToEditText(taskToConvert.getTaskStartTime());
	}
	else if (taskToConvert.isTaskHasStartAndEnd()) {
		taskDateEditText += COMMAND_PARAM_ADD_DATE_TIMED_START + 
			convertDateTimeToEditText(taskToConvert.getTaskStartTime());
		taskDateEditText += COMMAND_PARAM_ADD_DATE_TIMED_END + 
			convertDateTimeToEditText(taskToConvert.getTaskEndTime());
	}

	return taskDateEditText;
}

string WhatToDo::convertDateTimeToEditText(ptime timeToConvert) {
	string dateTimeEditText;
	dateTimeEditText = to_string(timeToConvert.date().day()) + 
		STRING_SPACE_CHAR + 
		changeMonthToMonthOfYear(timeToConvert.date().month()) + 
		STRING_SPACE_CHAR + to_string(timeToConvert.date().year()) + 
		STRING_SPACE_CHAR + getDisplayTime(timeToConvert) + 
		STRING_SPACE_CHAR;
	return dateTimeEditText;
}

string WhatToDo::convertDateToEditText(ptime timeToConvert) {
	string dateEditText;
	dateEditText = to_string(timeToConvert.date().day()) + 
		STRING_SPACE_CHAR + 
		changeMonthToMonthOfYear(timeToConvert.date().month()) + 
		STRING_SPACE_CHAR + to_string(timeToConvert.date().year()) + 
		STRING_SPACE_CHAR;
	return dateEditText;
}

bool WhatToDo::checkIsContainStrangeChars(string stringToProcess) {
	bool isContainStrangeChars = false;
	int i;
	for (i=0; unsigned(i)<stringToProcess.size(); i++) {
		if ((stringToProcess[i]<GUI_MIN_CHAR) 
				|| (stringToProcess[i]>GUI_MAX_CHAR)) {
			isContainStrangeChars = true;
			break;
		}
	}
	return isContainStrangeChars;
}

bool WhatToDo::checkIsCurrentStateEmpty() {
	bool isCurrentStateEmpty = false;
	vector<Task> listOfTasksInState = _tempFutureState.getAllTasks();
	isCurrentStateEmpty = listOfTasksInState.empty();
	return isCurrentStateEmpty;
}

	// End of segment: ./\whattodo.cpp





	/**
	 * origin: ./\whattodo.h
	 */

//
// This is the main GUI logic / event handler class.
// 
// It is reponsible for (i) setting up the GUI with the help of other GUI
// classes; and (ii) and handling all subsequent events in the GUI and performing
// the respective simple logic actions to handle these events.
//
//****************************************************************************

#ifndef WHATTODO_H
#define WHATTODO_H

#include <QtWidgets/QMainWindow>
#include <QtWebKit/qwebelement.h>
#include <QWebFrame>
#include <QShortcut>
#include <QGraphicsObject>
#include <QTextCursor>
#include <QObject>
#include <QAction>
#include <sstream>
#include <string>
#include <vector>
#include <assert.h>
#include "boost/algorithm/string.hpp"
#include "boost/date_time.hpp"
#include "ui_whattodo.h"
#include "KeyPressEater.h"
#include "LogicExecutor.h"
#include "State.h"
#include "Task.h"

#include "calendarcanvas.h"

using namespace std;
using namespace boost::posix_time;
using namespace boost::gregorian;

const string HTMLTAGS_BEGIN = 
	"<html><body style=\" font-family:'Calibri'; font-size:23pt; fon"
	"t-weight:400; font-style:normal;\">";
const string HTMLTAGS_END = "</ol></body></html>";
const string HTMLTAGS_TITLE_FLOATING = 
	"<p><b><u>Floating Tasks!</u></b></p><ol start=1 style=\"margin-"
	"top:-15px; margin-left:20px;\">";
const string HTMLTAGS_TITLE_DATE_PRE = "</ol><p><b><u>";
const string HTMLTAGS_TITLE_DATE_POST = "</u></b></p>";
const string HTMLTAGS_NUMBERING_PRE = "</ol><ol start=";
const string HTMLTAGS_NUMBERING_POST = 
	" style=\"margin-top:-15px; margin-left:20px;\">";
const string HTMLTAGS_TASK_PRE_UNCHANGED = 
	"<li style=\"margin-bottom:2px;\">";
const string HTMLTAGS_TASK_PRE_CHANGED = 
	"<li style=\"margin-bottom:2px;\" id=\"sptag\">";
const string HTMLTAGS_TASK_POST = "</li>";
const string HTMLTAGS_TASK_INDEX_SPECIAL_MARKER = 
	"<span style=\"\" id=\"sp\">[[SP]]</span>";
const string HTMLTAGS_TASK_NAMETAGS_POST = "]</span> ";
const string HTMLTAGS_TASK_NAMETAGS_PRE_DEADLINE_ALLDAY = 
	"<span style=\" font-weight:600; color:#ff0000;\">[DUE";
const string HTMLTAGS_TASK_NAMETAGS_POST_DEADLINE_TIMED = 
	"<span style=\" font-weight:600; color:#ff0000;\">[DUE - ";
const string HTMLTAGS_TASK_NAMETAGS_POST_FIXED_ALLDAY = 
	"<span style=\" font-weight:600; color:#0000ff;\">[All Day";
const string HTMLTAGS_TASK_NAMETAGS_POST_FIXED_START = 
	"<span style=\" font-weight:600; color:#0000ff;\">[";
const string HTMLTAGS_TASK_NAMETAGS_POST_FIXED_TIMED = 
	"<span style=\" font-weight:600; color:#0000ff;\">[";
const string HTMLTAGS_TASK_NAMETAGS_MID_FIXED_START = " - ";
const string HTMLTAGS_TASK_DONE_PRE = 
	"<font color=\"#007B21\"><b>[Done]";
const string HTMLTAGS_TASK_DONE_POST = "</font></b> ";
const string HTMLTAGS_TASK_TAGS_PRE = 
	"<span style=\" font-weight:600; color:#FF5D00;\"> ";
const string HTMLTAGS_TASK_TAGS_POST = "</span>";
const string HTMLTAGS_BACKGROUND_PAST_PRE = 
	"<span style=\"background-color: #D8D8D8;\">";
const string HTMLTAGS_BACKGROUND_PAST_POST = "</span>";
const string HTMLTAGS_BACKGROUND_CHANGED_TASK = 
	"background-color: #6DFF8F;";
const string HTMLTAGS_BACKGROUND_DELETED_TASK = 
	"background-color: #FF727E;";
const string HTMLTAGS_STYLE_PROPERTY = "style";
const string HTMLTAGS_STYLE_PROPERTY_HIDE = "display:none";
const string HTMLTAGS_CHANGED_TASK_TEXT = "[[sp]]";
const string HTMLTAGS_CHANGED_TASK_ID = "#sp";
const string HTMLTAGS_CHANGED_TASK_TEXT_ID = "#sptag";

const string QTSTYLESHEET_TRANSPARENT_BACKGROUND = 
	"background:transparent;";
const int GUI_PARAM_SIZE_WIDTH = 959;
const int GUI_PARAM_SIZE_HEIGHT = 692;
const double GUI_PARAM_TEXT_MULTIPLIER = 0.75;
const string GUI_PARAM_STATUS_TITLE = "Status: ";
const string GUI_PARAM_POPUP_PROPERTY_OPACITY = "imageOpacity";
const string GUI_PARAM_POPUP_PROPERTY_MESSAGE = "userMessage";
const string GUI_PARAM_POPUP_PROPERTY_ISANIMATE = 
	"isStartAnimation";
const string GUI_PARAM_DISPLAY_DATE_TODAY = "Today";
const int GUI_MIN_CHAR = 0;
const int GUI_MAX_CHAR = 255;

const string COMMAND_PARAM_EDIT = "/edit";
const string COMMAND_PARAM_DELETE_WITH_REAL_INDEX = "/delete_r";
const string COMMAND_PARAM_DONE_WITH_REAL_INDEX = "/done_r";
const string COMMAND_PARAM_UNDONE_WITH_REAL_INDEX = "/undone_r";
const string COMMAND_PARAM_DELETE = "/delete";
const string COMMAND_PARAM_DONE = "/done";
const string COMMAND_PARAM_UNDONE = "/undone";
const string COMMAND_PARAM_CLEAR = "/clear";
const string COMMAND_PARAM_HELP = "/help";
const string COMMAND_PARAM_UNDO = "/undo";
const string COMMAND_PARAM_REDO = "/redo";
const string COMMAND_PARAM_LOAD = "/load";
const string COMMAND_PARAM_FILTER = "/filter";
const string COMMAND_PARAM_SEARCH = "/search";
const string COMMAND_PARAM_HELP_EDIT = "edit";
const string COMMAND_PARAM_HELP_ADD = "add";
const string COMMAND_PARAM_HELP_DELETE = "delete";
const string COMMAND_PARAM_HELP_DONE = "done";
const string COMMAND_PARAM_HELP_CLEAR = "clear";
const string COMMAND_PARAM_HELP_UNDO = "undo";
const string COMMAND_PARAM_HELP_REDO = "redo";
const string COMMAND_PARAM_HELP_LOAD = "load";
const string COMMAND_PARAM_HELP_FILTER = "filter";
const string COMMAND_PARAM_HELP_SEARCH = "search";
const string COMMAND_PARAM_ADD_DATE_DEADLINE = "by ";
const string COMMAND_PARAM_ADD_DATE_TIMED_ALLDAY = "on ";
const string COMMAND_PARAM_ADD_DATE_TIMED_START = "from ";
const string COMMAND_PARAM_ADD_DATE_TIMED_END = "to ";

const string MSG_ERROR_USER_WRONG_INDEX = "No such display index!";
const string MSG_ERROR_USER_WRONG_PARAMS = 
	"Command parameters wrong!";
const string MSG_ERROR_INSUFFICIENT_INPUT =
	"Insufficient input parameters!";
const string MSG_ERR_CHANGED_HTML_ELEMENT_MISSING =
	"Changed html element missing!";
const string MSG_ERR_UNACCEPTED_CHARS_ENTERED = 
	"Unaccepted characters entered!";

const string RESOURCE_PATHS_HELP_ADD = 
	"/UI Files/Help/Help_Add.html";
const string RESOURCE_PATHS_HELP_DELETE = 
	"/UI Files/Help/Help_Delete.html";
const string RESOURCE_PATHS_HELP_EDIT = 
	"/UI Files/Help/Help_Edit.html";
const string RESOURCE_PATHS_HELP_DONE = 
	"/UI Files/Help/Help_Done.html";
const string RESOURCE_PATHS_HELP_CLEAR = 
	"/UI Files/Help/Help_Clear.html";
const string RESOURCE_PATHS_HELP_SEARCH = 
	"/UI Files/Help/Help_Search.html";
const string RESOURCE_PATHS_HELP_UNDO = 
	"/UI Files/Help/Help_Undo.html";
const string RESOURCE_PATHS_HELP_REDO = 
	"/UI Files/Help/Help_Redo.html";
const string RESOURCE_PATHS_HELP_FILTER = 
	"/UI Files/Help/Help_Filter.html";
const string RESOURCE_PATHS_HELP_CONTENT = 
	"/UI Files/Help/Help_Content.html";

const string ABBREV_MONTH_JAN = "Jan";
const string ABBREV_MONTH_FEB = "Feb";
const string ABBREV_MONTH_MAR = "Mar";
const string ABBREV_MONTH_APR = "Apr";
const string ABBREV_MONTH_MAY = "May";
const string ABBREV_MONTH_JUN = "Jun";
const string ABBREV_MONTH_JUL = "Jul";
const string ABBREV_MONTH_AUG = "Aug";
const string ABBREV_MONTH_SEP = "Sep";
const string ABBREV_MONTH_OCT = "Oct";
const string ABBREV_MONTH_NOV = "Nov";
const string ABBREV_MONTH_DEC = "Dec";

const string ABBREV_WEEK_MON = "Mon";
const string ABBREV_WEEK_TUE = "Tues";
const string ABBREV_WEEK_WED = "Wed";
const string ABBREV_WEEK_THU = "Thurs";
const string ABBREV_WEEK_FRI = "Fri";
const string ABBREV_WEEK_SAT = "Sat";
const string ABBREV_WEEK_SUN = "Sun";

const string STRING_SPACE_CHAR = " ";
const string STRING_NEWLN_CHAR = "\n";
const string STRING_RETURN_CHAR = "\r";
const string STRING_DOT_CHAR = ".";
const string STRING_COMMA_CHAR = ",";
const string STRING_ZERO_CHAR = "0";
const string STRING_AM = "am";
const string STRING_PM = "pm";
const string STRING_ALL_DAY = "All Day";

class WhatToDo : public QMainWindow
{
	Q_OBJECT

	public:
		WhatToDo(string exeDirectory, QWidget *parent = 0);
		~WhatToDo();

		// This event handler handles commands which are given by the
		// user through the calendar.

		void handleCalendarCommands(string command);
		void updateCalendarView();

	public slots:
		
		/*
		// All public event handlers are triggered when various events
		// occur within the GUI according to the user's interactions
		// with the program, and changes to the GUI have to be made via
		// these event handlers.
		*/

		// This event handler is called when the "Return" key is 
		// pressed for a widget with the KeyPressEater installed. In the
		// case where the "Return" key is pressed for the command entry 
		// field, this event handler will update the GUI accordingly 
		// depending on the user's command.

		void handleKeyPressEvents(QObject* obj);

		// This event handler is called when the "Tab" key is 
		// pressed for a widget with the KeyPressEater installed. This
		// event handler will alternate between the search bar and the command 
		// entry field when the "Tab" key is pressed.

		void handleEntryFieldTab();

		// This event handler is called when the search bar is entered through 
		// a hotkey event. This event handler will highlight all the text in the
		// search bar.

		void handleEntryIntoSearchBar();

		// This event handler is called when the user changes the contents of the
		// search bar, and it will update the GUI according to the user's 
		// desired search contents.

		void handleSearchBarChange();

		// These event handlers are called when hotkeys are pressed by the user.
		// The event handler titles should be self-explanatory.

		void handleHotkeyMinimize();
		void handleHotkeyEdit();
		void handleHotkeyDelete();
		void handleHotkeyDone();
		void handleHotkeyUndone();
		void handleHotkeyFilter();
		void handleHotkeyClear();
		void handleHotkeyHelp();

		// These event handlers are called when buttons are pressed by 
		// the user. The event handler titles should be self-explanatory.

		void handleButtonUndo();
		void handleButtonRedo();
		void handleButtonToggleCalendar();
		void handleButtonToggleAgenda();
		void handleButtonCalendarPrev();
		void handleButtonCalendarNext();

	private:
		
		// Attributes For Execution
		
		Ui::WhatToDoClass _ui;
		KeyPressEater* _myKeyPressEater;
		State _currState;
		State _tempFutureState;
		string _exeDirectory;
		CalendarCanvas* _SFMLView;
		bool _b_calender_init_complete;

		enum userCommandType { 
			COMMAND_OTHERS = 1, COMMAND_EDIT, 
			COMMAND_DONE_WITH_REAL_INDEX, 
			COMMAND_UNDONE_WITH_REAL_INDEX, 
			COMMAND_DELETE_WITH_REAL_INDEX,
			COMMAND_DONE, COMMAND_UNDONE, 
			COMMAND_DELETE, COMMAND_UNDO, COMMAND_HELP, 
			COMMAND_HELP_ADD, COMMAND_HELP_EDIT, 
			COMMAND_HELP_DELETE, COMMAND_HELP_DONE, 
			COMMAND_HELP_SEARCH, COMMAND_HELP_CLEAR, 
			COMMAND_HELP_UNDO, COMMAND_HELP_REDO, 
			COMMAND_HELP_FILTER
		};

		/*
		// These functions set up the GUI at startup by loading the
		// relevant graphic and information configurations to get it up
		// and running at startup. The function names should be self-
		// explanatory.
		*/

		void setupCalendar();
		void setupKeyPressEater();
		void setupOtherUIConfigs();
		void connectAllOtherSignalAndSlots();
		void defineAllHotkeys();
		void loadSavedSettings();

		void setupInitialGUIFocusConfigs();
		void setupInitialGUISizeConfigs();
		void setupMessageBoxConfigs();
		void setupTextSizeConfigs();

		/*
		// These functions handle the updating of GUI elements when there
		// are changes such as (i) user messages to display; or (ii) new view
		// states to display because the user made an action.
		*/

		// These functions update the GUI when there are new popup messages or
		// status bar messages to display to the user
		
		void showLogicUserFeedback();
		void showGUIUserFeedback(string guiUserFeedback);
		
		// These function updates the entire GUI according to the current 
		// contents in the search bar.

		void updateGUIFromSearchBar();

		// These function updates the entire GUI according to the current 
		// contents in the command entry field.

		void updateGUIFromCommandLine();

		// These function updates the GUI according to a command string
		// 
		// Pre-condition: 
		//     (i) the parameter commandString passed in must be 
		//     a valid command according to the checkIsUserCommandInputValid()
		//     function.

		void updateGUIWithCommandString(string commandString);

		// These functions update the agenda view in the GUI according to
		// the current state within this particular whattodo instance.

		void updateAgendaView();
		void markLastActionForUser(int timedViewScrollPos, int floatViewScrollPos);

		// This function refreshes the current state and temporary future states
		// within this particular whattodo instance according to the given
		// commandString.
		//
		// Pre-conditions: 
		//     (i) the parameter commandString passed in must be 
		//     a valid command according to the checkIsUserCommandInputValid()
		//     function.
		//     (ii) if the command implied by the parameter commandString is
		//     contains a task index, it should be the actual task index instead
		//     of the display index in the GUI
		//

		void refreshCurrStateWithCommand(string commandString);

		// This function checks if a given command string is considered 
		// valid user input 
		//
		// Pre-conditions: none
		// Post-conditions: 
		//     (i) returns true if the user input does not contain unwanted
		//     characters and is non-empty (not counting newline characters).

		bool checkIsUserCommandInputValid(string usercommandString);

		// This function determines and returns the user's command type given
		// a command string.

		int determineCommandType(string usercommandString);

		// The following functions execute the user's command string accordingly.
		//
		// Pre-conditions: 
		//     (i) the parameter commandString passed in should be a valid command
		//     according to the checkIsUserCommandInputValid() function.
		//     (ii) the parameter commandString passed in should be a command
		//     corresponding to the function name. For instance, the processCommandEdit()
		//     function should only be called to handle a commandString for an 
		//     edit command.

		void processCommandEdit(string commandString);
		void processCommandDone(string commandString, bool b_usingRealIndex);
		void processCommandUndone(string commandString, bool b_usingRealIndex);
		void processCommandDelete(string commandString, bool b_usingRealIndex);
		void processCommandOthers(string commandString);

		/*
		// These are functions that facilitate the construction of html tags
		// for display of the current state in the agenda view which is
		// to be shown to the user.
		*/

		string getAgendaTimedViewHtml();
		string getAgendaFloatViewHtml();
		string createDateTitleHtml(ptime titleDate);
		string createPreNumberingHtml(int startNumber);
		string createFloatingTaskHtml(Task taskToProcess);
		string createNonFloatingTaskHtml(Task taskToProcess);
		string getTaskNameTagsHtml(Task myTask);
		string getLastActionTextIndexHtml(Task taskToProcess);
		string getHtmlPreTaskTags(Task taskToProcess);

		/*
		// Other low-level functions which generally deal with formatting
		// issues and text conversions.
		*/

		ptime getTaskOrderingDate(Task myTask);
		string getDisplayTime(ptime myTime);
		string getDisplayDay(ptime myTime);
		string getDisplayDayWithoutTime(ptime myTime);
		string removeUnwantedChars(string stringToProcess);
		string changeDayToDayOfWeek(int day);
		string changeMonthToMonthOfYear(int year);
		string convertTaskToEditText(Task taskToConvert);
		string getTaskDateAsEditText(Task taskToConvert);
		string convertDateTimeToEditText(ptime timeToConvert);
		string convertDateToEditText(ptime timeToConvert);
		bool checkIsContainStrangeChars(string stringToProcess);
		bool checkIsCurrentStateEmpty();
};

#endif // WHATTODO_H

	// End of segment: ./\whattodo.h





