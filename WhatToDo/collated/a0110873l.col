//@author: a0110873l



	/**
	 * origin: ./\LogicData.h
	 */

//
//LogicData is responsible for holding the current State, view State and
//initial State. It also keeps track of the commands that are executed from 
//the time that WhatToDo is executed. This allows for easy redoing and undoing
//from caller methods such as Command::Undo and Command::Redo. Also, LogicData
//supports Command::Filter as well, it is able to support filters such as:
//	1) Status
//		a) Done & Undone
//		b) Done only
//		c) Undone Only
//	2) Task type
//		a) All types
//		b) Fixed Timed
//		c) Deadline
//	3) Date
//
//Furthermore, LogicData support the logging of functions executed and errors 
//should they occur. Logging mode can be turned on or off in the constructor
//based on the developer's requirements
//****************************************************************************

#ifndef LOGICDATA_H
#define LOGICDATA_H

#include <iostream>
#include <fstream>
#include <vector>
#include "State.h"
#include "StorageExecutor.h"

enum Status {
	STATUS_NOT_SET = -1, DONE_BOTH, ONLY_DONE, ONLY_UNDONE
};

enum Type {
	TYPE_NOT_SET = -1, ALL_TYPES, ONLY_FIXED, ONLY_DUE
};

enum Month {
	JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT,
	NOV, DEC
};

class Command;

class LogicData {

	private:
		//Attributes for LogicData
		static State _currentState;
		static State _viewState;
		static State _initialState;
		static vector<Command*> _commandHistory;
		static int _currentCommandHistoryIndex;
		static int _doneFilter;
		static int _typeFilter;
		static date _startDateFilter;
		static date _endDateFilter;

		//Attributes for Logging
		static string _logFileName;
		static bool _loggingModeOn;
		static char buffer[255];

	public:
		//Constructor
		LogicData();

		//Setters
		static void setCurrentState(State stateToSet);
		static void setViewState(State stateToSet);
		static void setDoneFilter(int doneFilter);
		static void setTypeFilter(int typeFilter);
		static void setDateFilter(date startDateFilter, date endDateFilter);
		static void setCommandHistoryIndex(int indexToSet);

		//Getters
		static State getCurrentState();
		static State getViewState();
		static vector<Command*> getCommandHistory();
		static int getCurrentCommandHistoryIndex();
		static int getDoneFilter();
		static int getTypeFilter();
		static date getStartDateFilter();
		static date getEndDateFilter();

		//Operations
		static void resetCommandHistory();
		static void addCommandToHistory(Command* commandToAdd);
		static void resetToInitialSettings();
		static void loadInitialSettings();
		static void fakeinitiate(State fakestate);
		static State filterTasks();
		static bool passDoneFilter(Task task);
		static bool passTypeFilter(Task task);
		static bool passDateFilter(Task task);
		static string getFilterStatus();
		static string changeMonthToMonthOfYear(int month);
		static string getDisplayDay(ptime myTime);
		static string compileStartDateFilterStatus(string dateFilterStatus, 
			date startDateFilter);
		static string compileEndDateFilterStatus(string dateFilterStatus, 
			date endDateFilter);
		static string compileFilterStatus(string doneFilterStatus,
			string typeFilterStatus, string dateFilterStatus);
		static string compileNewActionMessage(State filteredViewState);

		//Logging
		static void log(string stringToLog);
		static bool isLoggingModeOn();
		static void setLoggingModeOff();
		static void setLoggingModeOn();

		//Constants
		static const int INITIAL_COMMAND_HISTORY_INDEX;

		static const string ABBREV_MONTH_JAN;
		static const string ABBREV_MONTH_FEB;
		static const string ABBREV_MONTH_MAR;
		static const string ABBREV_MONTH_APR;
		static const string ABBREV_MONTH_MAY;
		static const string ABBREV_MONTH_JUN;
		static const string ABBREV_MONTH_JUL;
		static const string ABBREV_MONTH_AUG;
		static const string ABBREV_MONTH_SEP;
		static const string ABBREV_MONTH_OCT;
		static const string ABBREV_MONTH_NOV;
		static const string ABBREV_MONTH_DEC;
		static const string STRING_SPACE_CHAR;
		static const string STRING_FRONTSLASH_CHAR;
		static const string STRING_FROM;
		static const string STRING_TO;
		static const string STRING_FILTERED_BY;
		static const string STRING_COLON;
		static const string STRING_VERTICAL_BAR_CHAR;
		static const string STRING_EMPTY;
		static const string STRING_NO_DONE;
		static const string STRING_DONE;
		static const string STRING_UNDONE;
		static const string STRING_ALL_TYPES;
		static const string STRING_ONLY_FIXED;
		static const string STRING_ONLY_DUE;

		static const string LOG_LOGIC_DATA_FILE_NAME;
		static const string LOG_MSG_CURRENT_STATE_SET;
		static const string LOG_MSG_VIEW_STATE_SET;
		static const string LOG_MSG_DONE_FILTER_SET;
		static const string LOG_MSG_TYPE_FILTER_SET;
		static const string LOG_MSG_DATE_FILTER_SET;
		static const string LOG_MSG_COMMAND_HISTORY_RESET;
		static const string LOG_MSG_COMMAND_HISTORY_ADDED;
		static const string LOG_MSG_RESET;
		static const string LOG_MSG_LOAD;

		static const string ERR_MSG_INVALID_TASK_TYPE;
		static const string ERR_MSG_INVALID_STATUS_TYPE;
};

#endif
	// End of segment: ./\LogicData.h





	/**
	 * origin: ./\LogicDataUnitTests\LogicDataTests.cpp
	 */

//
//testLogicData
//****************************************************************************

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace std;

namespace testLogicDataComponent {		
	TEST_CLASS(TestTask) {
		public:
		
			TEST_METHOD(testInitTask) {
				Task myTask;

				//Check if TaskStartTime is initialized as "NULL"
				Assert::AreEqual(true, myTask.getTaskStartTime().is_not_a_date_time());

				//Check if TaskEndTime is initialized as "NULL"
				Assert::AreEqual(true, myTask.getTaskEndTime().is_not_a_date_time());
			
				//Check if TaskDeadline is initialized as "NULL"
				Assert::AreEqual(true, myTask.getTaskDeadline().is_not_a_date_time());
			}

			TEST_METHOD(testTaskTypeFloating) {
				//Checking for FLOATING tasks
				Task floatTask;
				Assert::AreEqual(int(Task::TaskType::FLOATING), floatTask.getTaskType());
			}

			TEST_METHOD(testTaskTypeDeadlineTime) {
				//Checking for DEADLINE_TIME tasks
				Task deadlineTimeTask;
				deadlineTimeTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				Assert::AreEqual(int(Task::TaskType::DEADLINE_TIME), deadlineTimeTask.getTaskType());
			}

			TEST_METHOD(testTaskTypeDeadlineAllDay) {
				//Checking for DEADLINE_ALLDAY tasks
				Task deadlineAllDayTask;
				deadlineAllDayTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(0,0,1)));
				Assert::AreEqual(int(Task::TaskType::DEADLINE_ALLDAY), deadlineAllDayTask.getTaskType());
			}

			TEST_METHOD(testTaskTypeFixedAllDay) {
				//Checking for FIXED_ALLDAY tasks
				Task fixedAllDayTask;
				fixedAllDayTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(0,0,1)));
				Assert::AreEqual(int(Task::TaskType::FIXED_ALLDAY), fixedAllDayTask.getTaskType());
			}
			
			TEST_METHOD(testTaskTypeFixedDayToDay) {
				//Checking for FIXED_DAY_TO_DAY tasks
				Task fixedDayToDayTask;
				fixedDayToDayTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(0,0,1)));
				fixedDayToDayTask.setTaskEndTime(ptime (date(2014,Dec,15), time_duration(0,0,1)));
				Assert::AreEqual(int(Task::TaskType::FIXED_DAY_TO_DAY), fixedDayToDayTask.getTaskType());
			}

			TEST_METHOD(testTaskTypeFixedDayToTime) {
				//Checking for FIXED_DAY_TO_TIME tasks
				Task fixedDayToTimeTask;
				fixedDayToTimeTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(0,0,1)));
				fixedDayToTimeTask.setTaskEndTime(ptime (date(2014,Dec,15), time_duration(10,30,0)));
				Assert::AreEqual(int(Task::TaskType::FIXED_DAY_TO_TIME), fixedDayToTimeTask.getTaskType());
			}

			TEST_METHOD(testTaskTypeFixedStart) {
				//Checking for FIXED_START tasks
				Task fixedStartTask;
				fixedStartTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,30,1)));
				Assert::AreEqual(int(Task::TaskType::FIXED_START), fixedStartTask.getTaskType());
			}

			TEST_METHOD(testTaskTypeFixedTimeWithinDay) {
				//Checking for FIXED_TIME_WITHIN_DAY tasks
				Task fixedTimeWithinDayTask;
				fixedTimeWithinDayTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				fixedTimeWithinDayTask.setTaskEndTime(ptime (date(2014,Dec,10), time_duration(16,30,0)));
				Assert::AreEqual(int(Task::TaskType::FIXED_TIME_WITHIN_DAY), fixedTimeWithinDayTask.getTaskType());
			}

			TEST_METHOD(testTaskTypeFixedTimeAcrossDay) {
				//Checking for FIXED_TIME_ACROSS_DAY tasks
				Task fixedTimeAcrossDayTask;
				fixedTimeAcrossDayTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				fixedTimeAcrossDayTask.setTaskEndTime(ptime (date(2014,Dec,12), time_duration(16,30,0)));
				Assert::AreEqual(int(Task::TaskType::FIXED_TIME_ACROSS_DAY), fixedTimeAcrossDayTask.getTaskType());
			}
			
			TEST_METHOD(testTaskTypeFixedTimeToDay) {
				//Checking for FIXED_TIME_TO_DAY tasks
				Task fixedTimeToDayTask;
				fixedTimeToDayTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				fixedTimeToDayTask.setTaskEndTime(ptime (date(2014,Dec,12), time_duration(0,0,1)));
				Assert::AreEqual(int(Task::TaskType::FIXED_TIME_TO_DAY), fixedTimeToDayTask.getTaskType());
			}

			TEST_METHOD(testTaskIsEarlier) {
				Task firstTask;
				Task secondTask;

           		//case where first task is earlier than second task (test for 'positive' value segment)
				//   first task          [   
				//   second task             [
				firstTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,11), time_duration(1,2,3)));
				Assert::AreEqual(true, firstTask.isEarlierThan(secondTask));

				//case where first task is later than second task (test for 'negative' value segment)
				//   first task                 [
				//   second task         [
				firstTask.setTaskStartTime(ptime (date(2002,Jan,13), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,11), time_duration(1,2,3)));
				Assert::AreEqual(false, firstTask.isEarlierThan(secondTask));

				//case where first task starts the same as second task (test for 'boundary' value segment)
				//   first task          [
				//   second task         [
				firstTask.setTaskStartTime(ptime (date(2002,Jan,11), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,11), time_duration(1,2,3)));
				Assert::AreEqual(false, firstTask.isEarlierThan(secondTask));
			}

			TEST_METHOD(testTaskIsOverlap) {
				Task firstTask;
				Task secondTask;
       
				//case where start time of second task is between start and end times of first task
				//   first task          [     ] 
				//   second task            [     ]
				firstTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				firstTask.setTaskEndTime(ptime (date(2002, Jan, 12), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,11), time_duration(1,2,3)));
				secondTask.setTaskEndTime(ptime (date(2002, Jan, 13), time_duration(1,2,3)));
				Assert::AreEqual(true, firstTask.isTaskOverlapWith(secondTask));

				//case where end time of second task is between start and end times of first task
				//   first task          [     ]
				//   second task      [     ]
 				firstTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				firstTask.setTaskEndTime(ptime (date(2002, Jan, 12), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,9), time_duration(1,2,3)));
				secondTask.setTaskEndTime(ptime (date(2002, Jan, 11), time_duration(1,2,3)));
				Assert::AreEqual(true, firstTask.isTaskOverlapWith(secondTask));

				//case where start time of second task equals the end time of the first task
				//   first task          [     ]
				//   second task               [     ]
				firstTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				firstTask.setTaskEndTime(ptime (date(2002, Jan, 12), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,12), time_duration(1,2,3)));
				secondTask.setTaskEndTime(ptime (date(2002, Jan, 14), time_duration(1,2,3)));
				Assert::AreEqual(false, firstTask.isTaskOverlapWith(secondTask));

				//case where end time of second task equals the start time of the first task
				//   first task          [     ]
				//   second task   [     ]
				firstTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				firstTask.setTaskEndTime(ptime (date(2002, Jan, 12), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,8), time_duration(1,2,3)));
				secondTask.setTaskEndTime(ptime (date(2002, Jan, 10), time_duration(1,2,3)));
				Assert::AreEqual(false, firstTask.isTaskOverlapWith(secondTask));

				//case where end time of second task equals the end time of the first task
				//    first task         [     ]      
				//    second task           [  ]
				firstTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				firstTask.setTaskEndTime(ptime (date(2002, Jan, 12), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,11), time_duration(1,2,3)));
				secondTask.setTaskEndTime(ptime (date(2002, Jan, 12), time_duration(1,2,3)));
				Assert::AreEqual(true, firstTask.isTaskOverlapWith(secondTask));

 				//case where start time of second task equals the start time of the first task
				//    first task         [     ]      
				//    second task        [  ]
				firstTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				firstTask.setTaskEndTime(ptime (date(2002, Jan, 12), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				secondTask.setTaskEndTime(ptime (date(2002, Jan, 11), time_duration(1,2,3)));
				Assert::AreEqual(true, firstTask.isTaskOverlapWith(secondTask));
			}

			TEST_METHOD(testTaskIsSortedBefore) {
				//FlOATING VS DEADLINE_TIME
				Task floatTask;

				Task deadlineTimeTask;
				deadlineTimeTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(14,29,0)));

				Assert::AreEqual(true, floatTask.isTaskSortedBefore(floatTask, deadlineTimeTask));

				//DEADLINE_TIME VS FIXED_START , deadline is earlier than start time of fixed task
				Task fixedStartTask;
				fixedStartTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,30,1)));

				Assert::AreEqual(false, fixedStartTask.isTaskSortedBefore(fixedStartTask, deadlineTimeTask));

				//FIXED_START VS FIXED_START - 2nd time starts later
				Task fixedStartTaskTwo;
				fixedStartTaskTwo.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,40,1)));

				Assert::AreEqual(true, fixedStartTask.isTaskSortedBefore(fixedStartTask, fixedStartTaskTwo));

				//FIXED_START VS FIXED_START - same start times
				Task fixedStartTaskThree;
				fixedStartTaskThree.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,40,1)));
				fixedStartTaskTwo.setTaskIndex(1);
				fixedStartTaskThree.setTaskIndex(10);

				Assert::AreEqual(true, fixedStartTaskTwo.getTaskIndex() < fixedStartTaskThree.getTaskIndex());
				Assert::AreEqual(true, fixedStartTaskTwo.isTaskSortedBefore(fixedStartTaskTwo, fixedStartTaskThree));		

				//FIXED_START VS FIXED_TIME_WITHIN_DAY - same start times, one fixed time, other fixed start(Higher precedence)
				Task fixedTimeWithinDayTask;
				fixedTimeWithinDayTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,40,0)));		
				fixedTimeWithinDayTask.setTaskEndTime(ptime (date(2014,Dec,10), time_duration(15,40,0)));	

				Assert::AreEqual(true, fixedStartTaskThree.isTaskSortedBefore(fixedStartTaskThree, fixedTimeWithinDayTask));
			}
	};

	TEST_CLASS(TestState) {
		public:

			TEST_METHOD(testStateAdd) {
				State myState;
				vector<Task> listOfTasks,listOfStateTasks;
				Task temp;

				temp.setTaskName("Go and Fish");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("I will go and run");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and Laugh");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and LOL");
				myState.addTask(temp);
				listOfTasks.push_back(temp);

				listOfStateTasks = myState.getAllTasks();

				for(int i=0; i< int(listOfTasks.size()); i++) {
					Assert::AreEqual(listOfTasks[i].getTaskName(), listOfStateTasks[i].getTaskName());
				}
			}

			TEST_METHOD(testStateDelete) {
				State myState;
				vector<Task> listOfTasks,listOfStateTasks;
				Task temp;

				//Adding Tasks
				temp.setTaskName("Go and Fish");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("I will go and run");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and Laugh");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and LOL");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
			
				//Deleting
				myState.deleteTask(1);
				listOfTasks.erase(listOfTasks.begin() + 1);

				//Checking
				listOfStateTasks = myState.getAllTasks();
				for(int i=0; i<int(listOfTasks.size());i++){
					Assert::AreEqual(listOfTasks[i].getTaskName(),listOfStateTasks[i].getTaskName());
				}

			}

			TEST_METHOD(testStateClear) {
				State myState;
				vector<Task> listOfTasks,listOfStateTasks;
				Task temp;

				//Adding Tasks
				temp.setTaskName("Go and Fish");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("I will go and run");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and Laugh");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and LOL");
				myState.addTask(temp);
				listOfTasks.push_back(temp);

				//Clear Tasks
				myState.clearAllTasks();
				listOfStateTasks = myState.getAllTasks();
            
				//Checking
				Assert::AreEqual(0, int(listOfStateTasks.size()));
			}

			TEST_METHOD(testStateGetFloatingTasks) {
				State myState;
				vector<Task> listOfTasks,listOfStateTasks;
				Task temp;

				//Adding Floating Tasks
				temp.setTaskName("Go and Fish");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("I will go and run");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and Laugh");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and LOL");
				myState.addTask(temp);
				listOfTasks.push_back(temp);

				//Adding Fixed Task
				Task fixedAllDayTask;
				fixedAllDayTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(0,0,1)));
				myState.addTask(fixedAllDayTask);

				//Adding Deadline Task
				Task deadlineAllDayTask;
				deadlineAllDayTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(0,0,1)));				
				myState.addTask(deadlineAllDayTask);

				//Checking
				listOfStateTasks = myState.getFloatingTasks();
				Assert::AreEqual(int(listOfTasks.size()), int(listOfStateTasks.size()));
				for(int i=0; i<int(listOfTasks.size());i++){
					Assert::AreEqual(listOfTasks[i].getTaskName(),listOfStateTasks[i].getTaskName());
				}
			}
	};

	TEST_CLASS(TestLogicData) {
		public:
			enum Status {
				STATUS_NOT_SET = -1, DONE_BOTH, ONLY_DONE, ONLY_UNDONE
			};

			enum Type {
				TYPE_NOT_SET = -1, ALL_TYPES, ONLY_FIXED, ONLY_DUE
			};

			TEST_METHOD(testInitialisation) {
				LogicData myLogicData;

				Assert::AreEqual(LogicData::INITIAL_COMMAND_HISTORY_INDEX,
					myLogicData.getCurrentCommandHistoryIndex());
				Assert::AreEqual(LogicData::Status::ONLY_UNDONE, 
					myLogicData.getDoneFilter());
				Assert::AreEqual(LogicData::Type::ALL_TYPES,
					myLogicData.getTypeFilter());
				Assert::AreEqual(boost::gregorian::date(neg_infin),
					myLogicData.getStartDateFilter());
				Assert::AreEqual(boost::gregorian::date(pos_infin),
					myLogicData.getEndDateFilter());
			}

			TEST_METHOD(testDoneFilter) {
				LogicData myLogicData;

				myLogicData.setDoneFilter(LogicData::Status::ONLY_DONE);

				State myState;
				Task temp;
				vector<Task> expectedTasks, actualTasks;

				temp.setTaskName("Go and Fish");
				temp.setTaskIsDone();
				myState.addTask(temp);
				expectedTasks.push_back(temp);
				
				temp.setTaskName("I will go and run");
				temp.setTaskIsNotDone();
				myState.addTask(temp);

				temp.setTaskName("Go and Laugh");
				myState.addTask(temp);

				temp.setTaskName("Go and LOL");
				temp.setTaskIsDone();
				myState.addTask(temp);
				expectedTasks.push_back(temp);

				myLogicData.setViewState(myState);
				State myfilteredState;
				myfilteredState = myLogicData.filterTasks();

				actualTasks = myfilteredState.getAllTasks();

				for(int i=0; i< int(expectedTasks.size()); i++) {
					Assert::AreEqual (expectedTasks[i].getTaskName(),
						actualTasks[i].getTaskName());
				}
			}

			TEST_METHOD(testUndoneFilter) {
				LogicData myLogicData;

				myLogicData.setDoneFilter(Status::ONLY_UNDONE);

				State myState;
				Task temp;
				vector<Task> expectedTasks, actualTasks;

				temp.setTaskName("Go and Fish");
				temp.setTaskIsDone();
				myState.addTask(temp);
				
				temp.setTaskName("I will go and run");
				temp.setTaskIsNotDone();
				myState.addTask(temp);
				expectedTasks.push_back(temp);

				temp.setTaskName("Go and Laugh");
				myState.addTask(temp);
				expectedTasks.push_back(temp);

				temp.setTaskName("Go and LOL");
				temp.setTaskIsDone();
				myState.addTask(temp);

				myLogicData.setViewState(myState);
				State myfilteredState;
				myfilteredState = myLogicData.filterTasks();

				actualTasks = myfilteredState.getAllTasks();

				for(int i=0; i< int(expectedTasks.size()); i++) {
					Assert::AreEqual (expectedTasks[i].getTaskName(),
						actualTasks[i].getTaskName());
				}
			}

			TEST_METHOD(testDeadlineFilter) {
				LogicData myLogicData;
				myLogicData.setTypeFilter(Type::ONLY_DUE);

				State myState;
				vector<Task> expectedTasks, actualTasks;
				
				Task deadlineTask;
				deadlineTask.setTaskName("Go and Fish");
				deadlineTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				myState.addTask(deadlineTask);
				expectedTasks.push_back(deadlineTask);

				deadlineTask.setTaskName("I will go and run");
				deadlineTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(16,30,0)));
				myState.addTask(deadlineTask);
				expectedTasks.push_back(deadlineTask);

				Task fixedTask;
				fixedTask.setTaskName("Go and Laugh");
				fixedTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				fixedTask.setTaskEndTime(ptime (date(2014,Dec,12), time_duration(16,30,0)));
				myState.addTask(fixedTask);

				fixedTask.setTaskName("Go and LOL");
				fixedTask.setTaskStartTime(ptime (date(2014,Dec,11), time_duration(14,30,0)));
				fixedTask.setTaskEndTime(ptime (date(2014,Dec,12), time_duration(16,30,0)));
				myState.addTask(fixedTask);

				myLogicData.setViewState(myState);
				State myfilteredState;
				myfilteredState = myLogicData.filterTasks();
				actualTasks = myfilteredState.getAllTasks();

				for(int i=0; i< int(expectedTasks.size()); i++) {
					Assert::AreEqual (expectedTasks[i].getTaskName(),
						actualTasks[i].getTaskName());
				}
			}	

			TEST_METHOD(testFixedFilter) {
				LogicData myLogicData;

				myLogicData.setTypeFilter(Type::ONLY_FIXED);

				State myState;
				vector<Task> expectedTasks, actualTasks;
				
				Task deadlineTask;
				deadlineTask.setTaskName("Go and Fish");
				deadlineTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				myState.addTask(deadlineTask);

				deadlineTask.setTaskName("I will go and run");
				deadlineTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(16,30,0)));
				myState.addTask(deadlineTask);

				Task fixedTask;
				fixedTask.setTaskName("Go and Laugh");
				fixedTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				fixedTask.setTaskEndTime(ptime (date(2014,Dec,12), time_duration(16,30,0)));
				myState.addTask(fixedTask);
				expectedTasks.push_back(fixedTask);

				fixedTask.setTaskName("Go and LOL");
				fixedTask.setTaskStartTime(ptime (date(2014,Dec,11), time_duration(14,30,0)));
				fixedTask.setTaskEndTime(ptime (date(2014,Dec,12), time_duration(16,30,0)));
				myState.addTask(fixedTask);
				expectedTasks.push_back(fixedTask);

				myLogicData.setViewState(myState);
				State myfilteredState;
				myfilteredState = myLogicData.filterTasks();
				actualTasks = myfilteredState.getAllTasks();

				for(int i=0; i< int(expectedTasks.size()); i++) {
					Assert::AreEqual (expectedTasks[i].getTaskName(),
						actualTasks[i].getTaskName());
				}
			}	
	};
}
	// End of segment: ./\LogicDataUnitTests\LogicDataTests.cpp





	/**
	 * origin: ./\State.h
	 */

//
//State is responsible for storing a list of Tasks. State primarily deals with
//the adding, deleting of Tasks. Also, when a Task is completed,
//State is able to set the Task as done. Other than this, State can return
//the caller a sorted list of specified Tasks based on these specifications:
//	1) Timed - Contain information such as StartDate or EndDate, but does not
//     have a deadline
//	2) Deadline - Specifically has a deadline
//	3) Floating - No StartDate and deadline
//
//Upon the execution of any function, State keeps track of its latest action
//type:
//	1) NONE - meaning that no changes were made
//  2) CHANGED - meaning that the State has changed with the addition of a new
//			task or a task is marked as done
//	3) DELETED - meaning that a Task has been deleted from State
//
//This information can be extracted from caller components such as LogicData
//through its getter functions
//****************************************************************************

#ifndef STATE_H
#define STATE_H

#include "Task.h"
#include <fstream>
using namespace std;

//Constants
const int UNSPECIFIED_INDEX = -1;
const int INITIAL_INDEX = 0;
const int TO_THE_RIGHT_BY_ONE = 1;
const bool UNSPECIFIED_USER_COMMAND = false;

const string LOG_STATE_FILE_NAME = "StateLog.txt";
const string LOG_MSG_TASK_ADDED = "Function called: addTask()\n";
const string LOG_MSG_TASK_DELETED = "Function called: deleteTask()\n";
const string LOG_MSG_TASK_DONE = "Function called: doneTask()\n";
const string LOG_MSG_TASKS_CLEARED = "Function called: clearAllTasks()\n";
const string LOG_MSG_TASKS_SORTED = "Function called: sortAllTasks()\n";

class State {
	private:
		//Attributes for State
		vector<Task> _entireListOfTasks;
		string _userMessage;
		string _actionMessage;
		int maxIndex;
		int _lastActionType;
		int _lastActionTaskIndex;

		//Attributes for Logging
		string _logFileName;
		bool _loggingModeOn;
		char buffer[255];

	public:
		//Constructor
		State();

		//Setters
		void setAllTasks(vector<Task> tasksToSet);
		void setUserMessage(string stringToSet);
		void setActionMessage(string stringToSet);
		void setLastActionType(int actionTypeToSet);
		void setLastActionTaskIndex(int actionTaskIndexToSet);
		
		//Getters
		string getUserMessage();
		string getActionMessage();
		int getLastActionType();
		int getLastActionTaskIndex();

		//Operations
		void addTask(Task taskToAdd, bool isUserCommand = UNSPECIFIED_USER_COMMAND, 
			int specifiedIndex = UNSPECIFIED_INDEX);
		void deleteTask(int taskIndexToDelete, 
			bool isUserCommand = UNSPECIFIED_USER_COMMAND);
		void doneTask(int taskIndexToDo, 
			bool isUserCommand = UNSPECIFIED_USER_COMMAND);
		void clearAllTasks();
		void sortAllTasks();
		vector<Task> getAllTasks();
		vector<Task> getTimedTasks();
		vector<Task> getDeadlineTasks();
		vector<Task> getFloatingTasks();
		bool isTimedTask(Task taskToCheck);
		bool isDeadlineTask(Task taskToCheck);
		bool isFloatingTask(Task taskToCheck);

		//Logging
		void log(string stringToLog);
		bool isLoggingModeOn();
		void setLoggingModeOff();
		void setLoggingModeOn();

		//Enumeration
		enum actionType { NONE = 1, CHANGED, DELETED };
};

#endif
	// End of segment: ./\State.h





	/**
	 * origin: ./\Task.h
	 */

//
//Task is the most fundamental component within WhatToDo and is responsible 
//for storing important details of a task such as its start time, end time, 
//deadline, name, tags and status (done or not done). In additional, a Task 
//has two additional functions – firstly it is able to check if two Tasks 
//overlap, and secondly it is able to check if a Task begins earlier than 
//another Task. A Task also can be defined in many types:
//	1)Floating Tasks - no start date time, no end date time and no deadline
//  2)Deadline Tasks
//		a) All Day - Meaning that the entire day is demarketed as the deadline
//		b) Time - Meaning that the deadline has a specific time
//	3)Fixed Tasks
//		a) Day
//			i) All Day - Meaning that one entire day is demarketed for the Task
//		   ii) Day To Time - Meaning that the start date is specified wih no 
//				time and the end date time is specified
//		  iii) Day To Day - Meaning that the start and end dates are both 
//				specified with no times specified	
//		b) Start - Meaning that the start time is specified without any end
//			datetime
//		c) Time 
//			i) Time Within Day - Meaning that the start time and end time are
//				specified within a single day
//		   ii) Time Across Day - Meaning that the start time and end time are
//				specified over one day
//		  iii) Time To Day - Meaning that the start time is specified and the
//				end date is specified with no time
//
//*Note: datetimes which occupy an entire day are marked with 1 second 
//		(000001 in HHMMSS)
//
//Logging is used to tracked changes within the internal workings of a Task
//However, it can be toggled on and off by the developer on an optional basis.
//This is because logging for a large number of Tasks may slow down the 
//computational processes within WhatToDo. This can be easily changed by
//setting _loggingModeOn to either true or false in the constructor.
//****************************************************************************

#ifndef TASK_H
#define TASK_H

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <exception>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/date_time/gregorian_calendar.hpp>

using namespace std;
using namespace boost::posix_time;
using namespace boost::gregorian;

//Constants
const int NUM_OF_COMP_FUNCTIONS = 8;
const int MARKED_AS_FULL_DAY = 1;
const int EMPTY = 0;
const string ERR_MSG_INVALID_FUNCTION_CALL = "INVALID_ARGUMENT: Function called does not exist\n";
const string LOG_TASK_FILE_NAME = "Task.txt";
const string LOG_MSG_INITIATE = "Constructor called: Task()\n";
const string LOG_MSG_COMPARE = "Function called: compare()\n";
const string LOG_MSG_TASK_SORTED_BEFORE = "Function called: isTaskSortedBefore()\n";
const string LOG_MSG_TASK_OVERLAP = "Function called: isTaskOverlapWith()\n";
const string LOG_MSG_TASK_DONE = "Function called: setTaskIsDone()\n";

class Task {
	private:
		//Attributes for Task
		ptime _taskStartDateTime;
		ptime _taskEndDateTime;
		ptime _taskDeadline;
		string _taskName;
		vector<string> _taskTags;
		int _taskIndex;
		bool _isDone;

		//Attributes for Logging
		string _logFileName;
		bool _loggingModeOn;
		char buffer[255];

	public:
		//Constructor
		Task();

		//Setters
		void setTaskStartTime(ptime dateTimeToSet);
		void setTaskEndTime(ptime dateTimeToSet);
		void setTaskDeadline(ptime dateTimeToSet);
		void setTaskName(string nameToSet);
		void setTaskTags(vector<string> tagsToSet);
		void setTaskIndex(int indexToSet);
		void setTaskIsDone(bool doneStatusToSet = true);
		void setTaskIsNotDone();

		//Getters
		int getTaskType();
		int getTaskIndex();
		ptime getTaskStartTime();
		ptime getTaskEndTime();
		ptime getTaskDeadline();
		time_duration getTaskDuration();
		string getTaskName();
		vector<string> getTaskTags();
		bool getTaskIsDone();
		
		//Primary Operations
		bool hasStartDateTime();
		bool hasEndDateTime();
		bool hasDeadline();
		bool isFullDay(ptime dateTimeToCheck);
		bool isStartDateEqualEndDate();
		bool isTaskTypeFixedDay(Task myTask);
		bool isTaskTypeFixedTime(Task myTask);
		bool isTaskOverlapWith(Task myTask);
		bool isEarlierThan(Task myTask);
		bool isTaskSortedBefore(Task firstTask, Task secondTask);
		bool compare(Task firstTask, Task secondTask, bool *orderConfirmed, int functionToCall);

		//Secondary Operations
		bool compareByFloat(Task firstTask, Task secondTask, bool *orderConfirmed);
		bool compareByDate(Task firstTask, Task secondTask, bool *orderConfirmed);
		bool compareByDeadlineAllDay(Task firstTask, Task secondTask, bool *orderConfirmed);
		bool compareByDeadlineTime(Task firstTask, Task secondTask, bool *orderConfirmed);
		bool compareByFixedDay(Task firstTask, Task secondTask, bool *orderConfirmed);
		bool compareByFixedStart(Task firstTask, Task secondTask, bool *orderConfirmed);
		bool compareByFixedTime(Task firstTask, Task secondTask, bool *orderConfirmed);
		bool compareByFixedTimeAndStart(Task firstTask, Task secondTask, bool *orderConfirmed);
		
		//Logging
		void log(string stringToLog);
		bool isLoggingModeOn();
		void setLoggingModeOff();
		void setLoggingModeOn();

		//Enumeration
		enum TaskType {
			 FLOATING = 1, DEADLINE_TIME, DEADLINE_ALLDAY, FIXED_ALLDAY, FIXED_DAY_TO_DAY, 
			 FIXED_DAY_TO_TIME, FIXED_START, FIXED_TIME_WITHIN_DAY, FIXED_TIME_ACROSS_DAY, 
			 FIXED_TIME_TO_DAY, NOT_A_TASK_TYPE 
		};

		//Compare Functions are arranged in order of precedence from greatest priority starting from 1.
		enum CompareType {
			COMPARE_FLOAT = 1, COMPARE_DATE, COMPARE_DEADLINE_ALLDAY, COMPARE_DEADLINE_TIME,
			COMPARE_FIXED_DAY, COMPARE_FIXED_START, COMPARE_FIXED_TIME, COMPARE_FIXED_TIME_START
		};
};

#endif
	// End of segment: ./\Task.h





