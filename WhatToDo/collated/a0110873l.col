//@author: a0110873l



	/**
	 * origin: ./\LogicData.cpp
	 */

#include "LogicData.h"

State LogicData::_currentState;
State LogicData::_viewState;
State LogicData::_initialState;
vector<Command*> LogicData::_commandHistory;
int LogicData::_currentCommandHistoryIndex;
int LogicData::_doneFilter;
int LogicData::_typeFilter;
date LogicData::_startDateFilter;
date LogicData::_endDateFilter;

//Constants
const int LogicData::INITIAL_COMMAND_HISTORY_INDEX = 0;

const string LogicData::ABBREV_MONTH_JAN = "Jan";
const string LogicData::ABBREV_MONTH_FEB = "Feb";
const string LogicData::ABBREV_MONTH_MAR = "Mar";
const string LogicData::ABBREV_MONTH_APR = "Apr";
const string LogicData::ABBREV_MONTH_MAY = "May";
const string LogicData::ABBREV_MONTH_JUN = "Jun";
const string LogicData::ABBREV_MONTH_JUL = "Jul";
const string LogicData::ABBREV_MONTH_AUG = "Aug";
const string LogicData::ABBREV_MONTH_SEP = "Sep";
const string LogicData::ABBREV_MONTH_OCT = "Oct";
const string LogicData::ABBREV_MONTH_NOV = "Nov";
const string LogicData::ABBREV_MONTH_DEC = "Dec";
const string LogicData::STRING_SPACE_CHAR = " ";
const string LogicData::STRING_FRONTSLASH_CHAR = "/";
const string LogicData::STRING_FROM = "from";
const string LogicData::STRING_TO = "to";
const string LogicData::STRING_FILTERED_BY = "Filtered by";
const string LogicData::STRING_COLON = ":";
const string LogicData::STRING_VERTICAL_BAR_CHAR = "|";
const string LogicData::STRING_EMPTY = "";
const string LogicData::STRING_NO_DONE = "nodone";
const string LogicData::STRING_DONE = "done";
const string LogicData::STRING_UNDONE = "undone";
const string LogicData::STRING_ALL_TYPES = "all types";
const string LogicData::STRING_ONLY_FIXED = "only fixed";
const string LogicData::STRING_ONLY_DUE = "only due";

const string LogicData::ERR_MSG_INVALID_TASK_TYPE = "INVALID_ARGUMENT: Task Type not known\n";
const string LogicData::ERR_MSG_INVALID_STATUS_TYPE = "INVALID_ARGUMENT: Status Type not known\n";

//Constructor
LogicData::LogicData() {
	_currentCommandHistoryIndex = INITIAL_COMMAND_HISTORY_INDEX;
	_doneFilter = Status::ONLY_UNDONE;
	_typeFilter = Type::ALL_TYPES;
	_startDateFilter = boost::gregorian::date(neg_infin);
	_endDateFilter = boost::gregorian::date(pos_infin);
}

//Setters
void LogicData::setCurrentState(State stateToSet) {
	_currentState = stateToSet;
	StorageExecutor myStorageExecutor;
	myStorageExecutor.saveToStorage(_currentState);
}

void LogicData::setViewState(State stateToSet) {
	_viewState = stateToSet;
}

void LogicData::setDoneFilter(int doneFilter) {
	_doneFilter = doneFilter;
}

void LogicData::setTypeFilter(int typeFilter) {
	_typeFilter = typeFilter;
}

void LogicData::setDateFilter(date startDateFilter, date endDateFilter) {
	_startDateFilter = startDateFilter;
	_endDateFilter = endDateFilter;
}

void LogicData::setCommandHistoryIndex(int indexToSet) {
	_currentCommandHistoryIndex = indexToSet;
}

//Getters
State LogicData::getCurrentState() {
	return _currentState;
}

State LogicData::getViewState() {
	return filterTasks();
}

vector<Command*> LogicData::getCommandHistory() {
	return _commandHistory;
}

int LogicData::getCurrentCommandHistoryIndex() {
	return _currentCommandHistoryIndex;
}

int LogicData::getDoneFilter() {
	return _doneFilter;
}

int LogicData::getTypeFilter() {
	return _typeFilter;
}

date LogicData::getStartDateFilter() {
	return _startDateFilter;
}

date LogicData::getEndDateFilter() {
	return _endDateFilter;
}

//Operations
void LogicData::resetCommandHistory() {
	_commandHistory.clear();
	return;
}

void LogicData::addCommandToHistory(Command* commandToAdd) {
	_commandHistory.push_back(commandToAdd);
	_currentCommandHistoryIndex++;
}

void LogicData::resetToInitialSettings() {
	_currentState = _initialState;
	_viewState = _initialState;
	_commandHistory.clear();
}

void LogicData::loadInitialSettings() {
	LogicData();
	StorageExecutor myStorageExecutor;
	State initialState = myStorageExecutor.loadFromStorage();
	_initialState = initialState;
	_currentState = initialState;
	_viewState = initialState;
}

void LogicData::fakeinitiate(State fakestate) {
	_initialState = fakestate;
	_currentState = _initialState;
	_viewState = _initialState;

}

State LogicData::filterTasks() {
	State filteredViewState = _viewState;
	vector<Task> unfilteredTasks = _viewState.getAllTasks();
	vector<Task> filteredTasks;
	try{
		for(auto iter = unfilteredTasks.begin(); iter != unfilteredTasks.end(); ++iter) {
			if(passDoneFilter(*iter) && passTypeFilter(*iter) && passDateFilter(*iter)) {
				filteredTasks.push_back(*iter);
			}
		}
	} catch (const invalid_argument& ia) {
	    cerr << ia.what();
	}
	filteredViewState.setAllTasks(filteredTasks);
	string newActionMessage = compileNewActionMessage(filteredViewState);
	filteredViewState.setActionMessage(newActionMessage);
	return filteredViewState;
}

bool LogicData::passDoneFilter(Task task) {
	try{
		switch(_doneFilter) {
			case(Status::DONE_BOTH) :
				return true;
			case(Status::ONLY_DONE) :
				return task.getTaskIsDone();
			case(Status::ONLY_UNDONE) :
				return !task.getTaskIsDone();
			default:;
				throw invalid_argument(ERR_MSG_INVALID_STATUS_TYPE);
		}
	} catch (const invalid_argument&) {
		throw;
	}
}

bool LogicData::passTypeFilter(Task task) {
	try{
		switch(_typeFilter) {
			case(Type::ALL_TYPES) :
				return true;
			case(Type::ONLY_FIXED) : 
				return !task.hasDeadline();
			case(Type::ONLY_DUE) :
				return task.hasDeadline() || !task.hasStartDateTime();
			default:;
				throw invalid_argument(ERR_MSG_INVALID_TASK_TYPE);
		}
	} catch (const invalid_argument&) {
		throw;
	}
}

bool LogicData::passDateFilter(Task task) {
	if(task.getTaskType() == Task::FLOATING) {
		return true;
	} else if(task.hasDeadline()) {
		return doesDeadlinePassDateFilter(task);
	} else if(task.hasStartDateTime() && task.hasEndDateTime()) {
		return doesStartDatePassDateFilter(task) && 
			doesEndDatePassDateFilter(task);
	} else if(task.hasStartDateTime() && !task.hasEndDateTime()) {
		return doesStartDatePassDateFilter(task);
	}
	return false;
}

string LogicData::getFilterStatus() {
	string filterStatus;
	string doneFilterStatus;
	string typeFilterStatus;
	string dateFilterStatus;
	
	switch(_doneFilter) {
		case(Status::DONE_BOTH) : {
			doneFilterStatus = STRING_NO_DONE;
			break;
		}
		case(Status::ONLY_DONE) : {
			doneFilterStatus = STRING_DONE;
			break;
		}
		case(Status::ONLY_UNDONE) : {
			doneFilterStatus = STRING_UNDONE;
			break;
		}
	}

	switch(_typeFilter) {
		case(Type::ALL_TYPES) : {
			typeFilterStatus = STRING_ALL_TYPES;
			break;
		}
		case(Type::ONLY_FIXED) : {
			typeFilterStatus = STRING_ONLY_FIXED;
			break;
		}
		case(Type::ONLY_DUE) : {
			typeFilterStatus = STRING_ONLY_DUE;
			break;
		}
	}

	if (_startDateFilter != boost::gregorian::date(neg_infin)) {
		dateFilterStatus = compileStartDateFilterStatus (dateFilterStatus,
			_startDateFilter);
	}
	if (_endDateFilter != boost::gregorian::date(pos_infin)) {
		dateFilterStatus = compileEndDateFilterStatus(dateFilterStatus,
			_endDateFilter);
	}

	filterStatus = compileFilterStatus(doneFilterStatus,
		typeFilterStatus, dateFilterStatus);

	return filterStatus;
}

string LogicData::getDisplayDay(ptime myTime) {
	string displayDay;
	displayDay += to_string(myTime.date().day());
	displayDay += STRING_SPACE_CHAR + changeMonthToMonthOfYear(myTime.date().month());
	displayDay += STRING_SPACE_CHAR + to_string(myTime.date().year());
	return displayDay;
}

string LogicData::changeMonthToMonthOfYear(int month) {
	if (month == Month::JAN) {
		return ABBREV_MONTH_JAN;
	} else if (month == Month::FEB) {
		return ABBREV_MONTH_FEB;
	} else if (month == Month::MAR) {
		return ABBREV_MONTH_MAR;
	} else if (month == Month::APR) {
		return ABBREV_MONTH_APR;
	} else if (month == Month::MAY) {
		return ABBREV_MONTH_MAY;
	} else if (month == Month::JUN) {
		return ABBREV_MONTH_JUN;
	} else if (month == Month::JUL) {
		return ABBREV_MONTH_JUL;
	} else if (month == Month::AUG) {
		return ABBREV_MONTH_AUG;
	} else if (month == Month::SEP) {
		return ABBREV_MONTH_SEP;
	} else if (month == Month::OCT) {
		return ABBREV_MONTH_OCT;
	} else if (month == Month::NOV) {
		return ABBREV_MONTH_NOV;
	} else if (month == Month::DEC) {
		return ABBREV_MONTH_DEC;
	}

	return STRING_EMPTY;
}

bool LogicData::doesDeadlinePassDateFilter(Task task) {
	return task.getTaskDeadline().date() >= _startDateFilter && 
			task.getTaskDeadline().date() <= _endDateFilter;
}

bool LogicData::doesStartDatePassDateFilter(Task task) {
    return task.getTaskStartTime().date() >= _startDateFilter && 
			task.getTaskStartTime().date() <= _endDateFilter;
}

bool LogicData::doesEndDatePassDateFilter(Task task) {
	return (task.getTaskEndTime().date() <= _endDateFilter) && 
			(task.getTaskEndTime().date() >= _startDateFilter);
}

string LogicData::compileStartDateFilterStatus(string dateFilterStatus, 
												date startDateFilter) {
	dateFilterStatus += STRING_SPACE_CHAR + STRING_FRONTSLASH_CHAR + 
		STRING_SPACE_CHAR + STRING_FROM + STRING_SPACE_CHAR + 
		getDisplayDay(ptime(_startDateFilter));
	return dateFilterStatus;
}

string LogicData::compileEndDateFilterStatus(string dateFilterStatus, 
											 date endDateFilter) {
	dateFilterStatus += STRING_SPACE_CHAR + STRING_TO + 
		STRING_SPACE_CHAR + getDisplayDay(ptime(_endDateFilter));
	return dateFilterStatus;
}

string LogicData::compileFilterStatus(string doneFilterStatus,
			string typeFilterStatus, string dateFilterStatus) {
	string filterStatusToReturn;
				
	filterStatusToReturn = STRING_FILTERED_BY + STRING_SPACE_CHAR + 
		doneFilterStatus + STRING_SPACE_CHAR + STRING_FRONTSLASH_CHAR + 
		STRING_SPACE_CHAR + typeFilterStatus + dateFilterStatus;

	return filterStatusToReturn;
}

string LogicData::compileNewActionMessage(State filteredViewState){
	string newActionMessageToReturn;	
	
	newActionMessageToReturn = filteredViewState.getActionMessage() + 
		STRING_SPACE_CHAR + STRING_SPACE_CHAR + STRING_VERTICAL_BAR_CHAR + 
		STRING_VERTICAL_BAR_CHAR + STRING_SPACE_CHAR + STRING_SPACE_CHAR + 
		getFilterStatus();

	return newActionMessageToReturn;
}
	// End of segment: ./\LogicData.cpp





	/**
	 * origin: ./\LogicData.h
	 */

//****************************************************************************
//LogicData is responsible for holding the current State, view State and
//initial State. It also keeps track of the commands that are executed from 
//the time that WhatToDo is executed. This allows for easy redoing and undoing
//from caller methods such as Command::Undo and Command::Redo. Also, LogicData
//supports Command::Filter as well, it is able to support filters such as:
//	1) Status
//		a) Done & Undone
//		b) Done only
//		c) Undone Only
//	2) Task type
//		a) All types
//		b) Fixed Timed
//		c) Deadline
//	3) Date
//
//****************************************************************************

#ifndef LOGICDATA_H
#define LOGICDATA_H

#include <iostream>
#include <fstream>
#include <vector>
#include "State.h"
#include "StorageExecutor.h"

enum Status {
	STATUS_NOT_SET = -1, DONE_BOTH, ONLY_DONE, ONLY_UNDONE
};

enum Type {
	TYPE_NOT_SET = -1, ALL_TYPES, ONLY_FIXED, ONLY_DUE
};

enum Month {
	JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT,
	NOV, DEC
};

class Command;

class LogicData {

	private:
		//Attributes for LogicData
		static State _currentState;
		static State _viewState;
		static State _initialState;
		static vector<Command*> _commandHistory;
		static int _currentCommandHistoryIndex;
		static int _doneFilter;
		static int _typeFilter;
		static date _startDateFilter;
		static date _endDateFilter;

		static char buffer[255];

	public:
		//Constructor
		LogicData();

		//Setters
		static void setCurrentState(State stateToSet);
		static void setViewState(State stateToSet);
		static void setDoneFilter(int doneFilter);
		static void setTypeFilter(int typeFilter);
		static void setDateFilter(date startDateFilter, date endDateFilter);
		static void setCommandHistoryIndex(int indexToSet);

		//Getters
		static State getCurrentState();
		static State getViewState();
		static vector<Command*> getCommandHistory();
		static int getCurrentCommandHistoryIndex();
		static int getDoneFilter();
		static int getTypeFilter();
		static date getStartDateFilter();
		static date getEndDateFilter();

		//Operations
		static void resetCommandHistory();
		static void addCommandToHistory(Command* commandToAdd);
		static void resetToInitialSettings();
		static void loadInitialSettings();
		static void fakeinitiate(State fakestate);
		static State filterTasks();
		static bool passDoneFilter(Task task);
		static bool passTypeFilter(Task task);
		static bool passDateFilter(Task task);
		static string getFilterStatus();
		static string changeMonthToMonthOfYear(int month);
		static string getDisplayDay(ptime myTime);
		static string compileNewActionMessage(State filteredViewState);
		static string compileStartDateFilterStatus(string dateFilterStatus, 
			date startDateFilter);
		static string compileEndDateFilterStatus(string dateFilterStatus, 
			date endDateFilter);
		static string compileFilterStatus(string doneFilterStatus,
			string typeFilterStatus, string dateFilterStatus);
		static string compileNewActionMessage(State filteredViewState);
		static bool doesDeadlinePassDateFilter(Task task);
		static bool doesStartDatePassDateFilter(Task task);
		static bool doesEndDatePassDateFilter(Task task);

		//Constants
		static const int INITIAL_COMMAND_HISTORY_INDEX;

		static const string ABBREV_MONTH_JAN;
		static const string ABBREV_MONTH_FEB;
		static const string ABBREV_MONTH_MAR;
		static const string ABBREV_MONTH_APR;
		static const string ABBREV_MONTH_MAY;
		static const string ABBREV_MONTH_JUN;
		static const string ABBREV_MONTH_JUL;
		static const string ABBREV_MONTH_AUG;
		static const string ABBREV_MONTH_SEP;
		static const string ABBREV_MONTH_OCT;
		static const string ABBREV_MONTH_NOV;
		static const string ABBREV_MONTH_DEC;
		static const string STRING_SPACE_CHAR;
		static const string STRING_FRONTSLASH_CHAR;
		static const string STRING_FROM;
		static const string STRING_TO;
		static const string STRING_FILTERED_BY;
		static const string STRING_COLON;
		static const string STRING_VERTICAL_BAR_CHAR;
		static const string STRING_EMPTY;
		static const string STRING_NO_DONE;
		static const string STRING_DONE;
		static const string STRING_UNDONE;
		static const string STRING_ALL_TYPES;
		static const string STRING_ONLY_FIXED;
		static const string STRING_ONLY_DUE;

		static const string ERR_MSG_INVALID_TASK_TYPE;
		static const string ERR_MSG_INVALID_STATUS_TYPE;
};

#endif
	// End of segment: ./\LogicData.h





	/**
	 * origin: ./\LogicDataUnitTest.cpp
	 */

//****************************************************************************
//testLogicData
//****************************************************************************

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace std;

namespace testLogicDataComponent {		
	TEST_CLASS(TestTask) {
		public:
		
			TEST_METHOD(testInitTask) {
				Task myTask;

				//Check if TaskStartTime is initialized as "NULL"
				Assert::AreEqual(true, myTask.getTaskStartTime().is_not_a_date_time());

				//Check if TaskEndTime is initialized as "NULL"
				Assert::AreEqual(true, myTask.getTaskEndTime().is_not_a_date_time());
			
				//Check if TaskDeadline is initialized as "NULL"
				Assert::AreEqual(true, myTask.getTaskDeadline().is_not_a_date_time());
			}

			TEST_METHOD(testTaskTypeFloating) {
				//Checking for FLOATING tasks
				Task floatTask;
				Assert::AreEqual(int(Task::TaskType::FLOATING), floatTask.getTaskType());
			}

			TEST_METHOD(testTaskTypeDeadlineTime) {
				//Checking for DEADLINE_TIME tasks
				Task deadlineTimeTask;
				deadlineTimeTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				Assert::AreEqual(int(Task::TaskType::DEADLINE_TIME), deadlineTimeTask.getTaskType());
			}

			TEST_METHOD(testTaskTypeDeadlineAllDay) {
				//Checking for DEADLINE_ALLDAY tasks
				Task deadlineAllDayTask;
				deadlineAllDayTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(0,0,1)));
				Assert::AreEqual(int(Task::TaskType::DEADLINE_ALLDAY), deadlineAllDayTask.getTaskType());
			}

			TEST_METHOD(testTaskTypeFixedAllDay) {
				//Checking for FIXED_ALLDAY tasks
				Task fixedAllDayTask;
				fixedAllDayTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(0,0,1)));
				Assert::AreEqual(int(Task::TaskType::FIXED_ALLDAY), fixedAllDayTask.getTaskType());
			}
			
			TEST_METHOD(testTaskTypeFixedDayToDay) {
				//Checking for FIXED_DAY_TO_DAY tasks
				Task fixedDayToDayTask;
				fixedDayToDayTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(0,0,1)));
				fixedDayToDayTask.setTaskEndTime(ptime (date(2014,Dec,15), time_duration(0,0,1)));
				Assert::AreEqual(int(Task::TaskType::FIXED_DAY_TO_DAY), fixedDayToDayTask.getTaskType());
			}

			TEST_METHOD(testTaskTypeFixedDayToTime) {
				//Checking for FIXED_DAY_TO_TIME tasks
				Task fixedDayToTimeTask;
				fixedDayToTimeTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(0,0,1)));
				fixedDayToTimeTask.setTaskEndTime(ptime (date(2014,Dec,15), time_duration(10,30,0)));
				Assert::AreEqual(int(Task::TaskType::FIXED_DAY_TO_TIME), fixedDayToTimeTask.getTaskType());
			}

			TEST_METHOD(testTaskTypeFixedStart) {
				//Checking for FIXED_START tasks
				Task fixedStartTask;
				fixedStartTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,30,1)));
				Assert::AreEqual(int(Task::TaskType::FIXED_START), fixedStartTask.getTaskType());
			}

			TEST_METHOD(testTaskTypeFixedTimeWithinDay) {
				//Checking for FIXED_TIME_WITHIN_DAY tasks
				Task fixedTimeWithinDayTask;
				fixedTimeWithinDayTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				fixedTimeWithinDayTask.setTaskEndTime(ptime (date(2014,Dec,10), time_duration(16,30,0)));
				Assert::AreEqual(int(Task::TaskType::FIXED_TIME_WITHIN_DAY), fixedTimeWithinDayTask.getTaskType());
			}

			TEST_METHOD(testTaskTypeFixedTimeAcrossDay) {
				//Checking for FIXED_TIME_ACROSS_DAY tasks
				Task fixedTimeAcrossDayTask;
				fixedTimeAcrossDayTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				fixedTimeAcrossDayTask.setTaskEndTime(ptime (date(2014,Dec,12), time_duration(16,30,0)));
				Assert::AreEqual(int(Task::TaskType::FIXED_TIME_ACROSS_DAY), fixedTimeAcrossDayTask.getTaskType());
			}
			
			TEST_METHOD(testTaskTypeFixedTimeToDay) {
				//Checking for FIXED_TIME_TO_DAY tasks
				Task fixedTimeToDayTask;
				fixedTimeToDayTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				fixedTimeToDayTask.setTaskEndTime(ptime (date(2014,Dec,12), time_duration(0,0,1)));
				Assert::AreEqual(int(Task::TaskType::FIXED_TIME_TO_DAY), fixedTimeToDayTask.getTaskType());
			}

			TEST_METHOD(testTaskIsEarlier) {
				Task firstTask;
				Task secondTask;

           		//case where first task is earlier than second task (test for 'positive' value segment)
				//   first task          [   
				//   second task             [
				firstTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,11), time_duration(1,2,3)));
				Assert::AreEqual(true, firstTask.isEarlierThan(secondTask));

				//case where first task is later than second task (test for 'negative' value segment)
				//   first task                 [
				//   second task         [
				firstTask.setTaskStartTime(ptime (date(2002,Jan,13), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,11), time_duration(1,2,3)));
				Assert::AreEqual(false, firstTask.isEarlierThan(secondTask));

				//case where first task starts the same as second task (test for 'boundary' value segment)
				//   first task          [
				//   second task         [
				firstTask.setTaskStartTime(ptime (date(2002,Jan,11), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,11), time_duration(1,2,3)));
				Assert::AreEqual(false, firstTask.isEarlierThan(secondTask));
			}

			TEST_METHOD(testTaskIsOverlap) {
				Task firstTask;
				Task secondTask;
       
				//case where start time of second task is between start and end times of first task
				//   first task          [     ] 
				//   second task            [     ]
				firstTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				firstTask.setTaskEndTime(ptime (date(2002, Jan, 12), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,11), time_duration(1,2,3)));
				secondTask.setTaskEndTime(ptime (date(2002, Jan, 13), time_duration(1,2,3)));
				Assert::AreEqual(true, firstTask.isTaskOverlapWith(secondTask));

				//case where end time of second task is between start and end times of first task
				//   first task          [     ]
				//   second task      [     ]
 				firstTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				firstTask.setTaskEndTime(ptime (date(2002, Jan, 12), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,9), time_duration(1,2,3)));
				secondTask.setTaskEndTime(ptime (date(2002, Jan, 11), time_duration(1,2,3)));
				Assert::AreEqual(true, firstTask.isTaskOverlapWith(secondTask));

				//case where start time of second task equals the end time of the first task
				//   first task          [     ]
				//   second task               [     ]
				firstTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				firstTask.setTaskEndTime(ptime (date(2002, Jan, 12), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,12), time_duration(1,2,3)));
				secondTask.setTaskEndTime(ptime (date(2002, Jan, 14), time_duration(1,2,3)));
				Assert::AreEqual(false, firstTask.isTaskOverlapWith(secondTask));

				//case where end time of second task equals the start time of the first task
				//   first task          [     ]
				//   second task   [     ]
				firstTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				firstTask.setTaskEndTime(ptime (date(2002, Jan, 12), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,8), time_duration(1,2,3)));
				secondTask.setTaskEndTime(ptime (date(2002, Jan, 10), time_duration(1,2,3)));
				Assert::AreEqual(false, firstTask.isTaskOverlapWith(secondTask));

				//case where end time of second task equals the end time of the first task
				//    first task         [     ]      
				//    second task           [  ]
				firstTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				firstTask.setTaskEndTime(ptime (date(2002, Jan, 12), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,11), time_duration(1,2,3)));
				secondTask.setTaskEndTime(ptime (date(2002, Jan, 12), time_duration(1,2,3)));
				Assert::AreEqual(true, firstTask.isTaskOverlapWith(secondTask));

 				//case where start time of second task equals the start time of the first task
				//    first task         [     ]      
				//    second task        [  ]
				firstTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				firstTask.setTaskEndTime(ptime (date(2002, Jan, 12), time_duration(1,2,3)));
				secondTask.setTaskStartTime(ptime (date(2002,Jan,10), time_duration(1,2,3)));
				secondTask.setTaskEndTime(ptime (date(2002, Jan, 11), time_duration(1,2,3)));
				Assert::AreEqual(true, firstTask.isTaskOverlapWith(secondTask));
			}

			TEST_METHOD(testTaskIsSortedBefore) {
				//FlOATING VS DEADLINE_TIME
				Task floatTask;

				Task deadlineTimeTask;
				deadlineTimeTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(14,29,0)));

				Assert::AreEqual(true, floatTask.isTaskSortedBefore(floatTask, deadlineTimeTask));

				//DEADLINE_TIME VS FIXED_START , deadline is earlier than start time of fixed task
				Task fixedStartTask;
				fixedStartTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,30,1)));

				Assert::AreEqual(false, fixedStartTask.isTaskSortedBefore(fixedStartTask, deadlineTimeTask));

				//FIXED_START VS FIXED_START - 2nd time starts later
				Task fixedStartTaskTwo;
				fixedStartTaskTwo.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,40,1)));

				Assert::AreEqual(true, fixedStartTask.isTaskSortedBefore(fixedStartTask, fixedStartTaskTwo));

				//FIXED_START VS FIXED_START - same start times
				Task fixedStartTaskThree;
				fixedStartTaskThree.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,40,1)));
				fixedStartTaskTwo.setTaskIndex(1);
				fixedStartTaskThree.setTaskIndex(10);

				Assert::AreEqual(true, fixedStartTaskTwo.getTaskIndex() < fixedStartTaskThree.getTaskIndex());
				Assert::AreEqual(true, fixedStartTaskTwo.isTaskSortedBefore(fixedStartTaskTwo, fixedStartTaskThree));		

				//FIXED_START VS FIXED_TIME_WITHIN_DAY - same start times, one fixed time, other fixed start(Higher precedence)
				Task fixedTimeWithinDayTask;
				fixedTimeWithinDayTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,40,0)));		
				fixedTimeWithinDayTask.setTaskEndTime(ptime (date(2014,Dec,10), time_duration(15,40,0)));	

				Assert::AreEqual(true, fixedStartTaskThree.isTaskSortedBefore(fixedStartTaskThree, fixedTimeWithinDayTask));
			}
	};

	TEST_CLASS(TestState) {
		public:

			TEST_METHOD(testStateAdd) {
				State myState;
				vector<Task> listOfTasks,listOfStateTasks;
				Task temp;

				temp.setTaskName("Go and Fish");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("I will go and run");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and Laugh");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and LOL");
				myState.addTask(temp);
				listOfTasks.push_back(temp);

				listOfStateTasks = myState.getAllTasks();

				for(int i=0; i< int(listOfTasks.size()); i++) {
					Assert::AreEqual(listOfTasks[i].getTaskName(), listOfStateTasks[i].getTaskName());
				}
			}

			TEST_METHOD(testStateDelete) {
				State myState;
				vector<Task> listOfTasks,listOfStateTasks;
				Task temp;

				//Adding Tasks
				temp.setTaskName("Go and Fish");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("I will go and run");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and Laugh");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and LOL");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
			
				//Deleting
				myState.deleteTask(1);
				listOfTasks.erase(listOfTasks.begin() + 1);

				//Checking
				listOfStateTasks = myState.getAllTasks();
				for(int i=0; i<int(listOfTasks.size());i++){
					Assert::AreEqual(listOfTasks[i].getTaskName(),listOfStateTasks[i].getTaskName());
				}

			}

			TEST_METHOD(testStateClear) {
				State myState;
				vector<Task> listOfTasks,listOfStateTasks;
				Task temp;

				//Adding Tasks
				temp.setTaskName("Go and Fish");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("I will go and run");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and Laugh");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and LOL");
				myState.addTask(temp);
				listOfTasks.push_back(temp);

				//Clear Tasks
				myState.clearAllTasks();
				listOfStateTasks = myState.getAllTasks();
            
				//Checking
				Assert::AreEqual(0, int(listOfStateTasks.size()));
			}

			TEST_METHOD(testStateGetFloatingTasks) {
				State myState;
				vector<Task> listOfTasks,listOfStateTasks;
				Task temp;

				//Adding Floating Tasks
				temp.setTaskName("Go and Fish");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("I will go and run");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and Laugh");
				myState.addTask(temp);
				listOfTasks.push_back(temp);
				temp.setTaskName("Go and LOL");
				myState.addTask(temp);
				listOfTasks.push_back(temp);

				//Adding Fixed Task
				Task fixedAllDayTask;
				fixedAllDayTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(0,0,1)));
				myState.addTask(fixedAllDayTask);

				//Adding Deadline Task
				Task deadlineAllDayTask;
				deadlineAllDayTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(0,0,1)));				
				myState.addTask(deadlineAllDayTask);

				//Checking
				listOfStateTasks = myState.getFloatingTasks();
				Assert::AreEqual(int(listOfTasks.size()), int(listOfStateTasks.size()));
				for(int i=0; i<int(listOfTasks.size());i++){
					Assert::AreEqual(listOfTasks[i].getTaskName(),listOfStateTasks[i].getTaskName());
				}
			}
	};

	TEST_CLASS(TestLogicData) {
		public:
			enum Status {
				STATUS_NOT_SET = -1, DONE_BOTH, ONLY_DONE, ONLY_UNDONE
			};

			enum Type {
				TYPE_NOT_SET = -1, ALL_TYPES, ONLY_FIXED, ONLY_DUE
			};

			TEST_METHOD(testInitialisation) {
				LogicData myLogicData;

				Assert::AreEqual(LogicData::INITIAL_COMMAND_HISTORY_INDEX,
					myLogicData.getCurrentCommandHistoryIndex());
				Assert::AreEqual(LogicData::Status::ONLY_UNDONE, 
					myLogicData.getDoneFilter());
				Assert::AreEqual(LogicData::Type::ALL_TYPES,
					myLogicData.getTypeFilter());
				Assert::AreEqual(boost::gregorian::date(neg_infin),
					myLogicData.getStartDateFilter());
				Assert::AreEqual(boost::gregorian::date(pos_infin),
					myLogicData.getEndDateFilter());
			}

			TEST_METHOD(testDoneFilter) {
				LogicData myLogicData;

				myLogicData.setDoneFilter(LogicData::Status::ONLY_DONE);

				State myState;
				Task temp;
				vector<Task> expectedTasks, actualTasks;

				temp.setTaskName("Go and Fish");
				temp.setTaskIsDone();
				myState.addTask(temp);
				expectedTasks.push_back(temp);
				
				temp.setTaskName("I will go and run");
				temp.setTaskIsNotDone();
				myState.addTask(temp);

				temp.setTaskName("Go and Laugh");
				myState.addTask(temp);

				temp.setTaskName("Go and LOL");
				temp.setTaskIsDone();
				myState.addTask(temp);
				expectedTasks.push_back(temp);

				myLogicData.setViewState(myState);
				State myfilteredState;
				myfilteredState = myLogicData.filterTasks();

				actualTasks = myfilteredState.getAllTasks();

				for(int i=0; i< int(expectedTasks.size()); i++) {
					Assert::AreEqual (expectedTasks[i].getTaskName(),
						actualTasks[i].getTaskName());
				}
			}

			TEST_METHOD(testUndoneFilter) {
				LogicData myLogicData;

				myLogicData.setDoneFilter(Status::ONLY_UNDONE);

				State myState;
				Task temp;
				vector<Task> expectedTasks, actualTasks;

				temp.setTaskName("Go and Fish");
				temp.setTaskIsDone();
				myState.addTask(temp);
				
				temp.setTaskName("I will go and run");
				temp.setTaskIsNotDone();
				myState.addTask(temp);
				expectedTasks.push_back(temp);

				temp.setTaskName("Go and Laugh");
				myState.addTask(temp);
				expectedTasks.push_back(temp);

				temp.setTaskName("Go and LOL");
				temp.setTaskIsDone();
				myState.addTask(temp);

				myLogicData.setViewState(myState);
				State myfilteredState;
				myfilteredState = myLogicData.filterTasks();

				actualTasks = myfilteredState.getAllTasks();

				for(int i=0; i< int(expectedTasks.size()); i++) {
					Assert::AreEqual (expectedTasks[i].getTaskName(),
						actualTasks[i].getTaskName());
				}
			}

			TEST_METHOD(testDeadlineFilter) {
				LogicData myLogicData;
				myLogicData.setTypeFilter(Type::ONLY_DUE);

				State myState;
				vector<Task> expectedTasks, actualTasks;
				
				Task deadlineTask;
				deadlineTask.setTaskName("Go and Fish");
				deadlineTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				myState.addTask(deadlineTask);
				expectedTasks.push_back(deadlineTask);

				deadlineTask.setTaskName("I will go and run");
				deadlineTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(16,30,0)));
				myState.addTask(deadlineTask);
				expectedTasks.push_back(deadlineTask);

				Task fixedTask;
				fixedTask.setTaskName("Go and Laugh");
				fixedTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				fixedTask.setTaskEndTime(ptime (date(2014,Dec,12), time_duration(16,30,0)));
				myState.addTask(fixedTask);

				fixedTask.setTaskName("Go and LOL");
				fixedTask.setTaskStartTime(ptime (date(2014,Dec,11), time_duration(14,30,0)));
				fixedTask.setTaskEndTime(ptime (date(2014,Dec,12), time_duration(16,30,0)));
				myState.addTask(fixedTask);

				myLogicData.setViewState(myState);
				State myfilteredState;
				myfilteredState = myLogicData.filterTasks();
				actualTasks = myfilteredState.getAllTasks();

				for(int i=0; i< int(expectedTasks.size()); i++) {
					Assert::AreEqual (expectedTasks[i].getTaskName(),
						actualTasks[i].getTaskName());
				}
			}	

			TEST_METHOD(testFixedFilter) {
				LogicData myLogicData;

				myLogicData.setTypeFilter(Type::ONLY_FIXED);

				State myState;
				vector<Task> expectedTasks, actualTasks;
				
				Task deadlineTask;
				deadlineTask.setTaskName("Go and Fish");
				deadlineTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				myState.addTask(deadlineTask);

				deadlineTask.setTaskName("I will go and run");
				deadlineTask.setTaskDeadline(ptime (date(2014,Dec,10), time_duration(16,30,0)));
				myState.addTask(deadlineTask);

				Task fixedTask;
				fixedTask.setTaskName("Go and Laugh");
				fixedTask.setTaskStartTime(ptime (date(2014,Dec,10), time_duration(14,30,0)));
				fixedTask.setTaskEndTime(ptime (date(2014,Dec,12), time_duration(16,30,0)));
				myState.addTask(fixedTask);
				expectedTasks.push_back(fixedTask);

				fixedTask.setTaskName("Go and LOL");
				fixedTask.setTaskStartTime(ptime (date(2014,Dec,11), time_duration(14,30,0)));
				fixedTask.setTaskEndTime(ptime (date(2014,Dec,12), time_duration(16,30,0)));
				myState.addTask(fixedTask);
				expectedTasks.push_back(fixedTask);

				myLogicData.setViewState(myState);
				State myfilteredState;
				myfilteredState = myLogicData.filterTasks();
				actualTasks = myfilteredState.getAllTasks();

				for(int i=0; i< int(expectedTasks.size()); i++) {
					Assert::AreEqual (expectedTasks[i].getTaskName(),
						actualTasks[i].getTaskName());
				}
			}	
	};
}
	// End of segment: ./\LogicDataUnitTest.cpp





	/**
	 * origin: ./\State.cpp
	 */

#include "State.h"

//Constructor
State::State(){
	maxIndex = 0;
	_loggingModeOn = true;
}

//Setters
void State::setAllTasks(vector<Task> tasksToSet) {
	_entireListOfTasks = tasksToSet;
}

void State::setUserMessage(string stringToSet) {
	_userMessage = stringToSet;
}

void State::setActionMessage(string stringToSet) {
	_actionMessage = stringToSet;
}

void State::setLastActionType(int actionTypeToSet) {
	_lastActionType = actionTypeToSet;
	return;
}

void State::setLastActionTaskIndex(int actionTaskIndexToSet) {
	_lastActionTaskIndex = actionTaskIndexToSet;
	return;
}

//Getters
string State::getUserMessage() {
	return _userMessage;
}

string State::getActionMessage() {
	return _actionMessage;
}

int State::getLastActionType() {
	return _lastActionType;
}

int State::getLastActionTaskIndex() {
	return _lastActionTaskIndex;
}

//Operations
void State::addTask(Task taskToAdd, bool isUserCommand, int specifiedIndex) {
	log(LOG_MSG_ADD_TASK);

	if (specifiedIndex == UNSPECIFIED_INDEX) {
		taskToAdd.setTaskIndex(maxIndex);
		if (isUserCommand) {
			_lastActionType = actionType::CHANGED;
			_lastActionTaskIndex = maxIndex;
		} else {
			_lastActionType = actionType::NONE;
		}
		maxIndex++;
		_entireListOfTasks.push_back(taskToAdd);
	} else {
		taskToAdd.setTaskIndex(specifiedIndex);
		if (isUserCommand) {
			_lastActionType = actionType::CHANGED;
			_lastActionTaskIndex = specifiedIndex;
		} else {
			_lastActionType = actionType::NONE;
		}
		_entireListOfTasks.push_back(taskToAdd);
	}
}

void State::deleteTask(int taskIndexToDelete, bool isUserCommand) {
	log(LOG_MSG_DELETE_TASK);

	for (unsigned int index = INITIAL_INDEX; 
		index < _entireListOfTasks.size(); index++) {
		if (_entireListOfTasks[index].getTaskIndex() == taskIndexToDelete) {
			if (isUserCommand) {
				_lastActionType = actionType::DELETED;
				_lastActionTaskIndex = taskIndexToDelete;
			} else {
				_lastActionType = actionType::NONE;
			}
			_entireListOfTasks.erase(_entireListOfTasks.begin() + index);
		}
	}
}

void State::doneTask(int taskIndexToDo, bool isUserCommand) {
	log(LOG_MSG_DONE_TASK);

	for(unsigned int index = INITIAL_INDEX; 
		index < _entireListOfTasks.size(); index++) {
		if(_entireListOfTasks[index].getTaskIndex() == taskIndexToDo) {
			_entireListOfTasks[index].setTaskIsDone(isUserCommand);
			_lastActionType = actionType::CHANGED;
			_lastActionTaskIndex = taskIndexToDo;
		}
	}
}

void State::clearAllTasks() {
	log(LOG_MSG_CLEAR_TASKS);
	_entireListOfTasks.clear();
}

void State::sortAllTasks() {
	log(LOG_MSG_SORT_TASKS);

	int primaryIndex, secondaryIndex;
	Task swapTask;

	//Selection Sort Algorithm
	for (primaryIndex = INITIAL_INDEX; 
		unsigned(primaryIndex) < _entireListOfTasks.size(); 
		primaryIndex++) {
			for (secondaryIndex = primaryIndex + TO_THE_RIGHT_BY_ONE; 
				unsigned(secondaryIndex) < _entireListOfTasks.size(); 
				secondaryIndex++) {
			if (!swapTask.isTaskSortedBefore(_entireListOfTasks[primaryIndex], 
				_entireListOfTasks[secondaryIndex])) {
				swapTask = _entireListOfTasks[secondaryIndex];
				_entireListOfTasks[secondaryIndex] = _entireListOfTasks[primaryIndex];
				_entireListOfTasks[primaryIndex] = swapTask;
			}
		}
	}
}

vector<Task> State::getAllTasks() {
	sortAllTasks();
	return _entireListOfTasks;
}

vector<Task> State::getTimedTasks() {
	vector<Task> timedTasks;
	sortAllTasks();

	for (unsigned int index = INITIAL_INDEX; 
		index < _entireListOfTasks.size(); index++) {
			if (isTimedTask(_entireListOfTasks[index])) {
			timedTasks.push_back(_entireListOfTasks[index]);
		}
	}
	return timedTasks;
}

vector<Task> State::getDeadlineTasks() {
	vector<Task> deadlineTasks;
	sortAllTasks();

	for (unsigned int index = INITIAL_INDEX; 
		index < _entireListOfTasks.size(); index++) {
			if (isDeadlineTask(_entireListOfTasks[index])) {
			deadlineTasks.push_back(_entireListOfTasks[index]);
		}
	}
	return deadlineTasks;
}

vector<Task> State::getFloatingTasks() {
	vector<Task> floatingTasks;
	sortAllTasks();

	for (unsigned int index = INITIAL_INDEX; 
		index < _entireListOfTasks.size(); index++) {
			if (isFloatingTask(_entireListOfTasks[index])) {
			floatingTasks.push_back(_entireListOfTasks[index]);
		}
	}
	return floatingTasks;
}

bool State::isTimedTask(Task taskToCheck) {
	return (taskToCheck.getTaskType() == Task::FIXED_ALLDAY) || 
			(taskToCheck.getTaskType() == Task::FIXED_START) || 
			(taskToCheck.getTaskType() == Task::FIXED_TIME_WITHIN_DAY) ||
			(taskToCheck.getTaskType() == Task::FIXED_TIME_ACROSS_DAY) ||
			(taskToCheck.getTaskType() == Task::FIXED_TIME_TO_DAY) ||
			(taskToCheck.getTaskType() == Task::FIXED_DAY_TO_TIME) ||
			(taskToCheck.getTaskType() == Task::FIXED_DAY_TO_DAY);
}

bool State::isDeadlineTask(Task taskToCheck) {
	return taskToCheck.getTaskType() == Task::DEADLINE_TIME || 
			taskToCheck.getTaskType() == Task::DEADLINE_ALLDAY;
}

bool State::isFloatingTask(Task taskToCheck) {
	return taskToCheck.getTaskType() == Task::FLOATING;
}

//Logging
void State::log(string stringToLog) {
	if (!isLoggingModeOn()) {
		return;
	}

	ofstream writeToLog;
	writeToLog.open(_logFileName, ios::app);
	writeToLog << stringToLog;
	writeToLog.close();

	return;
}

bool State::isLoggingModeOn() {
	return _loggingModeOn;
}

void State::setLoggingModeOff() {
	_loggingModeOn = false;
}

void State::setLoggingModeOn() {
	_loggingModeOn = true;
}
	// End of segment: ./\State.cpp





	/**
	 * origin: ./\State.h
	 */

//****************************************************************************
//State is responsible for storing a list of Tasks. State primarily deals with
//the adding, deleting of Tasks. Also, when a Task is completed,
//State is able to set the Task as done. Other than this, State can return
//the caller a sorted list of specified Tasks based on these specifications:
//	1) Timed - Contain information such as StartDate or EndDate, but does not
//     have a deadline
//	2) Deadline - Specifically has a deadline
//	3) Floating - No StartDate and deadline
//
//Upon the execution of any function, State keeps track of its latest action
//type:
//	1) NONE - meaning that no changes were made
//  2) CHANGED - meaning that the State has changed with the addition of a new
//			task or a task is marked as done
//	3) DELETED - meaning that a Task has been deleted from State
//
//This information can be extracted from caller components such as LogicData
//through its getter functions
//****************************************************************************

#ifndef STATE_H
#define STATE_H

#include "Task.h"
#include <fstream>
using namespace std;

//Constants
const int UNSPECIFIED_INDEX = -1;
const int INITIAL_INDEX = 0;
const int TO_THE_RIGHT_BY_ONE = 1;
const bool UNSPECIFIED_USER_COMMAND = false;

const string LOG_STATE_FILE_NAME = "StateLog.txt";
const string LOG_MSG_ADD_TASK = "Function called: addTask()\n";
const string LOG_MSG_DELETE_TASK = "Function called: deleteTask()\n";
const string LOG_MSG_DONE_TASK = "Function called: doneTask()\n";
const string LOG_MSG_CLEAR_TASKS = "Function called: clearAllTasks()\n";
const string LOG_MSG_SORT_TASKS = "Function called: sortAllTasks()\n";

class State {
	private:
		//Attributes for State
		vector<Task> _entireListOfTasks;
		string _userMessage;
		string _actionMessage;
		int maxIndex;
		int _lastActionType;
		int _lastActionTaskIndex;

		//Attributes for Logging
		string _logFileName;
		bool _loggingModeOn;
		char buffer[255];

	public:
		//Constructor
		State();

		//Setters
		void setAllTasks(vector<Task> tasksToSet);
		void setUserMessage(string stringToSet);
		void setActionMessage(string stringToSet);
		void setLastActionType(int actionTypeToSet);
		void setLastActionTaskIndex(int actionTaskIndexToSet);
		
		//Getters
		string getUserMessage();
		string getActionMessage();
		int getLastActionType();
		int getLastActionTaskIndex();

		//Operations
		void addTask(Task taskToAdd, bool isUserCommand = UNSPECIFIED_USER_COMMAND, 
			int specifiedIndex = UNSPECIFIED_INDEX);
		void deleteTask(int taskIndexToDelete, 
			bool isUserCommand = UNSPECIFIED_USER_COMMAND);
		void doneTask(int taskIndexToDo, 
			bool isUserCommand = UNSPECIFIED_USER_COMMAND);
		void clearAllTasks();
		void sortAllTasks();
		vector<Task> getAllTasks();
		vector<Task> getTimedTasks();
		vector<Task> getDeadlineTasks();
		vector<Task> getFloatingTasks();
		bool isTimedTask(Task taskToCheck);
		bool isDeadlineTask(Task taskToCheck);
		bool isFloatingTask(Task taskToCheck);

		//Logging
		void log(string stringToLog);
		bool isLoggingModeOn();
		void setLoggingModeOff();
		void setLoggingModeOn();

		//Enumeration
		enum actionType { NONE = 1, CHANGED, DELETED };
};

#endif
	// End of segment: ./\State.h





	/**
	 * origin: ./\Task.cpp
	 */

#include "Task.h"

//Constructor
Task::Task() {
	_taskStartDateTime = not_a_date_time;
	_taskEndDateTime = not_a_date_time;
	_taskDeadline = not_a_date_time;
	_isDone = false;
	_loggingModeOn = true;
	log(LOG_MSG_INITIATE);
}

//Setters
void Task::setTaskStartTime(ptime dateTimeToSet) {
	_taskStartDateTime = dateTimeToSet;
}

void Task::setTaskEndTime(ptime dateTimeToSet) {
	_taskEndDateTime = dateTimeToSet;
}

void Task::setTaskDeadline(ptime dateTimeToSet) {
	_taskDeadline = dateTimeToSet;
}

void Task::setTaskName(string nameToSet) {
	_taskName = nameToSet;
}

void Task::setTaskDetails(string detailsToSet) {
	_taskDetails = detailsToSet;
}

void Task::setTaskTags(vector<string> tagsToSet) {
	_taskTags = tagsToSet;
}

void Task::setTaskIndex(int indexToSet) {
	_taskIndex = indexToSet;
}

void Task::setTaskIsDone(bool doneStatusToSet) {
	log(LOG_MSG_TASK_DONE);
	_isDone = doneStatusToSet; 
}

void Task::setTaskIsNotDone() {
	_isDone = false;
}

//Getters
int Task::getTaskType() {
	try {
		if ((!hasStartDateTime()) && (!hasDeadline())) {
			return FLOATING;
		} else if (hasDeadline()) {
			if (isFullDay(_taskDeadline)) {
				return DEADLINE_ALLDAY;
			} else {
				return DEADLINE_TIME;
			}
		} else if (hasStartDateTime()) {
			if (hasEndDateTime()) {
				if(isStartDateEqualEndDate()) {
					return FIXED_TIME_WITHIN_DAY;
				} else if (isFullDay(_taskStartDateTime)) {
					if(isFullDay(_taskEndDateTime)) {
						return FIXED_DAY_TO_DAY;
					} else {
						return FIXED_DAY_TO_TIME;
					}
				} else if(isFullDay(_taskEndDateTime)) {
					return FIXED_TIME_TO_DAY;
				} else {
					return FIXED_TIME_ACROSS_DAY;
				}
			} else if (isFullDay(_taskStartDateTime)) {
				return FIXED_ALLDAY;
			} else {
				return FIXED_START;
			}
		} else {
			throw invalid_argument(ERR_MSG_INVALID_TASK_TYPE);
		}
	} catch (const invalid_argument& ia) {
		log(ia.what());
		return NOT_A_TASK_TYPE;
	}
}

int Task::getTaskIndex() {
	return _taskIndex;
}

ptime Task::getTaskStartTime() {
	return _taskStartDateTime;
}

ptime Task::getTaskEndTime() {
	return _taskEndDateTime;
}

ptime Task::getTaskDeadline() {
	return _taskDeadline;
}

time_duration Task::getTaskDuration() {
	time_duration taskDurationToReturn;
	taskDurationToReturn = _taskEndDateTime - _taskStartDateTime;
	return taskDurationToReturn;
}

string Task::getTaskName() {
	return _taskName;
}

string Task::getTaskDetails() {
	return _taskDetails;
}

vector<string> Task::getTaskTags() {
	return _taskTags;
}

bool Task::getTaskIsDone() {
	return _isDone;
}

//Primary Operations
bool Task::hasStartDateTime() {
	return !(_taskStartDateTime == not_a_date_time);
}

bool Task::hasEndDateTime() {
	return !(_taskEndDateTime == not_a_date_time);
}

bool Task::hasDeadline() {
	return !(_taskDeadline == not_a_date_time);
}

bool Task::isFullDay(ptime dateTimeToCheck) {
	return dateTimeToCheck.time_of_day().hours() == EMPTY &&
		dateTimeToCheck.time_of_day().minutes() == EMPTY && 
		dateTimeToCheck.time_of_day().seconds() == MARKED_AS_FULL_DAY;
}

bool Task::isStartDateEqualEndDate() {
	return _taskStartDateTime.date() == _taskEndDateTime.date();
}

bool Task::isTaskTypeFixedDay(Task myTask) {
	int myTaskType = myTask.getTaskType();
	return myTaskType == FIXED_ALLDAY || 
		myTaskType == FIXED_DAY_TO_DAY || 
		myTaskType == FIXED_DAY_TO_TIME;
}

bool Task::isTaskTypeFixedTime(Task myTask) {
	int myTaskType = myTask.getTaskType();
	return myTaskType == FIXED_TIME_WITHIN_DAY || 
		myTaskType == FIXED_TIME_ACROSS_DAY ||
		myTaskType == FIXED_TIME_TO_DAY;
}

bool Task::isTaskHasStartAndEnd() {
	return ((this->getTaskType() == FIXED_DAY_TO_DAY) || (this->getTaskType() == FIXED_TIME_WITHIN_DAY) || (this->getTaskType() == FIXED_TIME_ACROSS_DAY) || (this->getTaskType() == FIXED_DAY_TO_TIME) || (this->getTaskType() == FIXED_TIME_TO_DAY));
}

bool Task::isTaskOverlapWith(Task myTask) {
	log(LOG_MSG_TASK_OVERLAP);

	bool isOverlap = false;
	assert(myTask.getTaskType() != FLOATING && this->getTaskType() != FLOATING);

	if(isFullDay(myTask.getTaskStartTime()) || 
		isFullDay(myTask.getTaskEndTime()) || 
		isFullDay(_taskStartDateTime) || 
		isFullDay(_taskEndDateTime)){
		   return isOverlap;
	}

	assert(( myTask.getTaskType() == FIXED_TIME_WITHIN_DAY || 
		myTask.getTaskType() == FIXED_TIME_ACROSS_DAY) &&
		(this->getTaskType() == FIXED_TIME_WITHIN_DAY ||
		this->getTaskType() == FIXED_TIME_ACROSS_DAY));
	if(_taskStartDateTime < myTask.getTaskStartTime() && 
		_taskEndDateTime > myTask.getTaskStartTime()){
		isOverlap = true;
	}else if(_taskStartDateTime< myTask.getTaskEndTime() && 
		_taskEndDateTime > myTask.getTaskEndTime()){
		isOverlap = true;
	}else if(_taskStartDateTime == myTask.getTaskStartTime() || 
		_taskEndDateTime == myTask.getTaskEndTime()){
		isOverlap = true;
    }
	return isOverlap;
}

bool Task::isEarlierThan(Task myTask) {
	bool isEarlier = false;
	assert(myTask.getTaskType() != FLOATING && this->getTaskType() != FLOATING);
	if(_taskStartDateTime < myTask.getTaskStartTime()){
		isEarlier = true;
	}
	return isEarlier;
}

//This function will determine if the firstTask is sorted before the secondTask through a series
//of comparison functions that are arranged in order of precedence (Refer to enum::compareType for
//more information on the ordering sequence) Hence should the order be determined at any point, 
//the loop terminates from within and the boolean variable will be returned to the caller
bool Task::isTaskSortedBefore(Task firstTask, Task secondTask) {
	log(LOG_MSG_TASK_SORTED_BEFORE);

	bool orderConfirmed = false;
	bool isEarlier;
	int functionToCall = COMPARE_FLOAT;
	try{
		while(!orderConfirmed && functionToCall <= NUM_OF_COMP_FUNCTIONS) {
			isEarlier = compare(firstTask, secondTask, &orderConfirmed, functionToCall);
			functionToCall++;
		}
		return isEarlier;
	} catch(const invalid_argument& ia){
		cerr << ia.what();
	}
	return isEarlier;
}

bool Task::compare(Task firstTask, Task secondTask, bool *orderConfirmed, int functionToCall) {
	log(LOG_MSG_COMPARE);	
	
	switch(functionToCall){
		case COMPARE_FLOAT: {
			return compareByFloat(firstTask, secondTask, orderConfirmed);
		}
		case COMPARE_DATE: {
			return compareByDate(firstTask, secondTask, orderConfirmed);
		}
		case COMPARE_DEADLINE_ALLDAY: {
			return compareByDeadlineAllDay(firstTask, secondTask, orderConfirmed);
		}
		case COMPARE_DEADLINE_TIME: {
			return compareByDeadlineTime(firstTask, secondTask, orderConfirmed);
		}
		case COMPARE_FIXED_DAY: {
			return compareByFixedDay(firstTask, secondTask, orderConfirmed);
		}
		case COMPARE_FIXED_START: {
			return compareByFixedStart(firstTask, secondTask, orderConfirmed);
		}
		case COMPARE_FIXED_TIME: {
			return compareByFixedTime(firstTask, secondTask, orderConfirmed);
		}
		case COMPARE_FIXED_TIME_START: {
			return compareByFixedTimeAndStart(firstTask, secondTask, orderConfirmed);
		}
		default: {
			throw invalid_argument(MSG_ERR_INVALID_FUNCTION_CALL);
		}
	}
}

//Secondary Operations
bool Task::compareByFloat(Task firstTask, Task secondTask, bool *orderConfirmed) {
	if ((firstTask.getTaskType() == FLOATING) && (secondTask.getTaskType() == FLOATING)) {
		*orderConfirmed = true;
		return firstTask.getTaskIndex() < secondTask.getTaskIndex();
	} else if (firstTask.getTaskType() == FLOATING) {
		*orderConfirmed = true;
		return true;
	} else if (secondTask.getTaskType() == FLOATING) {
		*orderConfirmed = true;
		return false;
	}
	return false;
}

bool Task::compareByDate(Task firstTask, Task secondTask, bool *orderConfirmed) {
	ptime firstTaskTime;
	ptime secondTaskTime;
	
	if (firstTask.getTaskDeadline() != not_a_date_time) {
		firstTaskTime = firstTask.getTaskDeadline();
	} else {
		firstTaskTime = firstTask.getTaskStartTime();
	}

	if (secondTask.getTaskDeadline() != not_a_date_time) {
		secondTaskTime = secondTask.getTaskDeadline();
	} else {
		secondTaskTime = secondTask.getTaskStartTime();
	}

	if (firstTaskTime.date() < secondTaskTime.date()) {
		*orderConfirmed = true;
		return true;
	} else if (firstTaskTime.date() > secondTaskTime.date()) {
		*orderConfirmed = true;
		return false;
	}
    return false;
}

bool Task::compareByDeadlineAllDay(Task firstTask, Task secondTask, bool *orderConfirmed) {
	if ((firstTask.getTaskType() == DEADLINE_ALLDAY) && (secondTask.getTaskType() == DEADLINE_ALLDAY)) {
		*orderConfirmed = true;
		return firstTask.getTaskIndex() < secondTask.getTaskIndex();
	} else if (firstTask.getTaskType() == DEADLINE_ALLDAY) {
		*orderConfirmed = true;
		return true;
	} else if (secondTask.getTaskType() == DEADLINE_ALLDAY) {
		*orderConfirmed = true;
		return false;
	}
	return false;
}

bool Task::compareByDeadlineTime(Task firstTask, Task secondTask, bool *orderConfirmed) {
	ptime firstTaskTime;
	ptime secondTaskTime;
	
	if ((firstTask.getTaskType() == DEADLINE_TIME) && (secondTask.getTaskType() == DEADLINE_TIME)) {
		*orderConfirmed = true;
		if(firstTask.getTaskDeadline() < secondTask.getTaskDeadline()) {
			return true;
		} else if (firstTask.getTaskDeadline() > secondTask.getTaskDeadline()) {
			return false;
		} else {
			return firstTask.getTaskIndex() < secondTask.getTaskIndex();
		}
	} else if (firstTask.getTaskType() == DEADLINE_TIME) {
		*orderConfirmed = true;
		return true;
	} else if (secondTask.getTaskType() == DEADLINE_TIME) {
		*orderConfirmed = true;
		return false;
	}
	return false;
}

bool Task::compareByFixedDay(Task firstTask, Task secondTask, bool *orderConfirmed) {
	if (isTaskTypeFixedDay(firstTask) && isTaskTypeFixedDay(secondTask)) {
		*orderConfirmed = true;

		if (firstTask.getTaskType() == FIXED_ALLDAY) {
			if (secondTask.getTaskType() == FIXED_ALLDAY) {
				return firstTask.getTaskIndex() < secondTask.getTaskIndex();
			} else {
				return true;
			}
		} else if (secondTask.getTaskType() == FIXED_ALLDAY) {
			return false;
		} else if (firstTask.getTaskType() == FIXED_DAY_TO_DAY) {
			if(secondTask.getTaskType() == FIXED_DAY_TO_DAY) {
				if(firstTask.getTaskEndTime().date() < 
					secondTask.getTaskEndTime().date()){
					return true;
				} else if(firstTask.getTaskEndTime().date() > 
					secondTask.getTaskEndTime().date()) {
					return false;
				} else {
					return firstTask.getTaskIndex() < secondTask.getTaskIndex();
			    }
			} else {
				assert(secondTask.getTaskType() == FIXED_DAY_TO_TIME);
				return true;
			}
		} else {
			assert(firstTask.getTaskType() == FIXED_DAY_TO_TIME);
			if(secondTask.getTaskType() != FIXED_DAY_TO_TIME) {
				return false;
			} else {
				assert(secondTask.getTaskType() == FIXED_DAY_TO_TIME);
				if(firstTask.getTaskEndTime() < secondTask.getTaskEndTime()) {
					return true;
				} else if (firstTask.getTaskEndTime() > secondTask.getTaskEndTime()) {
					return false;
				} else {
					return firstTask.getTaskIndex() < secondTask.getTaskIndex();
				}
			}
		}
	} else if (isTaskTypeFixedDay(firstTask)) {
		*orderConfirmed = true;
		return true;
	} else if (isTaskTypeFixedDay(secondTask)) {
		*orderConfirmed = true;
		return false;
	}
	return false;
}

bool Task::compareByFixedStart(Task firstTask, Task secondTask, bool *orderConfirmed) {
	if ((firstTask.getTaskType() == FIXED_START) && 
		(secondTask.getTaskType() == FIXED_START)) {
		*orderConfirmed = true;
		if (firstTask.getTaskStartTime() < secondTask.getTaskStartTime()) {
			return true;
		} else if (firstTask.getTaskStartTime() > secondTask.getTaskStartTime()) {
			return false;
		} else {
			return firstTask.getTaskIndex() < secondTask.getTaskIndex();
		}
	}
	return false;
}

bool Task::compareByFixedTime(Task firstTask, Task secondTask, bool *orderConfirmed) {
	if (isTaskTypeFixedTime(firstTask) && isTaskTypeFixedTime(secondTask)) {
		*orderConfirmed = true;
		if (firstTask.getTaskStartTime() < secondTask.getTaskStartTime()) {
			return true;
		} else if (firstTask.getTaskStartTime() > secondTask.getTaskStartTime()) {
			return false;
		}
			
		if (firstTask.getTaskEndTime() == secondTask.getTaskEndTime()) {
			return firstTask.getTaskIndex() < secondTask.getTaskIndex();
		} else {
			return firstTask.getTaskEndTime() < secondTask.getTaskEndTime();
		}
	}
	return false;
}

bool Task::compareByFixedTimeAndStart(Task firstTask, Task secondTask, bool *orderConfirmed) {
    ptime firstTaskTime;
	ptime secondTaskTime;
	
	if ((isTaskTypeFixedTime(firstTask)) && (secondTask.getTaskType() == FIXED_START)) {
		//This step is to prevent the 1s marker in a FIXED_START task to be considered as
		//later than a FIXED_TIME task that has the same time in terms of just HHMM
		firstTaskTime = ptime(firstTask.getTaskStartTime().date(), 
			hours(firstTask.getTaskStartTime().time_of_day().hours()) + 
			minutes(firstTask.getTaskStartTime().time_of_day().minutes()));
		secondTaskTime = ptime(secondTask.getTaskStartTime().date(), 
			hours(secondTask.getTaskStartTime().time_of_day().hours()) + 
			minutes(secondTask.getTaskStartTime().time_of_day().minutes()));
		*orderConfirmed = true;

		if (firstTaskTime != secondTaskTime) {
			return firstTaskTime < secondTaskTime;
		} else {
			return false;
		}
	} else if ((firstTask.getTaskType() == FIXED_START) && (isTaskTypeFixedTime(secondTask))) {
		//This step is to prevent the 1s marker in a FIXED_START task to be considered as
		//later than a FIXED_TIME task that has the same time in terms of just HHMM
		firstTaskTime = ptime(firstTask.getTaskStartTime().date(), 
			hours(firstTask.getTaskStartTime().time_of_day().hours()) + 
			minutes(firstTask.getTaskStartTime().time_of_day().minutes()));
		secondTaskTime = ptime(secondTask.getTaskStartTime().date(), 
			hours(secondTask.getTaskStartTime().time_of_day().hours()) + 
			minutes(secondTask.getTaskStartTime().time_of_day().minutes()));
		*orderConfirmed = true;

		if (firstTaskTime != secondTaskTime) {
			return firstTaskTime < secondTaskTime;
		} else {
			return true;
		}
	}
	return false;
}

bool Task::isLoggingModeOn() {
	return _loggingModeOn;
}

void Task::setLoggingModeOff() {
	_loggingModeOn = false;
}

void Task::setLoggingModeOn() {
	_loggingModeOn = true;
}
	// End of segment: ./\Task.cpp





	/**
	 * origin: ./\Task.h
	 */

//****************************************************************************
//Task is the most fundamental component within WhatToDo and is responsible 
//for storing important details of a task such as its start time, end time, 
//deadline, name, tags and status (done or not done). In additional, a Task 
//has two additional functions  firstly it is able to check if two Tasks 
//overlap, and secondly it is able to check if a Task begins earlier than 
//another Task. A Task also can be defined in many types:
//	1)Floating Tasks - no start date time, no end date time and no deadline
//  2)Deadline Tasks
//		a) All Day - Meaning that the entire day is demarketed as the deadline
//		b) Time - Meaning that the deadline has a specific time
//	3)Fixed Tasks
//		a) Day
//			i) All Day - Meaning that one entire day is demarketed for the Task
//		   ii) Day To Time - Meaning that the start date is specified wih no 
//				time and the end date time is specified
//		  iii) Day To Day - Meaning that the start and end dates are both 
//				specified with no times specified	
//		b) Start - Meaning that the start time is specified without any end
//			datetime
//		c) Time 
//			i) Time Within Day - Meaning that the start time and end time are
//				specified within a single day
//		   ii) Time Across Day - Meaning that the start time and end time are
//				specified over one day
//		  iii) Time To Day - Meaning that the start time is specified and the
//				end date is specified with no time
//
//*Note: datetimes which occupy an entire day are marked with 1 second 
//		(000001 in HHMMSS)
//
//Logging is used to tracked changes within the internal workings of a Task
//However, it can be toggled on and off by the developer on an optional basis.
//This is because logging for a large number of Tasks may slow down the 
//computational processes within WhatToDo. This can be easily changed by
//setting _loggingModeOn to either true or false in the constructor.
//****************************************************************************

#ifndef TASK_H
#define TASK_H

#include <iostream>
#include <vector>
#include <string>
#include <exception>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/date_time/gregorian_calendar.hpp>

using namespace std;
using namespace boost::posix_time;
using namespace boost::gregorian;

//constants
const int NUM_OF_COMP_FUNCTIONS = 8;
const int MARKED_AS_FULL_DAY = 1;
const int EMPTY = 0;
const string ERR_MSG_INVALID_FUNCTION_CALL = "ERROR: Function called does not exist\n";
const string ERR_MSG_INVALID_TASK_TYPE = "ERROR: Task Type does not exist\n";
const string LOG_TASK_FILE_NAME = "Task.txt";
const string LOG_MSG_INITIATE = "Constructor called: Task()\n";
const string LOG_MSG_COMPARE = "Function called: compare()\n";
const string LOG_MSG_TASK_SORTED_BEFORE = "Function called: isTaskSortedBefore()\n";
const string LOG_MSG_TASK_OVERLAP = "Function called: isTaskOverlapWith()\n";
const string LOG_MSG_TASK_DONE = "Function called: setTaskIsDone()\n";

class Task {
	private:
		//Attributes for Task
		ptime _taskStartDateTime;
		ptime _taskEndDateTime;
		ptime _taskDeadline;
		string _taskName;
		vector<string> _taskTags;
		int _taskIndex;
		bool _isDone;

		//Attributes for Logging
		string _logFileName;
		bool _loggingModeOn;
		char buffer[255];

	public:
		//Constructor
		Task();

		//Setters
		void setTaskStartTime(ptime dateTimeToSet);
		void setTaskEndTime(ptime dateTimeToSet);
		void setTaskDeadline(ptime dateTimeToSet);
		void setTaskName(string nameToSet);
		void setTaskTags(vector<string> tagsToSet);
		void setTaskIndex(int indexToSet);
		void setTaskIsDone(bool doneStatusToSet = true);
		void setTaskIsNotDone();

		//Getters
		int getTaskType();
		int getTaskIndex();
		ptime getTaskStartTime();
		ptime getTaskEndTime();
		ptime getTaskDeadline();
		time_duration getTaskDuration();
		string getTaskName();
		vector<string> getTaskTags();
		bool getTaskIsDone();
		
		//Primary Operations
		bool hasStartDateTime();
		bool hasEndDateTime();
		bool hasDeadline();
		bool isFullDay(ptime dateTimeToCheck);
		bool isStartDateEqualEndDate();
		bool isTaskTypeFixedDay(Task myTask);
		bool isTaskTypeFixedTime(Task myTask);
		bool isTaskHasStartAndEnd();
		bool isTaskOverlapWith(Task myTask);
		bool isEarlierThan(Task myTask);
		bool isTaskSortedBefore(Task firstTask, Task secondTask);
		bool compare(Task firstTask, Task secondTask, bool *orderConfirmed, int functionToCall);

		//Secondary Operations
		bool compareByFloat(Task firstTask, Task secondTask, bool *orderConfirmed);
		bool compareByDate(Task firstTask, Task secondTask, bool *orderConfirmed);
		bool compareByDeadlineAllDay(Task firstTask, Task secondTask, bool *orderConfirmed);
		bool compareByDeadlineTime(Task firstTask, Task secondTask, bool *orderConfirmed);
		bool compareByFixedDay(Task firstTask, Task secondTask, bool *orderConfirmed);
		bool compareByFixedStart(Task firstTask, Task secondTask, bool *orderConfirmed);
		bool compareByFixedTime(Task firstTask, Task secondTask, bool *orderConfirmed);
		bool compareByFixedTimeAndStart(Task firstTask, Task secondTask, bool *orderConfirmed);

		//Logging
		void log(string stringToLog);
		bool isLoggingModeOn();
		void setLoggingModeOff();
		void setLoggingModeOn();

		//Enumeration
		enum TaskType {
			 FLOATING = 1, DEADLINE_TIME, DEADLINE_ALLDAY, FIXED_ALLDAY, FIXED_DAY_TO_DAY, 
			 FIXED_DAY_TO_TIME, FIXED_START, FIXED_TIME_WITHIN_DAY, FIXED_TIME_ACROSS_DAY, 
			 FIXED_TIME_TO_DAY, NOT_A_TASK_TYPE 
		};

		//Compare Functions are arranged in order of precedence from greatest priority starting from 1.
		enum CompareType {
			COMPARE_FLOAT = 1, COMPARE_DATE, COMPARE_DEADLINE_ALLDAY, COMPARE_DEADLINE_TIME,
			COMPARE_FIXED_DAY, COMPARE_FIXED_START, COMPARE_FIXED_TIME, COMPARE_FIXED_TIME_START
		};
};

#endif
	// End of segment: ./\Task.h





