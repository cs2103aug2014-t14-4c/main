//@author: a0110655n



	/**
	 * origin: ./\LogicParser.cpp
	 */

#include "LogicParser.h"

LogicParser::LogicParser(void) {
}

LogicParser::~LogicParser(void) {
}

Command* LogicParser::getCommandFromUserInput(string userInput) {
	try {
		if(isEmptyInput(userInput)) {
			throw invalid_argument(EMPTY_STRING);
		}
		CommandCreator cmdCreator;
		Command* command = cmdCreator.createCommand(userInput);

		return command;
	} catch(const exception&) {
		Command* command = new CommandAdd;
		command->setParsedStatus(false);
		return command;
	}
}

bool LogicParser::isEmptyInput(string userInput) {
	return (userInput.empty() 
		 || userInput.find_first_not_of(WHITESPACE_CHAR) == string::npos);
}
	// End of segment: ./\LogicParser.cpp





	/**
	 * origin: ./\LogicParser.h
	 */

//****************************************************************************
//This is the interface class to the entire Parser component. When called with 
//the getCommandFromUserInput(string) method, it is guaranteed to return a 
//pointer to a concrete Command object (such as CommandAdd, CommandEdit, etc).
//
//If an error has occurred during the parsing of the string, the boolean field
//isParsedCorrectly of the Command pointer will be set to false. In the case
//of incorrect input, an appropriate message to the user will be set in the 
//userMessage field of the Command pointer.
//
//Sample usage:
//	LogicParser parser;
//	Command* command = parser.getCommandFromUserInput(string);
//	(...)command.execute();
//	delete command;
//****************************************************************************

#pragma once
#include "LogicParserCommandCreator.h"

using namespace std;

class LogicParser {
public:
	LogicParser(void);
	~LogicParser(void);

	Command* getCommandFromUserInput(string userInput);

private:
	bool isEmptyInput(string userInput);
};
	// End of segment: ./\LogicParser.h





	/**
	 * origin: ./\LogicParserCommandCreator.cpp
	 */

#include "LogicParserCommandCreator.h"

CommandCreator::CommandCreator(void) {
}

CommandCreator::~CommandCreator(void) {
}

Command* CommandCreator::createCommand(string userInput) {
	assert(!userInput.empty());

	setUserInput(userInput);
	Command* command = NULL;

	if(isClearCommand()) {
		command = createClearCommand();
	} else if(isDeleteCommand()) {
		command = createDeleteCommand();	
	} else if(isDoneCommand()) {
		command = createDoneCommand();
	} else if(isEditCommand()) {
		command = createEditCommand();
	} else if(isFilterCommand()) {
		command = createFilterCommand();
	} else if(isLoadCommand()) {
		command = createLoadCommand();
	} else if(isRedoCommand()) {
		command = createRedoCommand();
	} else if(isSearchCommand()) {
		command = createSearchCommand();
	} else if(isUndoCommand()) {
		command = createUndoCommand();
	} else if(isUndoneCommand()) {
		command = createUndoneCommand();
	} else {
		command = createAddCommand();
	}
	return command;
}

void CommandCreator::setUserInput(string userInput) {
	_userInput = userInput;
	_userCommand = getUserCommand();
}

string CommandCreator::getUserCommand(void) {
	return transformToLowercase(getFirstWord(_userInput));
}

string CommandCreator::getParameters(void) {
	return getExceptFirstWord(_userInput);
}

bool CommandCreator::hasParameters(void) {
	return !isOneWord(_userInput);
}

bool CommandCreator::hasNoParameters(void) {
	return isOneWord(_userInput);
}

bool CommandCreator::isClearCommand(void) {
	if(_userCommand == COMMAND_CLEAR) {
			return true;
	}
	return false;
}

bool CommandCreator::isDeleteCommand(void) {
	if(_userCommand == COMMAND_DELETE) {
			return true;
	}
	return false;
}

bool CommandCreator::isDoneCommand(void) {
	if(_userCommand == COMMAND_DONE) {
			return true;
	}
	return false;
}

bool CommandCreator::isEditCommand(void) {
	if(_userCommand == COMMAND_EDIT) {
			return true;
	}
	return false;
}

bool CommandCreator::isFilterCommand(void) {
	if(_userCommand == COMMAND_FILTER) {
			return true;
	}
	return false;
}

bool CommandCreator::isLoadCommand(void) {
	if(_userCommand == COMMAND_LOAD) {
			return true;
	}
	return false;
}

bool CommandCreator::isRedoCommand(void) {
	if(_userCommand == COMMAND_REDO) {
			return true;
	}
	return false;
}

bool CommandCreator::isSearchCommand(void) {
	if(_userCommand == COMMAND_SEARCH) {
			return true;
	}
	return false;
}

bool CommandCreator::isUndoCommand(void) {
	if(_userCommand == COMMAND_UNDO) {
			return true;
	}
	return false;
}

bool CommandCreator::isUndoneCommand(void) {
	if(_userCommand == COMMAND_UNDONE) {
			return true;
	}
	return false;
}

Command* CommandCreator::createAddCommand(void) {
	sprintf_s(logBuffer, LOG_CREATE_ADD.c_str());
	log(logBuffer);

	Command* addCommand = new CommandAdd;
	addCommand->setParsedStatus(true);

	DetailsParser details(_userInput);
	details.addNewTask(addCommand);
	return addCommand;
}

Command* CommandCreator::createClearCommand(void) {
	sprintf_s(logBuffer, LOG_CREATE_CLEAR.c_str());
	log(logBuffer);

	Command* clearCommand = new CommandClear;
	clearCommand->setParsedStatus(hasNoParameters());

	if(!clearCommand->getParsedStatus()) {
		clearCommand->setUserMessage(USERMESSAGE_INVALID_COMMAND_CLEAR);
		sprintf_s(logBuffer, LOG_ERROR_PARAMETER_NUMBER.c_str());
		log(logBuffer);
	}
	return clearCommand;
}

Command* CommandCreator::createDeleteCommand(void) {
	sprintf_s(logBuffer, LOG_CREATE_DELETE.c_str());
	log(logBuffer);

	Command* deleteCommand = new CommandDelete;
	deleteCommand->setParsedStatus(hasParameters());

	if(deleteCommand->getParsedStatus()) {
		DetailsParser details(getParameters());
		details.deleteExistingTask(deleteCommand);
	} else {
		deleteCommand->setUserMessage(USERMESSAGE_INVALID_COMMAND_DELETE);
		sprintf_s(logBuffer, LOG_ERROR_PARAMETER_NUMBER.c_str());
		log(logBuffer);
	}
	return deleteCommand;
}

Command* CommandCreator::createDoneCommand(void) {
	sprintf_s(logBuffer, LOG_CREATE_DONE.c_str());
	log(logBuffer);

	Command* doneCommand = new CommandDone;
	doneCommand->setParsedStatus(hasParameters());

	if(doneCommand->getParsedStatus()) {
		DetailsParser details(getParameters());
		details.markTaskAsDone(doneCommand);
	} else {
		doneCommand->setUserMessage(USERMESSAGE_INVALID_COMMAND_DONE);
		sprintf_s(logBuffer, LOG_ERROR_PARAMETER_NUMBER.c_str());
		log(logBuffer);
	}
	return doneCommand;
}

Command* CommandCreator::createEditCommand(void) {
	sprintf_s(logBuffer, LOG_CREATE_EDIT.c_str());
	log(logBuffer);

	Command* editCommand = new CommandEdit;
	editCommand->setParsedStatus(hasParameters());

	if(editCommand->getParsedStatus()) {
		DetailsParser details(getParameters());
		details.editExistingTask(editCommand);
	} else {
		editCommand->setUserMessage(USERMESSAGE_INVALID_COMMAND_EDIT);
		sprintf_s(logBuffer, LOG_ERROR_PARAMETER_NUMBER.c_str());
		log(logBuffer);
	}
	return editCommand;
}

Command* CommandCreator::createFilterCommand(void) {
	sprintf_s(logBuffer, LOG_CREATE_FILTER.c_str());
	log(logBuffer);

	Command* filterCommand = new CommandFilter;
	filterCommand->setParsedStatus(hasParameters());

	if(filterCommand->getParsedStatus()) {
		DetailsParser details(getParameters());
		details.filterExistingTasks(filterCommand);
	} else {
		filterCommand->setUserMessage(USERMESSAGE_INVALID_COMMAND_FILTER);
		sprintf_s(logBuffer, LOG_ERROR_PARAMETER_NUMBER.c_str());
		log(logBuffer);
	}
	return filterCommand;
}

Command* CommandCreator::createLoadCommand(void) {
	sprintf_s(logBuffer, LOG_CREATE_LOAD.c_str());
	log(logBuffer);

	Command* loadCommand = new CommandLoad;
	loadCommand->setParsedStatus(hasNoParameters());

	if(!loadCommand->getParsedStatus()) {
		loadCommand->setUserMessage(USERMESSAGE_INVALID_COMMAND_LOAD);
		sprintf_s(logBuffer, LOG_ERROR_PARAMETER_NUMBER.c_str());
		log(logBuffer);
	}
	return loadCommand;
}

Command* CommandCreator::createRedoCommand(void) {
	sprintf_s(logBuffer, LOG_CREATE_REDO.c_str());
	log(logBuffer);
	
	Command* redoCommand = new CommandRedo;
	redoCommand->setParsedStatus(hasNoParameters());
	
	if(!redoCommand->getParsedStatus()) {
		redoCommand->setUserMessage(USERMESSAGE_INVALID_COMMAND_REDO);
		sprintf_s(logBuffer, LOG_ERROR_PARAMETER_NUMBER.c_str());
		log(logBuffer);
	}
	return redoCommand;
}

Command* CommandCreator::createSearchCommand(void) {
	sprintf_s(logBuffer, LOG_CREATE_SEARCH.c_str());
	log(logBuffer);

	Command* searchCommand = new CommandSearch;
	searchCommand->setParsedStatus(hasParameters());

	if(searchCommand->getParsedStatus()) {
		DetailsParser details(getParameters());
		details.searchForTask(searchCommand);
	} else {
		searchCommand->setUserMessage(USERMESSAGE_INVALID_COMMAND_SEARCH);
		sprintf_s(logBuffer, LOG_ERROR_PARAMETER_NUMBER.c_str());
		log(logBuffer);
	}
	return searchCommand;
}

Command* CommandCreator::createUndoCommand(void) {
	sprintf_s(logBuffer, LOG_CREATE_UNDO.c_str());
	log(logBuffer);

	Command* undoCommand = new CommandUndo;
	undoCommand->setParsedStatus(hasNoParameters());
		
	if(!undoCommand->getParsedStatus()) {
		undoCommand->setUserMessage(USERMESSAGE_INVALID_COMMAND_UNDO);
		sprintf_s(logBuffer, LOG_ERROR_PARAMETER_NUMBER.c_str());
		log(logBuffer);
	}
	return undoCommand;
}

Command* CommandCreator::createUndoneCommand(void) {
	sprintf_s(logBuffer, LOG_CREATE_UNDONE.c_str());
	log(logBuffer);
	
	Command* undoneCommand = new CommandDone;
	undoneCommand->setParsedStatus(hasParameters());

	if(undoneCommand->getParsedStatus()) {
		DetailsParser details(getParameters());
		details.markTaskAsUndone(undoneCommand);
	} else {
		undoneCommand->setUserMessage(USERMESSAGE_INVALID_COMMAND_UNDONE);
		sprintf_s(logBuffer, LOG_ERROR_PARAMETER_NUMBER.c_str());
		log(logBuffer);
	}
	return undoneCommand;
}
	// End of segment: ./\LogicParserCommandCreator.cpp





	/**
	 * origin: ./\LogicParserCommandCreator.h
	 */

//****************************************************************************
//CommandCreator is the class responsible for the creation of pointers to each
//concrete Command subclass, based on the user input in comparison to the
//valid command inputs as listed below. 
//
//In the process of validating the command, CommandCreator checks the presence
//of the accompanying parameters. In particular, it ensures that
//	1) No parameter is given for {CommandClear, CommandRedo, CommandUndo}.
//	2) Parameter(s) are given for {CommandAdd, CommandDelete, CommandDone,
//								   CommandEdit, CommandFilter, CommandSearch}.

//Note that the validity of the parameters are not checked by CommandCreator.
//
//If unnecessary or insufficient parameters are given, the Command
//pointer returned will have its isParsedCorrectly status set to false and
//userMessage set to an explanation of the command and its usage.
//
//CommandCreator inherits string modification functions from StringModifier.
//
//Sample usage:
//	CommandCreator commandCreator;
//	Command* command = commandCreator.createCommand(string);
//****************************************************************************

#pragma once
#include "CommandAdd.h"
#include "CommandDelete.h"
#include "CommandDone.h"
#include "CommandClear.h"
#include "CommandEdit.h"
#include "CommandFilter.h"
#include "CommandLoad.h"
#include "CommandRedo.h"
#include "CommandSearch.h"
#include "CommandUndo.h"
#include "LogicParserDetailsParser.h"

using namespace std;

const string COMMAND_CLEAR = "/clear";
const string COMMAND_DELETE = "/delete";
const string COMMAND_DONE = "/done";
const string COMMAND_EDIT = "/edit";
const string COMMAND_FILTER = "/filter";
const string COMMAND_LOAD = "/load";
const string COMMAND_REDO = "/redo";
const string COMMAND_SEARCH = "/search";
const string COMMAND_UNDO = "/undo";
const string COMMAND_UNDONE = "/undone";

const string USERMESSAGE_INVALID_COMMAND_CLEAR = 
	"/clear : clear search results";
const string USERMESSAGE_INVALID_COMMAND_DELETE =
	"/delete <index> : delete a task";
const string USERMESSAGE_INVALID_COMMAND_DONE =
	"/done <index> : mark task as done";
const string USERMESSAGE_INVALID_COMMAND_EDIT =
	"/edit <index> <task> : modify task";
const string USERMESSAGE_INVALID_COMMAND_FILTER = 
	"/filter <option> : filter tasks";
const string USERMESSAGE_INVALID_COMMAND_LOAD = 
	"/load is a system command";
const string USERMESSAGE_INVALID_COMMAND_REDO =
	"/redo : redo last undone action";
const string USERMESSAGE_INVALID_COMMAND_SEARCH =
	"/search <keyword> : search for matching task";
const string USERMESSAGE_INVALID_COMMAND_UNDO =
	"/undo : undo last performed action";
const string USERMESSAGE_INVALID_COMMAND_UNDONE =
	"/undone <index> : mark task as not done";

const string LOG_CREATE_ADD = 
	"CommandCreator - Creating an Add Command.\n";
const string LOG_CREATE_CLEAR = 
	"CommandCreator - Creating a Clear Command.\n";
const string LOG_CREATE_DELETE = 
	"CommandCreator - Creating an Delete Command.\n";
const string LOG_CREATE_DONE = 
	"CommandCreator - Creating a Done Command.\n";
const string LOG_CREATE_EDIT = 
	"CommandCreator - Creating an Edit Command.\n";
const string LOG_CREATE_FILTER = 
	"CommandCreator - Creating a Filter Command.\n";
const string LOG_CREATE_LOAD = 
	"CommandCreator - Creating a Load Command.\n";
const string LOG_CREATE_REDO = 
	"CommandCreator - Creating a Redo Command.\n";
const string LOG_CREATE_SEARCH = 
	"CommandCreator - Creating a Search Command.\n";
const string LOG_CREATE_UNDO = 
	"CommandCreator - Creating an Undo Command.\n";
const string LOG_CREATE_UNDONE = 
	"CommandCreator - Creating an Undone Command.\n";
const string LOG_ERROR_PARAMETER_NUMBER = 
	"CommandCreator - Error - Command not parsed correctly. Unexpected number"
	"of parameters supplied.\n";

class CommandCreator : public StringModifier {
public:
	CommandCreator(void);
	~CommandCreator(void);

	Command* createCommand(string userInput);

private:
	void setUserInput(string userInput);
	string getUserCommand(void);
	string getParameters(void);
	bool hasParameters(void);
	bool hasNoParameters(void);

	//Determines the type of concrete Command subclass according to the user
	//command, if any. This set of methods only check for the first word of
	//the user input, and is not concerned with the parameters, if any.
	bool isClearCommand(void);
	bool isDeleteCommand(void);
	bool isDoneCommand(void);
	bool isEditCommand(void);
	bool isFilterCommand(void);
	bool isLoadCommand(void);
	bool isRedoCommand(void);
	bool isSearchCommand(void);
	bool isUndoCommand(void);
	bool isUndoneCommand(void);

	//Creates the pointer to the respective Command subclasses, and populate
	//their internal fields with the variables required as specified in the
	//user input.
	Command* createAddCommand(void);
	Command* createClearCommand(void);
	Command* createDeleteCommand(void);
	Command* createDoneCommand(void);
	Command* createEditCommand(void);
	Command* createFilterCommand(void);
	Command* createLoadCommand(void);
	Command* createRedoCommand(void);
	Command* createSearchCommand(void);
	Command* createUndoCommand(void);
	Command* createUndoneCommand(void);

	string _userInput;
	string _userCommand;
};
	// End of segment: ./\LogicParserCommandCreator.h





	/**
	 * origin: ./\LogicParserDateTimeParser.cpp
	 */

#include "LogicParserDatetimeParser.h"

DatetimeParser::DatetimeParser(void) {
	_currentDate = day_clock::local_day();
	_startTime = not_a_date_time;
	_endTime = not_a_date_time;
	_deadlineTime = not_a_date_time;
}

DatetimeParser::~DatetimeParser(void) {
}

void DatetimeParser::addTaskDatetime(Task* task, string& parameters) {
	try{
		setParameters(parameters);

		addDeadlineDatetime();
		addEndDatetime();
		addStartDatetime();

		combineDatetime();
		setFoundDatetime(task);
		parameters = getParameters();
	} catch(const out_of_range&) {
		throw;
	}
}

void DatetimeParser::addFilterDate(Command* command, string parameters) {
	try{
		setParameters(parameters);

		addEndWithIdentifier();
		addStartWithoutIdentifier();

		setFilterDatetime(command);
	} catch(const out_of_range&) {
		throw;
	}
}

void DatetimeParser::setParameters(string parameters) {
	_parameters = tokenizeString(parameters);
}

string DatetimeParser::getParameters() {
	return detokenizeVector(_parameters);
}

void DatetimeParser::combineDatetime(void) {
	combineDeadlineDatetime();
	combineStartDatetime();
	combineEndDatetime();
}

void DatetimeParser::setFoundDatetime(Task* task) {
	task->setTaskStartTime(_startDatetime);
	task->setTaskEndTime(_endDatetime);
	task->setTaskDeadline(_deadlineDatetime);
}

void DatetimeParser::setFilterDatetime(Command* command) {
	command->setStartDateFilter(_startDate);
	if(hasEndDate()) {
		command->setEndDateFilter(_endDate);
	} else {
		command->setEndDateFilter((date)pos_infin);
	}
}

void DatetimeParser::eraseWord(vector<string>::iterator& iter) {
	*iter = EMPTY_STRING;
}

void DatetimeParser::addDate(vector<string>::iterator iter, date& date, time_duration& time) {
	try {
		if(is3WordDate(iter)) {
			if(isATime(iter + THREE)) {
				time = parseTime(iter + THREE);
			}
		} else if(is2WordDate(iter)) {
			if(isATime(iter + TWO)) {
				time = parseTime(iter + TWO);
			}
		} else if(isATime(iter + ONE)) {
				time = parseTime(iter + ONE);
		}
		date = parseDate(iter);
	} catch(const out_of_range&) {
		throw;
	}
}

void DatetimeParser::addTime(vector<string>::iterator iter,  date& date, time_duration& time) {
	try {
		if(isADate(iter + ONE)) {
			date = parseDate(iter + ONE);
		}
		time = parseTime(iter);
	} catch(const out_of_range&) {
		throw;
	}
}

void DatetimeParser::addStartDatetime(void) {
	try {
		addStartWithIdentifier(); 
		if(!hasStartDate() || !hasStartTime()) {
			addStartWithoutIdentifier();
		}
	} catch(const out_of_range&) {
		throw;
	}
}

bool DatetimeParser::hasStartDatetime(void) {
	return !_startDatetime.is_not_a_date_time();
}

bool DatetimeParser::hasStartDate(void) {
	return !_startDate.is_not_a_date();
}

bool DatetimeParser::hasStartTime(void) {
	return !_startTime.is_not_a_date_time();
}

void DatetimeParser::addStartWithIdentifier(void) {
	try {
		for(auto iter = _parameters.begin(); iter != _parameters.end(); ++iter) {
			if(isStartIdentifier(*iter) && isATime(iter + ONE)) {
				addTime(iter + ONE, _startDate, _startTime);
				eraseWord(iter);
			} else if(isStartIdentifier(*iter) && isADate(iter + ONE)) {
				addDate(iter + ONE, _startDate, _startTime);
				eraseWord(iter);
			}
		}
	} catch(const out_of_range&) {
		throw;
	}
}

void DatetimeParser::addStartWithoutIdentifier(void) {
	try {
		for(auto iter = _parameters.begin(); iter != _parameters.end(); ++iter) {
			if(!hasStartTime() && isATime(iter)) {
				_startTime = parseTime(iter);
			} else if(!hasStartDate() && isADate(iter)) {
				_startDate = parseDate(iter);
			}
		}
	} catch(const out_of_range&) {
		throw;
	}
}

bool DatetimeParser::isStartIdentifier(string word) {
	for(auto iter = DATE_START.begin(); iter != DATE_START.end(); ++iter) {
		if(transformToLowercase(word) == *iter) {
			return true;
		}
	}
	return false;
}

void DatetimeParser::combineStartDatetime(void) {
	if(!hasStartTime()) {
		//Marker for allday tasks
		time_duration allDay = seconds(ONE);
		_startTime = allDay;
	} else if(!hasStartDate()) {
		_startDate = _currentDate;
	}
	ptime startDatetime(_startDate, _startTime);
	_startDatetime = startDatetime;
}

void DatetimeParser::addEndDatetime(void) {
	try {
		addEndWithIdentifier(); 
	} catch(const out_of_range&) {
		throw;
	}
}

bool DatetimeParser::hasEndDatetime(void) {
	return !_endDatetime.is_not_a_date_time();
}

bool DatetimeParser::hasEndDate(void) {
	return !_endDate.is_not_a_date();
}

bool DatetimeParser::hasEndTime(void) {
	return !_endTime.is_not_a_date_time();
}

void DatetimeParser::addEndWithIdentifier(void) {
	try {
		for(auto iter = _parameters.begin(); iter != _parameters.end(); ++iter) {
			if(isEndIdentifier(*iter) && isATime(iter + ONE)) {
				addTime(iter + ONE, _endDate, _endTime);
				eraseWord(iter);
			} else if(isEndIdentifier(*iter) && isADate(iter + ONE)) {
				addDate(iter + ONE, _endDate, _endTime);
				eraseWord(iter);
			}
		}
	} catch(const out_of_range&) {
		throw;
	}
}

bool DatetimeParser::isEndIdentifier(string word) {
	for(auto iter = DATE_END.begin(); iter != DATE_END.end(); ++iter) {
		if(transformToLowercase(word) == *iter) {
			return true;
		}
	}
	return false;
}

void DatetimeParser::combineEndDatetime(void) {
	if(!hasEndTime()) {
		//Marker for allday tasks
		time_duration allDay = seconds(ONE);
		_endTime = allDay;
	} else if(!hasEndDate()) {
		_endDate = _startDate;
	}
	ptime endDatetime(_endDate, _endTime);
	_endDatetime = endDatetime;
}

void DatetimeParser::addDeadlineDatetime(void) {
	try {
		addDeadlineWithIdentifier(); 
	} catch(const out_of_range&) {
		throw;
	}
}

bool DatetimeParser::hasDeadlineDatetime(void) {
	return !_deadlineDatetime.is_not_a_date_time();
}

bool DatetimeParser::hasDeadlineDate(void) {
	return !_deadlineDate.is_not_a_date();
}

bool DatetimeParser::hasDeadlineTime(void) {
	return !_deadlineTime.is_not_a_date_time();
}

void DatetimeParser::addDeadlineWithIdentifier(void) {
	try {
		for(auto iter = _parameters.begin(); iter != _parameters.end(); ++iter) {
			if(isDeadlineIdentifier(*iter) && isATime(iter + ONE)) {
				addTime(iter + ONE, _deadlineDate, _deadlineTime);
				eraseWord(iter);
			} else if(isDeadlineIdentifier(*iter) && isADate(iter + ONE)) {
				addDate(iter + ONE, _deadlineDate, _deadlineTime);
				eraseWord(iter);
			}
		}
	} catch(const out_of_range&) {
		throw;
	}
}

bool DatetimeParser::isDeadlineIdentifier(string word) {
	for(auto iter = DATE_DEADLINE.begin(); iter != DATE_DEADLINE.end(); ++iter) {
		if(transformToLowercase(word) == *iter) {
			return true;
		}
	}
	return false;
}

void DatetimeParser::combineDeadlineDatetime(void) {
	if(!hasDeadlineTime()) {
		//Marker for allday tasks
		time_duration allDay = seconds(ONE);
		_deadlineTime = allDay;
	} else if(!hasDeadlineDate()) {
		_deadlineDate = _currentDate;
	}
	ptime deadlineDatetime(_deadlineDate, _deadlineTime);
	_deadlineDatetime = deadlineDatetime;
}

//Time Parsing Functions													   
bool DatetimeParser::isATime(vector<string>::iterator iter) {
	if(iter == _parameters.end()) {
		return false;
	}
	return (isAmPmTime(*iter) || isMilitaryTime(*iter));
}

time_duration DatetimeParser::parseTime(vector<string>::iterator iter) {
	assert(iter != _parameters.end());
	assert(isATime(iter));

	int intHours = ZERO;
	int intMinutes = ZERO;

	if(isAmPmTime(*iter)) {
		parseAmPmTime(*iter, intHours, intMinutes);
	} else {
		parseMilitaryTime(*iter, intHours, intMinutes);
	}

	time_duration timeOfDay = hours(intHours) + minutes(intMinutes);
	eraseWord(iter);
	return timeOfDay;
}

bool DatetimeParser::isMilitaryTime(string word) {
	removeTimeDelimiters(word);

	if(!isNumber(word) || word.length() != STRLEN_24H_TIME) {
		return false;
	}
	return is24HourTime(stoi(word));
}

bool DatetimeParser::isAmPmTime(string word) {
	removeTimeDelimiters(word);

	istringstream iss(word);
	int time;
	string AMPM;

	iss >> time >> AMPM;
	return (is12HourTime(time) && (isAm(AMPM) || isPm(AMPM)));
}

bool DatetimeParser::is24HourTime(int number) {
	int hours = number / NUMLEN_3;
	int minutes = number % NUMLEN_3;
	return ((hours >= VALID_MIN_HOUR_24 && hours <= VALID_MAX_HOUR_24) 
		&& (minutes >= VALID_MIN_MINUTE && minutes <= VALID_MAX_MINUTE));
}

bool DatetimeParser::is12HourTime(int number) {
	if(number < NUMLEN_3) {
		return (number >= VALID_MIN_HOUR_12 && number <= VALID_MAX_HOUR_12);
	} else {
		int hours = number / NUMLEN_3;
		int minutes = number % NUMLEN_3;
		return ((hours >= VALID_MIN_HOUR_12 && hours <= VALID_MAX_HOUR_12) 
			&& (minutes >= VALID_MIN_MINUTE && minutes <= VALID_MAX_MINUTE));
	}
}

bool DatetimeParser::isAm(string word) {
	return (word == TIME_AM);
}

bool DatetimeParser::isPm(string word) {
	return (word == TIME_PM);
}

void DatetimeParser::parseMilitaryTime(string word, int& hours, int& minutes) {
	removeTimeDelimiters(word);

	int time = stoi(word);
	hours = time / NUMLEN_3;
	minutes = time % NUMLEN_3;
}

void DatetimeParser::parseAmPmTime(string word, int& hours, int& minutes) {
	removeTimeDelimiters(word);

	istringstream iss(word);
	int time;
	string AMPM;
	iss >> time >> AMPM;

	if(time < NUMLEN_3) {
		hours = time;
	} else {
		hours = time / NUMLEN_3;
		minutes = time % NUMLEN_3;
	}

	if(isAm(AMPM) && hours == VALID_MAX_HOUR_12) {
		hours = ZERO;
	} else if(isPm(AMPM) && hours != VALID_MAX_HOUR_12) {
		hours += VALID_MAX_HOUR_12;
	}
}

void DatetimeParser::removeTimeDelimiters(string& word) {
	word = transformToLowercase(word);
	for(auto iter = TIME_DELIMITERS.begin(); iter != TIME_DELIMITERS.end(); ++iter) {
		word.erase(remove(word.begin(), word.end(), *iter), word.end());
	}
}

//Date Parsing Functions
bool DatetimeParser::isADate(vector<string>::iterator iter) {
	if(iter == _parameters.end()) {
		return false;
	}
	return (is3WordDate(iter) || is2WordDate(iter) || is1WordDate(iter));
}

date DatetimeParser::parseDate(vector<string>::iterator iter) {
	try{
		assert(iter != _parameters.end());
		assert(isADate(iter));
		if(is3WordDate(iter)) {
			return parse3WordDate(iter);
		} else if(is2WordDate(iter)) {
			return parse2WordDate(iter);
		} else {
			return parse1WordDate(iter);
		}
	} catch(const out_of_range&) {
		throw;
	}
}

bool DatetimeParser::is3WordDate(vector<string>::iterator iter) {
	assert(iter != _parameters.end());
	if((iter + ONE) == _parameters.end() || (iter + TWO) == _parameters.end()) {
		return false;
	}
	return DatetimeParser::isDayMonthYear(iter);
}

bool DatetimeParser::is2WordDate(vector<string>::iterator iter) {
	assert(iter != _parameters.end());
	if((iter + ONE) == _parameters.end()) {
		return false;
	}
	return (isDayMonth(iter) || isThisNextWeekday(iter));
}

bool DatetimeParser::is1WordDate(vector<string>::iterator iter) {
	assert(iter != _parameters.end());
	return (isToday(*iter)
		 || isTomorrow(*iter)
	 	 || isWeekday(*iter)
		 || isNumericalDate(*iter));
}

bool DatetimeParser::isDayMonthYear(vector<string>::iterator iter) {
	assert(iter != _parameters.end());
	assert((iter + ONE) != _parameters.end());
	assert((iter + TWO) != _parameters.end());
	if(!isNumber(*iter)) {
		return false;
	} else if(!isNumber(*(iter + TWO))) {
		return false;
	}
	int day = stoi(*iter);
	string month = *(iter + ONE);
	int year = stoi(*(iter + TWO));
	return (isDay(day) && isMonth(month) && isYear(year));
}

bool DatetimeParser::isDayMonth(vector<string>::iterator iter) {
	assert(iter != _parameters.end());
	assert((iter + ONE) != _parameters.end());
	if(!isNumber(*iter)) {
		return false;
	}
	int day = stoi(*iter);
	string month = *(iter + ONE);
	return (isDay(day) && isMonth(month));
}

bool DatetimeParser::isThisNextWeekday(vector<string>::iterator iter) {
	assert(iter != _parameters.end());
	assert((iter + ONE) != _parameters.end());
	string thisNext = *iter;
	string weekday = *(iter + ONE);
	return (isWeekday(weekday) 
		&& (isThis(thisNext) || isNext(thisNext)));
}

bool DatetimeParser::isToday(string date) {
	date = transformToLowercase(date);
	for(auto iter = DATE_TODAY.begin(); iter != DATE_TODAY.end(); ++iter) {
		if(date == *iter) {
			return true;
		}
	}
	return false;
}

bool DatetimeParser::isTomorrow(string date) {
	date = transformToLowercase(date);
	for(auto iter = DATE_TOMORROW.begin(); iter != DATE_TOMORROW.end(); ++iter) {
		if(date == *iter) {
			return true;
		}
	}
	return false;
}

bool DatetimeParser::isWeekday(string date) {
	date = transformToLowercase(date);
	for(int index = ZERO; index < VALID_MAX_WEEKDAY; ++index) {
		if(date == WEEKDAYS_LONG[index] || date == WEEKDAYS_SHORT[index]) {
			return true;
		}
	}
	return false;
}

bool DatetimeParser::isNumericalDate(string date) {
	removeDateDelimiters(date);

	if(!isNumber(date)) {
		return false;
	}
	return (isDDMM(date) 
		 || isDDMMYY(date) 
		 || isDDMMYYYY(date));
}

bool DatetimeParser::isDDMM(string date) {
	if(date.length() != STRLEN_DDMM) {
		return false;
	}
	int numDate = stoi(date);
	int day = numDate / NUMLEN_3;
	int month = numDate % NUMLEN_3;
	return (isDay(day) && isMonth(month));
}

bool DatetimeParser::isDDMMYY(string date) {
	if(date.length() != STRLEN_DDMMYY) {
		return false;
	}
	int numDate = stoi(date);
	int day = numDate / NUMLEN_5;
	int month = (numDate / NUMLEN_3) % NUMLEN_3;
	int year = (numDate % NUMLEN_3) + CURRENT_MILLENIUM;
	return (isDay(day) && isMonth(month) && isYear(year));
}

bool DatetimeParser::isDDMMYYYY(string date) {
	if(date.length() != STRLEN_DDMMYYYY) {
		return false;
	}
	int numDate = stoi(date);
	int day = numDate / NUMLEN_7;
	int month = (numDate / NUMLEN_5) % NUMLEN_3;
	int year = numDate % NUMLEN_5;
	return (isDay(day) && isMonth(month) && isYear(year));
}

bool DatetimeParser::isThis(string word) {
	return transformToLowercase(word) == DATE_THIS;
}

bool DatetimeParser::isNext(string word) {
	return transformToLowercase(word) == DATE_NEXT;
}

bool DatetimeParser::isDay(int day) {
	return (day >= VALID_MIN_DAY && day <= VALID_MAX_DAY);
}

bool DatetimeParser::isMonth(int month) {
	return (month >= VALID_MIN_MONTH && month <= VALID_MAX_MONTH);
}

bool DatetimeParser::isYear(int year) {
	return ((year >= VALID_MIN_YEAR_YY && year <= VALID_MAX_YEAR_YY)
		  || year >= VALID_MIN_YEAR_YYYY && year <= VALID_MAX_YEAR_YYYY);
}

bool DatetimeParser::isMonth(string month) {
	month = transformToLowercase(month);
	for(int index = ZERO; index < VALID_MAX_MONTH; ++index) {
		if(month == MONTHS_LONG[index] || month == MONTHS_SHORT[index]) {
			return true;
		}
	}
	return false;
}

date DatetimeParser::parse3WordDate(vector<string>::iterator iter) {
	try {
		assert(iter != _parameters.end());
		assert((iter + ONE) != _parameters.end());
		assert((iter + TWO) != _parameters.end());

		date dateFound = parseDayMonthYear(iter);

		eraseWord(iter);
		eraseWord(iter + ONE);
		eraseWord(iter + TWO);
		return dateFound;
	} catch(const out_of_range&) {
		throw;
	}
}

date DatetimeParser::parse2WordDate(vector<string>::iterator iter) {
	try {
		assert(iter != _parameters.end());
		assert((iter + ONE) != _parameters.end());

		date dateFound;
		if(isDayMonth(iter)) {
			dateFound = parseDayMonth(iter);
		} else if(isThis(*iter)) {
			dateFound = parseThisWeekday(*(iter + ONE));
		} else {
			dateFound = parseNextWeekday(*(iter + ONE));
		}

		eraseWord(iter);
		eraseWord(iter + ONE);
		return dateFound;
	} catch(const out_of_range&) {
		throw;
	}
}

date DatetimeParser::parse1WordDate(vector<string>::iterator iter) {
	try {
		assert(iter != _parameters.end());

		date dateFound;
		if(isToday(*iter)) {
			dateFound = parseToday();
		} else if(isTomorrow(*iter)) {
			dateFound = parseTomorrow();
		} else if(isWeekday(*iter)) {
			dateFound = parseComingWeekday(*iter);
		} else {
			dateFound = parseNumericalDate(*iter);
		}

		eraseWord(iter);
		return dateFound;
	} catch(const out_of_range&) {
		throw;
	}
}

date DatetimeParser::parseDayMonthYear(vector<string>::iterator iter) {
	try {
		int day = parseDay(*iter);
		int month = parseMonth(*(iter + ONE));
		int year = parseYear(*(iter + TWO));
		date dateFound(year, month, day);
		return dateFound;
	} catch(const out_of_range&) {
		throw out_of_range(USERMESSAGE_DATETIME_NOT_PARSED);
	}
}

date DatetimeParser::parseDayMonth(vector<string>::iterator iter) {
	try {
		int day = parseDay(*iter);
		int month = parseMonth(*(iter + ONE));
		int year = _currentDate.year();
		date dateFound(year, month, day);
		return dateFound;
	} catch(const out_of_range&) {
		throw out_of_range(USERMESSAGE_DATETIME_NOT_PARSED);
	}
}

date DatetimeParser::parseThisWeekday(string weekday) {
	weekday = transformToLowercase(weekday);
	int _currentWeekday = (int)_currentDate.day_of_week();
		
	for(int index = ZERO; index < VALID_MAX_WEEKDAY; ++index) {
		if(weekday == WEEKDAYS_LONG[index] || weekday == WEEKDAYS_SHORT[index]) {
			if(index >= _currentWeekday) {
				return next_weekday(_currentDate, (greg_weekday)index);
			} else {
				date thisWeekday = next_weekday(_currentDate, (greg_weekday)index);
				date dateFound = thisWeekday - (date_duration)VALID_MAX_WEEKDAY;
				return dateFound;
			}
		}
	}
	date notFound;
	return notFound;
}

date DatetimeParser::parseNextWeekday(string weekday) {
	weekday = transformToLowercase(weekday);
	int _currentWeekday = (int)_currentDate.day_of_week();

	for(int index = ZERO; index < VALID_MAX_WEEKDAY; ++index) {
		if(weekday == WEEKDAYS_LONG[index] || weekday == WEEKDAYS_SHORT[index]) {
			if(index >= _currentWeekday) {
				date nextWeekday = next_weekday(_currentDate, (greg_weekday)index);
				date dateFound = nextWeekday + (date_duration)VALID_MAX_WEEKDAY;
				return dateFound;
			} else {
				return next_weekday(_currentDate, (greg_weekday)index);
			}
		}
	}
	date notFound;
	return notFound;
}

date DatetimeParser::parseToday(void) {
	return _currentDate;
}

date DatetimeParser::parseTomorrow(void) {
	return _currentDate + (date_duration)ONE;
}

date DatetimeParser::parseComingWeekday(string weekday) {
	weekday = transformToLowercase(weekday);
	int _currentWeekday = (int)_currentDate.day_of_week();

	for(int index = ZERO; index < VALID_MAX_WEEKDAY; ++index) {
		if(weekday == WEEKDAYS_LONG[index] || weekday == WEEKDAYS_SHORT[index]) {
			if(index == _currentWeekday) {
				return _currentDate + (date_duration)VALID_MAX_WEEKDAY;
			} else {
				return next_weekday(_currentDate, (greg_weekday)index);
			}
		}
	}
	date notFound;
	return notFound;
}

date DatetimeParser::parseNumericalDate(string date) {
	try {
		removeDateDelimiters(date);

		assert(isNumber(date));
		if(isDDMM(date)) {
			return parseDDMM(stoi(date));
		} else if(isDDMMYY(date)) {
			return parseDDMMYY(stoi(date));
		} else {
			return parseDDMMYYYY(stoi(date));
		}
	} catch(const out_of_range&) {
		throw;
	}
}

date DatetimeParser::parseDDMM(int intDate) {
	try {
		int day = intDate / NUMLEN_3;
		int month = intDate % NUMLEN_3;
		int year = _currentDate.year();
		date dateFound(year, month, day);
		return dateFound;
	} catch(const out_of_range&) {
		throw out_of_range(USERMESSAGE_DATETIME_NOT_PARSED);
	}
}

date DatetimeParser::parseDDMMYY(int intDate) {
	try {
		int day = intDate / NUMLEN_5;
		int month = (intDate / NUMLEN_3) % NUMLEN_3;
		int year = intDate % NUMLEN_3;
		if(year <= VALID_MAX_YEAR_YY) {
			year += CURRENT_MILLENIUM;
		}
		date dateFound(year, month, day);
		return dateFound;
	} catch(const out_of_range&) {
		throw out_of_range(USERMESSAGE_DATETIME_NOT_PARSED);
	}
}

date DatetimeParser::parseDDMMYYYY(int intDate) {
	try {
		int day = intDate / NUMLEN_7;
		int month = (intDate / NUMLEN_5) % NUMLEN_3;
		int year = intDate % NUMLEN_5;
		date dateFound(year, month, day);
		return dateFound;
	} catch(const out_of_range&) {
		throw out_of_range(USERMESSAGE_DATETIME_NOT_PARSED);
	}
}

int DatetimeParser::parseDay(string day) {
	assert(isNumber(day));
	return stoi(day);
}

int DatetimeParser::parseMonth(string month) {
	if(isNumber(month)) {
		return stoi(month);
	} else {
		month = transformToLowercase(month);
		for(int index = ZERO; index < VALID_MAX_MONTH; ++index) {
			if(month == MONTHS_LONG[index] || month == MONTHS_SHORT[index]) {
				return ++index;
			}
		}
	}
	return ZERO;
}

int DatetimeParser::parseYear(string year) {
	assert(isNumber(year));
	int numYear = stoi(year);
	if(numYear <= VALID_MAX_YEAR_YY) {
		numYear += CURRENT_MILLENIUM;
	}
	return numYear;
}

void DatetimeParser::removeDateDelimiters(string& word) {
	word = transformToLowercase(word);
	for(auto iter = DATE_DELIMITERS.begin(); iter != DATE_DELIMITERS.end(); ++iter) {
		word.erase(remove(word.begin(), word.end(), *iter), word.end());
	}
}
	// End of segment: ./\LogicParserDateTimeParser.cpp





	/**
	 * origin: ./\LogicParserDateTimeParser.h
	 */

//****************************************************************************
//DatetimeParser is responsible for the parsing of date and/or time tokens in
//the user input, if any. It serves two main functions:
//	1) Parsing the datetimes for new tasks added/tasks that are to be edited
//	2) Parsing the date/date range required for filters.
//
//1) addTaskDatetime - Parsing datetimes for CommandAdd/CommandEdit
//addTaskDatetime takes in a Task pointer and a reference to a string, in order
//to set the Start/End/Deadline datetimes in the task to dates found in the
//string parameters given.
//
//It does so by breaking up the parameters given into individual tokens and 
//searching for instances of date and/or time tokens. If any of the datetimes]
//are found, the relevant tokens will be removed. Finally, the parameters
//string is reconstructed such that it can be used again by the calling 
//function (to be set as the task name). Note that in the process, the
//whitespace character(s) between tokens in the original paramters are all
//replaced by a single space.
//
//addTaskDatetime adds deadlines and end datetimes through the use of key
//identifier words as listed below. These identifiers are required for 
//deadline and end datetimes, but not for start datetimes. As such, a datetime
//token without a identifier will be automatically recognised as a start
//datetime.
//
//addTaskDatetime will throw an out_of_range exception if a "valid datetime",
//after parsing, is found to be non-existent (eg, 30 Feb 2014). It will NOT
//throw exceptions if invalid datetime tokens are encountered (eg, 32 Dec),
//but will instead retain them in the parameters string supplied.
//
//2) addFilterDate - Parsing date/date ranges for CommandFilter
//addFilterDate takes in a Command pointer and a string to parse the date
// or date range filtering options for the filter command.
//
//Similarly to addTaskDatetime, addFilterDate breaks the parameters string
//into tokens to look for instances of date tokens. However, as the parameters
//need not be updated for further use, it is not reconstructed or returned.
//
//addFilterDate requires identifiers to recognise end date filters, but will
//add start date filters regardless of identifiers.
//
//Exception handling procedures are identical the addTaskDatetime, as stated
//above.
//
//
//DatetimeParser currently supports the following formats for input:
//Date - 
//	1) Day Month Year - 15 Nov|November 14|2014
//	2) Day Month - 15 Nov|November (Sets the year as the current year)
//	3) This Weekday - this fri|friday (Sets the date as the friday this week,
//									   regardless of the day today.)
//	4) Next Weekday - next thur (Sets the date as the thursday this week, 
//								 regardless of the day today.)
//	5) DDMM - 0103 (Can be delimited by ".", "/", or "-", eg 01/03. Sets the
//				    year as the current year.)
//	6) DDMMYY - 010314 (As above, can be delimited by ".", "/", or "-".)
//	7) DDMMYYYY  -01032014 (As above, can be delimited by ".", "/", or "-".)
//	8) Weekday - fri|friday (Sets the date as the nearest friday, not counting
//							 today.)
//	9) Special - today|tomorrow
//
//Time - 
//	1) 12 Hours - 12pm, 1245AM (Can be delimited by "." or ":", eg 12:00a.m.)
//	2) 24 Hours - 0845, 2359 (Can be delimited by "." or ":", eg 23.59)
//
//All above input formats are case insensitive.
//
//DatetimeParser inherits string modification functions from StringModifier.
//
//Sample usage:
//	DatetimeParser datetime;
//	Task* task = new task;
//	string parameters = "parameters are inside here";
//	datetime.addTaskDatetime(task, parameters);
//****************************************************************************
#pragma once
#include "boost\date_time.hpp"
#include "LogicParserStringModifier.h"

using namespace std;
using namespace boost::posix_time;
using namespace boost::gregorian;

const int NUMLEN_3 = 100;
const int NUMLEN_5 = 10000;
const int NUMLEN_7 = 1000000;

const int STRLEN_24H_TIME = 4;
const int STRLEN_DDMM = 4;
const int STRLEN_DDMMYY = 6;
const int STRLEN_DDMMYYYY = 8;

const int VALID_MIN_HOUR_12 = 1;
const int VALID_MAX_HOUR_12 = 12;
const int VALID_MIN_HOUR_24 = 0;
const int VALID_MAX_HOUR_24 = 23;
const int VALID_MIN_MINUTE = 0;
const int VALID_MAX_MINUTE = 59;

const int VALID_MIN_DAY = 1;
const int VALID_MAX_DAY = 31;
const int VALID_MIN_MONTH = 1;
const int VALID_MAX_MONTH = 12;
const int VALID_MIN_YEAR_YY = 0;
const int VALID_MAX_YEAR_YY = 99;
const int VALID_MIN_YEAR_YYYY = 1970;
const int VALID_MAX_YEAR_YYYY = 9999;
const int VALID_MAX_WEEKDAY = 7;
const int CURRENT_MILLENIUM = 2000;

const string TIME_DELIMITERS = ".:";
const string TIME_AM = "am";
const string TIME_PM = "pm";

const string DATE_DELIMITERS = "./-";
const string DATE_THIS = "this";
const string DATE_NEXT = "next";
const array<string, 2> DATE_TODAY = 
	{"today", "tdy"};
const array<string, 5> DATE_TOMORROW = 
	{"tomorrow", "tmr", "tml", "tmw", "tmrw"};
const array<string, 3> DATE_START = 
	{"at", "on", "from"};
const array<string, 5> DATE_END = 
	{"to", "till", "til", "until", "-"};
const array<string, 3> DATE_DEADLINE = 
	{"by", "due", "before"};

const array<string, 7> WEEKDAYS_SHORT = 
	{"sun", "mon", "tue", "wed", "thu", "fri", "sat",};
const array<string, 7> WEEKDAYS_LONG = 
	{"sunday", "monday", "tuesday", "wednesday",
	"thursday", "friday", "saturday"};
const array<string, 12> MONTHS_SHORT = 
	{"jan", "feb", "mar", "apr", "may", "jun",
	"jul", "aug", "sep", "oct", "nov", "dec"};
const array<string, 12> MONTHS_LONG = 
	{"january", "february", "march", "april", "may", "june",
	"july", "august", "september", "october", "november", "december"};

const string USERMESSAGE_DATETIME_NOT_PARSED = 
	"You've entered a non-existent date!";

class DatetimeParser : public StringModifier {
public:
	DatetimeParser(void);
	~DatetimeParser(void);

	void addTaskDatetime(Task* task, string& parameters);
	void addFilterDate(Command* command, string parameters);

private:
	vector<string> _parameters;
	date _currentDate;
	date _startDate;
	date _endDate;
	date _deadlineDate;
	time_duration _startTime;
	time_duration _endTime;
	time_duration _deadlineTime;
	ptime _startDatetime;
	ptime _endDatetime;
	ptime _deadlineDatetime;
	
	void setParameters(string parameters);
	string getParameters(void);
	void combineDatetime(void);
	void setFoundDatetime(Task* task);
	void setFilterDatetime(Command* command);
	void eraseWord(vector<string>::iterator& iter);
	void addDate(vector<string>::iterator iter, date& date, time_duration& time);
	void addTime(vector<string>::iterator iter, date& date, time_duration& time);

	//Functions to parse the start datetime of the task
	void addStartDatetime(void);
	bool hasStartDatetime(void);
	bool hasStartDate(void);
	bool hasStartTime(void);
	void addStartWithIdentifier(void);
	void addStartWithoutIdentifier(void);
	bool isStartIdentifier(string word);
	void combineStartDatetime(void);

	//Functions to parse the end datetime of the task
	void addEndDatetime(void);
	bool hasEndDatetime(void);
	bool hasEndDate(void);
	bool hasEndTime(void);
	void addEndWithIdentifier(void);
	bool isEndIdentifier(string word);
	void combineEndDatetime(void);

	//Functions to parse the deadline datetime of the task
	void addDeadlineDatetime(void);
	bool hasDeadlineDatetime(void);
	bool hasDeadlineDate(void);
	bool hasDeadlineTime(void);
	void addDeadlineWithIdentifier(void);
	bool isDeadlineIdentifier(string word);
	void combineDeadlineDatetime(void);

	//Time Parsing Functions
	bool isATime(vector<string>::iterator iter);
	time_duration parseTime(vector<string>::iterator iter);

	bool isMilitaryTime(string word);
	bool isAmPmTime(string word);

	bool is24HourTime(int number);
	bool is12HourTime(int number);
	bool isAm(string word);
	bool isPm(string word);

	//Handles the parsing for military (or 24 hour) time.
	void parseMilitaryTime(string word, int& hours, int& minutes);
	//Handles the parsing for AM/PM (or 12 hour) time.
	void parseAmPmTime(string word, int& hours, int& minutes);

	void removeTimeDelimiters(string& word);

	//Date Parsing Functions
	bool isADate(vector<string>::iterator iter);
	date parseDate(vector<string>::iterator iter);

	bool is3WordDate(vector<string>::iterator iter);
	bool is2WordDate(vector<string>::iterator iter);
	bool is1WordDate(vector<string>::iterator iter);

	bool isDayMonthYear(vector<string>::iterator iter);
	bool isDayMonth(vector<string>::iterator iter);
	//Note: A week is defined to start from Sunday ane ends on Saturday.
	bool isThisNextWeekday(vector<string>::iterator iter);
	bool isToday(string date);
	bool isTomorrow(string date);
	//Note: A week is defined to start from Sunday ane ends on Saturday.
	bool isWeekday(string date);
	bool isNumericalDate(string date);

	bool isDDMM(string date);
	bool isDDMMYY(string date);
	bool isDDMMYYYY(string date);
	bool isThis(string word);
	bool isNext(string word);
	bool isDay(int day);
	bool isMonth(string month);
	bool isMonth(int month);
	bool isYear(int year);

	date parse3WordDate(vector<string>::iterator iter);
	date parse2WordDate(vector<string>::iterator iter);
	date parse1WordDate(vector<string>::iterator iter);

	date parseDayMonthYear(vector<string>::iterator iter);
	date parseDayMonth(vector<string>::iterator iter);
	
	//"This weekday" assumes that the user is referring to the weekday in
	//the current week, regardless of whether it has actually passed. As such,
	//adding a task "this monday" when the current day of the week is Wednesday
	//will add the task to 2 days prior.
	date parseThisWeekday(string weekday);

	//"Next weekday" assumes that the user is referring to the weekday in the 
	//week following the current one. As such, adding a task "next friday" when
	//the current day of the week is monday will add the task 11 days later.
	//Note that since the week starts on Sunday, adding a task "next Sunday"
	//will always add the task to the Sunday nearest the current day, except in
	//the case where the current day is Sunday.
	date parseNextWeekday(string weekday);
	
	date parseToday(void);
	date parseTomorrow(void);
	//"Weekday" assumes that the user is referring to the next approaching
	//day of the week specified, except for the current day. As such, adding
	//a task on "friday" when the current day is Wednesday will add the task
	//2 days from today, but adding the the task on "wednesday" in the same 
	//situation will add it to a week later.
	date parseComingWeekday(string weekday);

	date parseNumericalDate(string date);
	date parseDDMM(int intDate);
	date parseDDMMYY(int intDate);
	date parseDDMMYYYY(int intDate);
	
	int parseDay(string day);
	int parseMonth(string month);
	int parseYear(string year);

	void removeDateDelimiters(string& word);
};
	// End of segment: ./\LogicParserDateTimeParser.h





	/**
	 * origin: ./\LogicParserDetailsParser.cpp
	 */

#include "LogicParserDetailsParser.h"

DetailsParser::DetailsParser(string parameters) {
	assert(!parameters.empty());
	_parameters = parameters;
	_tokens = tokenizeString(parameters);
}

DetailsParser::~DetailsParser(void) {
}

void DetailsParser::addNewTask(Command* command) {
	sprintf_s(logBuffer, LOG_ADD_TASK.c_str());
	log(logBuffer);

	try {
		DatetimeParser datetime;
		Task* task = new Task;
	
		addTaskTags(task);
		datetime.addTaskDatetime(task, _parameters);
		addTaskName(task);

		command->setCurrentTask(*task);
		delete task;
	} catch(const invalid_argument& e) {
		command->setUserMessage(e.what());
		command->setParsedStatus(false);
	} catch(const out_of_range& e) {
		command->setUserMessage(e.what());
		command->setParsedStatus(false);
	}
}

void DetailsParser::deleteExistingTask(Command* command) {
	sprintf_s(logBuffer, LOG_DELETE_TASK.c_str());
	log(logBuffer);

	try {
		if(!hasOnlyIndex()) {
			sprintf_s(logBuffer, LOG_ERROR_NO_INDEX.c_str());
			log(logBuffer);

			throw invalid_argument(USERMESSAGE_INVALID_DELETE);
		}
		setTaskIndex(command);
	} catch(const invalid_argument& e) {
		command->setUserMessage(e.what());
		command->setParsedStatus(false);
	}
}

void DetailsParser::markTaskAsDone(Command* command) {
	sprintf_s(logBuffer, LOG_MARK_DONE.c_str());
	log(logBuffer);

	try {
		if(!hasOnlyIndex()) {
			sprintf_s(logBuffer, LOG_ERROR_NO_INDEX.c_str());
			log(logBuffer);

			throw invalid_argument(USERMESSAGE_INVALID_DONE);
		}
		setTaskIndex(command);
		command->setIsDoneStatus(true);
	} catch(const invalid_argument& e) {
		command->setUserMessage(e.what());
		command->setParsedStatus(false);
	}
}

void DetailsParser::markTaskAsUndone(Command* command) {
	sprintf_s(logBuffer, LOG_MARK_UNDONE.c_str());
	log(logBuffer);

	try {
		if(!hasOnlyIndex()) {
			sprintf_s(logBuffer, LOG_ERROR_NO_INDEX.c_str());
			log(logBuffer);

			throw invalid_argument(USERMESSAGE_INVALID_UNDONE);
		}
		setTaskIndex(command);
		command->setIsDoneStatus(false);
	} catch(const invalid_argument& e) {
		command->setUserMessage(e.what());
		command->setParsedStatus(false);
	}
}

void DetailsParser::editExistingTask(Command* command) {
	sprintf_s(logBuffer, LOG_EDIT_TASK.c_str());
	log(logBuffer);

	try {
		if(!hasIndex()) {
			sprintf_s(logBuffer, LOG_ERROR_NO_INDEX.c_str());
			log(logBuffer);

			throw invalid_argument(USERMESSAGE_INVALID_EDIT_NO_INDEX);
		} else if(!hasEditedTask()) {
			sprintf_s(logBuffer, LOG_ERROR_NO_TASK.c_str());
			log(logBuffer);

			throw invalid_argument(USERMESSAGE_INVALID_EDIT_NO_TASK);
		}
		setTaskIndex(command);
		removeIndexForEdit();
		addNewTask(command);
	} catch(const invalid_argument& e) {
		command->setUserMessage(e.what());
		command->setParsedStatus(false);
	}
}

void DetailsParser::filterExistingTasks(Command* command) {
	sprintf_s(logBuffer, LOG_FILTER_TASKS.c_str());
	log(logBuffer);

	_parameters = transformToLowercase(_parameters);
	_tokens = tokenizeString(_parameters);
	if(foundClear()) {
		clearFilters(command);
	} else {
		parseDoneFilter(command);
		parseTypeFilter(command);
		parseDateFilter(command);
	}
}

void DetailsParser::searchForTask(Command* command) {
	sprintf_s(logBuffer, LOG_SEARCH_TASKS.c_str());
	log(logBuffer);

	formatForSearch();
	command->setSearchKeyword(_parameters);
}

void DetailsParser::setTaskIndex(Command* command) {
	assert(hasIndex());
	command->setTaskIndex(stoi(_tokens.front()));
}

void DetailsParser::addTaskTags(Task* task) {
	vector<string> taskTags;
	_parameters.clear();

	for(auto iter = _tokens.begin(); iter != _tokens.end(); ++iter) {
		if(isTag(*iter)) {
			taskTags.push_back(*iter);
		} else {
			_parameters += *iter + SPACE;
		}
	}
	_parameters = trimWhiteSpace(_parameters);
	_tokens = tokenizeString(_parameters);
	task->setTaskTags(taskTags);
}

void DetailsParser::addTaskName(Task* task) {
	try {
		if(_parameters.empty()) {
			sprintf_s(logBuffer, LOG_ERROR_NO_NAME.c_str());
			log(logBuffer);

			throw invalid_argument(USERMESSAGE_NO_TASK_NAME);
		}
		task->setTaskName(_parameters);
	} catch(const invalid_argument&) {
		throw;
	}
}

void DetailsParser::clearFilters(Command* command) {
	command->setDoneFilter(Status::DONE_BOTH);
	command->setTypeFilter(Type::ALL_TYPES);
	command->setStartDateFilter((date)neg_infin);
	command->setEndDateFilter((date)pos_infin);
}

void DetailsParser::parseDoneFilter(Command* command) {
	if(foundNoDone()) {
		command->setDoneFilter(Status::DONE_BOTH);
	} else if(foundDone()) {
		command->setDoneFilter(Status::ONLY_DONE);
	} else if(foundUndone()) {
		command->setDoneFilter(Status::ONLY_UNDONE);
	}
}

void DetailsParser::parseTypeFilter(Command* command) {
	if(foundNoType()) {
		command->setTypeFilter(Type::ALL_TYPES);
	} else if(foundDue()) {
		command->setTypeFilter(Type::ONLY_DUE);
	} else if(foundFixed()) {
		command->setTypeFilter(Type::ONLY_FIXED);
	}
}

void DetailsParser::parseDateFilter(Command* command) {
	try {
		if(foundNoDate()) {
			command->setStartDateFilter((date)neg_infin);
			command->setEndDateFilter((date)pos_infin);
		} else {
			DatetimeParser datetime;
			datetime.addFilterDate(command, _parameters);
		}
	} catch(const out_of_range& e) {
		command->setUserMessage(e.what());
		command->setParsedStatus(false);
	}
}

bool DetailsParser::hasIndex() {
	return isNumber(_tokens.front());
}

bool DetailsParser::hasOnlyIndex() {
	return (isOneWord(_parameters) && hasIndex());
}

bool DetailsParser::hasEditedTask() {
	return !isOneWord(_parameters);
}

bool DetailsParser::isTag(string word) {
	return (word.find_first_of(IDENTIFIER_TAG) == ZERO);
}

bool DetailsParser::foundClear(void) {
	for(auto iter = _tokens.begin(); iter != _tokens.end(); ++iter) {
		if(*iter == FILTER_CLEAR) {
			return true;
		}
	}
	return false;
}

bool DetailsParser::foundDone(void) {
	for(auto iter = _tokens.begin(); iter != _tokens.end(); ++iter) {
		if(*iter == FILTER_DONE_DONE) {
			return true;
		}
	}
	return false;
}

bool DetailsParser::foundUndone(void) {
	for(auto iter = _tokens.begin(); iter != _tokens.end(); ++iter) {
		if(*iter == FILTER_DONE_UNDONE) {
			return true;
		}
	}
	return false;
}

bool DetailsParser::foundNoDone(void) {
	for(auto iter = _tokens.begin(); iter != _tokens.end(); ++iter) {
		if(*iter == FILTER_DONE_ALL) {
			return true;
		}
	}
	return false;
}

bool DetailsParser::foundFixed(void) {
	for(auto iter = _tokens.begin(); iter != _tokens.end(); ++iter) {
		if(*iter == FILTER_TYPE_FIXED) {
			return true;
		}
	}
	return false;
}

bool DetailsParser::foundDue(void) {
	for(auto iter = _tokens.begin(); iter != _tokens.end(); ++iter) {
		if(*iter == FILTER_TYPE_DUE) {
			return true;
		}
	}
	return false;
}

bool DetailsParser::foundNoType(void) {
	for(auto iter = _tokens.begin(); iter != _tokens.end(); ++iter) {
		if(*iter == FILTER_TYPE_ALL) {
			return true;
		}
	}
	return false;
}

bool DetailsParser::foundNoDate(void) {
	for(auto iter = _tokens.begin(); iter != _tokens.end(); ++iter) {
		if(*iter == FILTER_DATE_NONE) {
			return true;
		}
	}
	return false;
}

void DetailsParser::removeIndexForEdit() {
	_parameters = getExceptFirstWord(_parameters);
	_tokens.erase(_tokens.begin());
}

void DetailsParser::formatForSearch() {
	string searchWords;
	string searchTags;
	_parameters = transformToLowercase(_parameters);
	_tokens = tokenizeString(_parameters);
	
	for(auto iter = _tokens.begin(); iter != _tokens.end(); ++iter) {
		if(isTag(*iter)) {
			searchTags += *iter;
		} else {
			searchWords += *iter + SPACE;
		}
	}

	_parameters = trimWhiteSpace(searchWords) + searchTags;
}
	// End of segment: ./\LogicParserDetailsParser.cpp





	/**
	 * origin: ./\LogicParserDetailsParser.h
	 */

//****************************************************************************
//DetailsParser is concerned with the parsing of parameters for Command 
//subclasses which require them, specifically {CommandAdd, CommandDelete, 
//CommandDone, CommandEdit, CommandFilter, CommandSearch}. It firstly checks 
//the validity of the parameters supplied. In particular, it ensures that
//	1) Only an integer parameter is given for {CommandDelete, CommandDone}.
//	2) An integer followed by a string parameter is given for {CommandEdit}.
//
//DetailsParser further ensures that all details are formatted and placed
//in their respective fields. Tasks created for {CommandAdd, CommandEdit} are
//also given its individual attributes, such as TaskName and TaskTags. If 
//parsing is unsuccessful, isParsedCorrectly status will be set to false.
//
//DetailsParser inherits string modification functions from StringModifier.
//
//Sample usage: Initialize with parameters, call relevant function with
//				Command pointer.
//	DetailsParser details(parameters);
//	details.addNewTask((CommandAdd*) add);
//****************************************************************************

#pragma once
#include "LogicParserStringModifier.h"
#include "LogicParserDatetimeParser.h"

using namespace std;

const string IDENTIFIER_TAG = "#";

const string FILTER_CLEAR = "clear";
const string FILTER_DONE_ALL = "nodone";
const string FILTER_DONE_DONE = "done";
const string FILTER_DONE_UNDONE = "undone";
const string FILTER_TYPE_ALL = "notype";
const string FILTER_TYPE_FIXED = "fixed";
const string FILTER_TYPE_DUE = "due";
const string FILTER_DATE_NONE = "nodate";

const string USERMESSAGE_NO_TASK_NAME =
	"You cannot add a task without a task name!";
const string USERMESSAGE_INVALID_DELETE = 
	"You must specify an index to delete a task!";
const string USERMESSAGE_INVALID_DONE = 
	"You must specify an index to mark a task as done!";
const string USERMESSAGE_INVALID_UNDONE = 
	"You must specify an index to mark a task as not done!";
const string USERMESSAGE_INVALID_EDIT_NO_INDEX = 
	"You must specify an index to edit a task!";
const string USERMESSAGE_INVALID_EDIT_NO_TASK = 
	"You must add changed task details to edit a task!";

const string LOG_ADD_TASK = 
	"DetailsParser - Adding new task.\n";
const string LOG_DELETE_TASK = 
	"DetailsParser - Deleteing task.\n";
const string LOG_MARK_DONE = 
	"DetailsParser - Marking task as done.\n";
const string LOG_MARK_UNDONE = 
	"DetailsParser - Marking task as undone.\n";
const string LOG_EDIT_TASK = 
	"DetailsParser - Editing task.\n";
const string LOG_FILTER_TASKS = 
	"DetailsParser - Filtering tasks.\n";
const string LOG_SEARCH_TASKS = 
	"DetailsParser - Searching tasks.\n";

const string LOG_ERROR_NO_INDEX = 
	"DetailsParser - Error - No index supplied.\n";
const string LOG_ERROR_NO_TASK = 
	"DetailsParser - Error - No task supplied.\n";
const string LOG_ERROR_NO_NAME = 
	"DetailsParser - Error - No task name supplied.\n";

class DetailsParser : public StringModifier {
public:
	DetailsParser(string parameters);
	~DetailsParser(void);

	void addNewTask(Command* command);
	void deleteExistingTask(Command* command);
	void markTaskAsDone(Command* command);
	void markTaskAsUndone(Command* command);
	void editExistingTask(Command* command);
	void filterExistingTasks(Command* command);
	void searchForTask(Command* command);

private:
	void setTaskIndex(Command* command);
	void addTaskTags(Task* task);
	void addTaskName(Task* task);

	void clearFilters(Command* command);
	void parseDoneFilter(Command* command);
	void parseTypeFilter(Command* command);
	void parseDateFilter(Command* command);

	bool hasIndex(void);
	bool hasOnlyIndex(void);
	bool hasEditedTask(void);
	bool isTag(string word);

	bool foundClear(void);
	bool foundDone(void);
	bool foundUndone(void);
	bool foundNoDone(void);
	bool foundFixed(void);
	bool foundDue(void);
	bool foundNoType(void);
	bool foundNoDate(void);

	void removeIndexForEdit(void);	
	void formatForSearch(void);

	string _parameters;
	vector<string> _tokens;
};
	// End of segment: ./\LogicParserDetailsParser.h





	/**
	 * origin: ./\LogicParserStringModifier.cpp
	 */

#include "LogicParserStringModifier.h"

StringModifier::StringModifier(void) {
}

StringModifier::~StringModifier(void) {
}

bool StringModifier::isOneWord(string text) {
	if(text.empty()) {
		return false;
	}
	text = trimWhiteSpace(text);
	return (text.find_first_of(WHITESPACE_CHAR) == string::npos);
}

bool StringModifier::isNumber(string text) {
	if(text.empty()) {
		return false;
	}
	text = trimWhiteSpace(text);
	return all_of(text.begin(), text.end(), isdigit);
}

string StringModifier::getFirstWord(string text) {
	assert(!text.empty());
	text = trimWhiteSpace(text);
	return text.substr(ZERO, text.find_first_of(WHITESPACE_CHAR));
}

string StringModifier::getExceptFirstWord(string text) {
	assert(!text.empty());
	if(isOneWord(text)) {
		return EMPTY_STRING;
	}
	text = trimWhiteSpace(text);
	text = text.substr(text.find_first_of(WHITESPACE_CHAR));
	return trimWhiteSpace(text);
}

string StringModifier::trimWhiteSpace(string text) {
	if(text.empty()) {
		return EMPTY_STRING;
	}
	return trimLeft(trimRight(text));
}

string StringModifier::transformToLowercase(string text) {
	if(text.empty()) {
		return EMPTY_STRING;
	}
	transform(text.begin(), text.end(), text.begin(), tolower);
	return text;
}

vector<string> StringModifier::tokenizeString(string text) {
	try {
		if(text.empty()) {
			throw invalid_argument(EMPTY_STRING);
		}
		istringstream iss(text);
		string currentWord;
		vector<string> tokens;

		while(iss >> currentWord) {
			tokens.push_back(currentWord);
		}
		return tokens;
	}
	catch(const invalid_argument) {
		vector<string> emptyVector;
		return emptyVector;
	}
}

string StringModifier::detokenizeVector(vector<string> text) {
	if(text.empty()) {
		return EMPTY_STRING;
	}
	string line;
	for(auto iter = text.begin(); iter != text.end(); ++iter) {
		if(!(*iter).empty()) {
			line += *iter + SPACE;
		}
	}
	return trimWhiteSpace(line);
}

void StringModifier::log(string message) {
	if (!PARSER_LOGGING_ON) {
		return;
	}

	ofstream logger;
	logger.open(PARSER_LOG_FILE_NAME, ios::app);
	logger << message;
	logger.close();
}

string StringModifier::trimLeft(string text) {
	assert(!text.empty());
	return text.substr(text.find_first_not_of(WHITESPACE_CHAR));
}

string StringModifier::trimRight(string text) {
	assert(!text.empty());
	return text.substr(ZERO, text.find_last_not_of(WHITESPACE_CHAR) + ONE);
}
	// End of segment: ./\LogicParserStringModifier.cpp





	/**
	 * origin: ./\LogicParserStringModifier.h
	 */

//****************************************************************************
//StringModifier is the class containing the common string manipulation and 
//modification methods used throughout the Parser component. In addition, it
//also provides the logging function that is shared between the sub-classes
//of the LogicParser component.
//
//Sample usage:
//	StringModifier stringMod;
//	string output = stringMod.transformToLowercase("ONE");
//  //output == "one"
//****************************************************************************

#pragma once
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <algorithm>
#include <cctype>
#include <assert.h>
#include <exception>
#include "Command.h"

using namespace std;

enum ConstInt {
	ZERO, ONE, TWO, THREE
};

const string SPACE = " ";
const string EMPTY_STRING = "";
const string WHITESPACE_CHAR = " \f\n\r\t\v";

const string PARSER_LOG_FILE_NAME = "ParserLog.txt";
const bool PARSER_LOGGING_ON = false;

class StringModifier {
public:
	StringModifier(void);
	~StringModifier(void);

	bool isOneWord(string text);

	//Checks if the given string is wholly alphanumeric, excluding starting
	//and ending whitespace characters. Note that negative numbers denoted by
	//a - sign will fail this check.
	bool isNumber(string text);

	string getFirstWord(string text);

	//Gets the string given with the first word removed. Returns an empty
	//string if the given string consists of only one word.
	string getExceptFirstWord(string text);

	//Trims the starting and ending whitespace characters around the given
	//string. Note that it does not modify whitespace characters between words.
	string trimWhiteSpace(string text);

	string transformToLowercase(string text);

	vector<string> tokenizeString(string text);

	//Sequentially concatenates a vector of strings into a single string,
	//with each token separated by a space.
	string detokenizeVector(vector<string> text);

	//Logging function and buffer
	void log(string message);
	char logBuffer[1000];

private:
	string trimLeft(string text);
	string trimRight(string text);
};


	// End of segment: ./\LogicParserStringModifier.h





	/**
	 * origin: ./\ParserUnitTests\ParserTest.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace std;
using namespace boost::gregorian;
using namespace boost::posix_time;

namespace ParserTest {		

	//Unit tests for the StringModifier class.
	TEST_CLASS(StringModifierTest) {
	public:
		StringModifier strMod;

		TEST_METHOD(StringModifier_isOneWOrd) {
			//One word with different characters
			Assert::AreEqual(true, strMod.isOneWord("one"));
			Assert::AreEqual(true, strMod.isOneWord(" onetwothreefour "));

			//More than one word
			Assert::AreEqual(false, strMod.isOneWord("two words"));
			Assert::AreEqual(false, strMod.isOneWord("  two     words"));

			//Empty string
			Assert::AreEqual(false, strMod.isOneWord(""));
		}

		TEST_METHOD(StringModifier_isNumber) {
			//Numbers
			Assert::AreEqual(true, strMod.isNumber("1"));
			Assert::AreEqual(true, strMod.isNumber(" 1  "));
			Assert::AreEqual(true, strMod.isNumber("1123432543363"));

			//Not numbers
			Assert::AreEqual(false, strMod.isNumber("-12"));
			Assert::AreEqual(false, strMod.isNumber("12ab"));
			Assert::AreEqual(false, strMod.isNumber("1 2 3 4 "));

			//Empty string
			Assert::AreEqual(false, strMod.isOneWord(""));
		}
		
		TEST_METHOD(StringModifier_getFirstWord) {
			string expected = "one";

			//Single word
			Assert::AreEqual(expected, strMod.getFirstWord("one"));

			//Multiple words
			Assert::AreEqual(expected, strMod.getFirstWord("one two three"));

			//Expected failing test
			Assert::AreNotEqual(expected, strMod.getFirstWord("two one"));
		}

		TEST_METHOD(StringModifier_getExceptFirstWord) {
			string expected = "two three";

			//Simple string
			Assert::AreEqual(expected, strMod.getExceptFirstWord("one two three"));
			
			//String with additional spaces
			Assert::AreEqual(expected, strMod.getExceptFirstWord(" onetwo  two three"));

			//Different substring
			Assert::AreNotEqual(expected, strMod.getExceptFirstWord("one two   three"));

			//Expected failing test
			Assert::AreNotEqual(expected, strMod.getExceptFirstWord("two three four"));
		}

		TEST_METHOD(StringModifier_trimWhitespace) {
			string expected1 = "one";
			string expected2 = "one two";

			//Single word, no whitespace
			Assert::AreEqual(expected1, strMod.trimWhiteSpace("one"));
			
			//Single word, with whitespace
			Assert::AreEqual(expected1, strMod.trimWhiteSpace("  one	"));

			//Multiple words, no whitespace
			Assert::AreEqual(expected2, strMod.trimWhiteSpace("one two"));

			//Multiple words, with whitespace
			Assert::AreEqual(expected2, strMod.trimWhiteSpace("	one two "));

			//Multiple words with whitespace in between
			Assert::AreNotEqual(expected2, strMod.trimWhiteSpace("one   two"));
		}

		TEST_METHOD(StringModifier_transformToLowercase) {
			string expected = "one two three";

			//Lowercase to lowercase
			Assert::AreEqual(expected, strMod.transformToLowercase("one two three"));

			//Uppercase to lowercase
			Assert::AreEqual(expected, strMod.transformToLowercase("ONE TwO thrEE"));
			
			//Different characters
			Assert::AreNotEqual(expected, strMod.transformToLowercase("one two thre3"));
		}

		TEST_METHOD(StringModifier_tokenizeString) {
			vector<string> actual = strMod.tokenizeString("	one  fine  day  ");
			size_t expectedSize = 3;
			string expected1 = "one";
			string expected2 = "fine";
			string expected3 = "day";
			Assert::AreEqual(expectedSize, actual.size());
			Assert::AreEqual(expected1, actual[0]);
			Assert::AreEqual(expected2, actual[1]);
			Assert::AreEqual(expected3, actual[2]);
		}
		
		TEST_METHOD(StringModifier_detokenizeVector) {
			vector<string> actual = strMod.tokenizeString("one fine day");
			string expected = "one fine day";
			Assert::AreEqual(expected, strMod.detokenizeVector(actual));
		}
	};

	//Unit tests for the DetailsParser class.
	TEST_CLASS(DetailsParserTest) {
	public:
		TEST_METHOD(Details_search) {
			DetailsParser details("APPLE   #Fruit banana   #eat");
			Command* command = new Command;
			details.searchForTask(command);

			string expectedSearch = "apple banana#fruit#eat";

			Assert::AreEqual(expectedSearch, command->getSearchKeyword());
		}

		TEST_METHOD(Details_markAsDone) {
			DetailsParser details("123");
			Command* command = new Command;
			details.markTaskAsDone(command);

			int expectedIndex = 123;
			bool expectedDone = true;

			Assert::AreEqual(expectedIndex, command->getTaskIndex());
			Assert::AreEqual(expectedDone, command->getIsDoneStatus());
		}

		TEST_METHOD(Details_markAsDone_Fail) {
			DetailsParser details("abc");
			Command* command = new Command;
			details.markTaskAsDone(command);

			Assert::AreEqual(false, command->getParsedStatus());
		}

		TEST_METHOD(Details_markAsUndone) {
			DetailsParser details("123");
			Command* command = new Command;
			details.markTaskAsUndone(command);

			int expectedIndex = 123;
			bool expectedDone = false;

			Assert::AreEqual(expectedIndex, command->getTaskIndex());
			Assert::AreEqual(expectedDone, command->getIsDoneStatus());
		}

		TEST_METHOD(Details_deleteExistingTask) {
			DetailsParser details("3243523");
			Command* command = new Command;
			details.deleteExistingTask(command);

			int expectedIndex = 3243523;

			Assert::AreEqual(expectedIndex, command->getTaskIndex());
		}

		TEST_METHOD(Details_deleteExistingTask_Fail) {
			DetailsParser details("-1");
			Command* command = new Command;
			details.deleteExistingTask(command);

			Assert::AreEqual(false, command->getParsedStatus());
		}

		TEST_METHOD(Details_addNewTask_OnlyName) {
			DetailsParser details("watch cs2103 webcast");
			Command* command = new Command;
			details.addNewTask(command);
			Task task = command->getCurrentTask();

			string expectedName = "watch cs2103 webcast";

			Assert::AreEqual(expectedName, task.getTaskName());
		}

		TEST_METHOD(Details_addNewTask_OnlyTag_Fail) {
			DetailsParser details("#cs2103 #school");
			Command* command = new Command;
			details.addNewTask(command);

			Assert::AreEqual(false, command->getParsedStatus());
		}

		TEST_METHOD(Details_addNewTask_NameAndTags) {
			DetailsParser details("Prepare for exam #cs2103 #school");
			Command* command = new Command;
			details.addNewTask(command);
			Task task = command->getCurrentTask();

			string expectedName = "Prepare for exam";
			size_t expectedTagsSize = 2;
			string expectedTag1 = "#cs2103";
			string expectedTag2 = "#school";

			Assert::AreEqual(expectedName, task.getTaskName());
			Assert::AreEqual(expectedTagsSize, task.getTaskTags().size());
			Assert::AreEqual(expectedTag1, task.getTaskTags()[0]);
			Assert::AreEqual(expectedTag2, task.getTaskTags()[1]);
		}

		TEST_METHOD(Details_editExistingTask) {
			DetailsParser details("13 watch webcast #cs2103");
			Command* command = new Command;
			details.editExistingTask(command);
			Task task = command->getCurrentTask();

			int expectedIndex = 13;
			string expectedName = "watch webcast";
			size_t expectedTagsSize = 1;
			string expectedTag = "#cs2103";

			Assert::AreEqual(expectedIndex, command->getTaskIndex());
			Assert::AreEqual(expectedName, task.getTaskName());
			Assert::AreEqual(expectedTagsSize, task.getTaskTags().size());
			Assert::AreEqual(expectedTag, task.getTaskTags()[0]);
		}

		TEST_METHOD(Details_editExistingTask_Fail) {
			DetailsParser details("watch webcast #cs2103");
			Command* command = new Command;
			details.editExistingTask(command);

			Assert::AreEqual(false, command->getParsedStatus());
		}

		TEST_METHOD(Details_filterInvalid) {
			DetailsParser details("this doesn't contain any filters");
			Command* command = new Command;
			details.filterExistingTasks(command);

			int expectedDone = Status::STATUS_NOT_SET;
			int expectedType = Type::TYPE_NOT_SET;
			date start;
			date end((date)pos_infin);

			Assert::AreEqual(expectedDone, command->getDoneFilter());
			Assert::AreEqual(expectedType, command->getTypeFilter());

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(command->getStartDateFilter());
			Assert::AreEqual(expectedStart, actualStart);

			string expectedEnd = to_iso_string(end);
			string actualEnd = to_iso_string(command->getEndDateFilter());
			Assert::AreEqual(expectedEnd, actualEnd);
		}

		TEST_METHOD(Details_filterDone) {
			DetailsParser details("done but this is extra stuff");
			Command* command = new Command;
			details.filterExistingTasks(command);

			int expectedDone = Status::ONLY_DONE;
			int expectedType = Type::TYPE_NOT_SET;
			date start;
			date end((date)pos_infin);

			Assert::AreEqual(expectedDone, command->getDoneFilter());
			Assert::AreEqual(expectedType, command->getTypeFilter());

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(command->getStartDateFilter());
			Assert::AreEqual(expectedStart, actualStart);

			string expectedEnd = to_iso_string(end);
			string actualEnd = to_iso_string(command->getEndDateFilter());
			Assert::AreEqual(expectedEnd, actualEnd);
		}

		TEST_METHOD(Details_filterStartDate) {
			DetailsParser details("25 dec");
			Command* command = new Command;
			details.filterExistingTasks(command);

			int expectedDone = Status::STATUS_NOT_SET;
			int expectedType = Type::TYPE_NOT_SET;
			date start(2014, 12, 25);
			date end((date)pos_infin);

			Assert::AreEqual(expectedDone, command->getDoneFilter());
			Assert::AreEqual(expectedType, command->getTypeFilter());

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(command->getStartDateFilter());
			Assert::AreEqual(expectedStart, actualStart);

			string expectedEnd = to_iso_string(end);
			string actualEnd = to_iso_string(command->getEndDateFilter());
			Assert::AreEqual(expectedEnd, actualEnd);
		}

		TEST_METHOD(Details_filterStartEndDate) {
			DetailsParser details("25 dec to 31 dec");
			Command* command = new Command;
			details.filterExistingTasks(command);

			int expectedDone = Status::STATUS_NOT_SET;
			int expectedType = Type::TYPE_NOT_SET;
			date start(2014, 12, 25);
			date end(2014, 12, 31);

			Assert::AreEqual(expectedDone, command->getDoneFilter());
			Assert::AreEqual(expectedType, command->getTypeFilter());

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(command->getStartDateFilter());
			Assert::AreEqual(expectedStart, actualStart);

			string expectedEnd = to_iso_string(end);
			string actualEnd = to_iso_string(command->getEndDateFilter());
			Assert::AreEqual(expectedEnd, actualEnd);
		}

		TEST_METHOD(Details_filterDeadline) {
			DetailsParser details("due");
			Command* command = new Command;
			details.filterExistingTasks(command);

			int expectedDone = Status::STATUS_NOT_SET;
			int expectedType = Type::ONLY_DUE;
			date start;
			date end((date)pos_infin);

			Assert::AreEqual(expectedDone, command->getDoneFilter());
			Assert::AreEqual(expectedType, command->getTypeFilter());

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(command->getStartDateFilter());
			Assert::AreEqual(expectedStart, actualStart);

			string expectedEnd = to_iso_string(end);
			string actualEnd = to_iso_string(command->getEndDateFilter());
			Assert::AreEqual(expectedEnd, actualEnd);
		}

		TEST_METHOD(Details_filterMultiple) {
			DetailsParser details("due 25 Dec nodone");
			Command* command = new Command;
			details.filterExistingTasks(command);

			int expectedDone = Status::DONE_BOTH;
			int expectedType = Type::ONLY_DUE;
			date start(2014, 12, 25);
			date end((date)pos_infin);

			Assert::AreEqual(expectedDone, command->getDoneFilter());
			Assert::AreEqual(expectedType, command->getTypeFilter());

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(command->getStartDateFilter());
			Assert::AreEqual(expectedStart, actualStart);

			string expectedEnd = to_iso_string(end);
			string actualEnd = to_iso_string(command->getEndDateFilter());
			Assert::AreEqual(expectedEnd, actualEnd);
		}

		TEST_METHOD(Details_filterClear) {
			DetailsParser details("CLEAR");
			Command* command = new Command;
			details.filterExistingTasks(command);

			int expectedDone = Status::DONE_BOTH;
			int expectedType = Type::ALL_TYPES;
			date start((date)neg_infin);
			date end((date)pos_infin);

			Assert::AreEqual(expectedDone, command->getDoneFilter());
			Assert::AreEqual(expectedType, command->getTypeFilter());

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(command->getStartDateFilter());
			Assert::AreEqual(expectedStart, actualStart);

			string expectedEnd = to_iso_string(end);
			string actualEnd = to_iso_string(command->getEndDateFilter());
			Assert::AreEqual(expectedEnd, actualEnd);
		}
	};

	//Unit tests for the DatetimeParser class.
	TEST_CLASS(DatetimeParserTest) {
	public:
		DatetimeParser datetime;

		TEST_METHOD(Datetime_noDate) {
			Task* task = new Task;
			string parameters = "meeting with cs2103 group";
			datetime.addTaskDatetime(task, parameters);

			string expectedParameters = "meeting with cs2103 group";
			Assert::AreEqual(expectedParameters, parameters);
		}

		TEST_METHOD(Datetime_3Date_dateMonthYearNoIdentifier) {
			Task* task = new Task;
			string parameters = "meeting 25 oct 14";
			datetime.addTaskDatetime(task, parameters);

			string expectedParameters = "meeting";
			Assert::AreEqual(expectedParameters, parameters);

			date startDate(2014, 10, 25);
			time_duration startTime(0, 0, 1);
			ptime start(startDate, startTime);

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);
		}

		TEST_METHOD(Datetime_3Date_dateMonthFullYearNoIdentifier) {
			Task* task = new Task;
			string parameters = "meeting 25 oct 2015";
			datetime.addTaskDatetime(task, parameters);

			string expectedParameters = "meeting";
			Assert::AreEqual(expectedParameters, parameters);

			date startDate(2015, 10, 25);
			time_duration startTime(0, 0, 1);
			ptime start(startDate, startTime);

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);
		}

		TEST_METHOD(Datetime_2Date_dateMonthNoIdentifier) {
			Task* task = new Task;
			string parameters = "meeting 25 oct at utown";
			datetime.addTaskDatetime(task, parameters);

			string expectedParameters = "meeting at utown";
			Assert::AreEqual(expectedParameters, parameters);

			date startDate(2014, 10, 25);
			time_duration startTime(0, 0, 1);
			ptime start(startDate, startTime);

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);
		}

		//Must be adjusted according to current date
		TEST_METHOD(Datetime_2Date_thisWeekdayNoIdentifier) {
			Task* task = new Task;
			string parameters = "cs2103 meeting this fri";
			datetime.addTaskDatetime(task, parameters);

			string expectedParameters = "cs2103 meeting";
			Assert::AreEqual(expectedParameters, parameters);

			date startDate(2014, 11, 14);
			time_duration startTime(0, 0, 1);
			ptime start(startDate, startTime);

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);
		}

		//Must be adjusted according to current date
		TEST_METHOD(Datetime_2Date_nextWeekdayNoIdentifier) {
			Task* task = new Task;
			string parameters = "next mon meeting for cs";
			datetime.addTaskDatetime(task, parameters);

			string expectedParameters = "meeting for cs";
			Assert::AreEqual(expectedParameters, parameters);

			date startDate(2014, 11, 17);
			time_duration startTime(0, 0, 1);
			ptime start(startDate, startTime);

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);
		}

		TEST_METHOD(Datetime_1Date_DDMMNoIdentifier) {
			Task* task = new Task;
			string parameters = "meeting 13/11";
			datetime.addTaskDatetime(task, parameters);

			date startDate(2014, 11, 13);
			time_duration startTime(0, 0, 1);
			ptime start(startDate, startTime);

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);
		}

		TEST_METHOD(Datetime_1Date_DDMMYYNoIdentifier) {
			Task* task = new Task;
			string parameters = "meeting 13-11-14";
			datetime.addTaskDatetime(task, parameters);

			date startDate(2014, 11, 13);
			time_duration startTime(0, 0, 1);
			ptime start(startDate, startTime);

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);
		}

		TEST_METHOD(Datetime_1Date_DDMMYYYYNoIdentifier) {
			Task* task = new Task;
			string parameters = "meeting 13.11.2014";
			datetime.addTaskDatetime(task, parameters);

			date startDate(2014, 11, 13);
			time_duration startTime(0, 0, 1);
			ptime start(startDate, startTime);

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);
		}

		TEST_METHOD(Datetime_1Date_TodayNoIdentifier) {
			Task* task = new Task;
			string parameters = "meeting today";
			datetime.addTaskDatetime(task, parameters);

			date startDate(day_clock::local_day());
			time_duration startTime(0, 0, 1);
			ptime start(startDate, startTime);

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);
		}

		TEST_METHOD(Datetime_1Date_TomorrowNoIdentifier) {
			Task* task = new Task;
			string parameters = "meeting tmr";
			datetime.addTaskDatetime(task, parameters);

			date startDate(day_clock::local_day());
			time_duration startTime(24, 0, 1);
			ptime start(startDate, startTime);

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);
		}

		//Must be adjusted according to current date
		TEST_METHOD(Datetime_1Date_WeekdayNoIdentifier) {
			Task* task = new Task;
			string parameters = "wed meeting";
			datetime.addTaskDatetime(task, parameters);

			date startDate(2014, 11, 12);
			time_duration startTime(0, 0, 1);
			ptime start(startDate, startTime);

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);
		}

		TEST_METHOD(Datetime_12HTime_NoIdentifier) {
			Task* task = new Task;
			string parameters = "meeting 10.00a.m. 04/01/2015";
			datetime.addTaskDatetime(task, parameters);

			date startDate(2015, 1, 4);
			time_duration startTime(10, 0, 0);
			ptime start(startDate, startTime);

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);
		}

		TEST_METHOD(Datetime_24HTime_NoIdentifier) {
			Task* task = new Task;
			string parameters = "meeting 23:59 25 dec";
			datetime.addTaskDatetime(task, parameters);

			date startDate(2014, 12, 25);
			time_duration startTime(23, 59, 0);
			ptime start(startDate, startTime);

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);
		}

		TEST_METHOD(Datetime_StartIdentifier) {
			Task* task = new Task;
			string parameters = "meeting on 23 dec at 12:30pm";
			datetime.addTaskDatetime(task, parameters);

			date startDate(2014, 12, 23);
			time_duration startTime(12, 30, 0);
			ptime start(startDate, startTime);
			ptime end;
			ptime deadline;

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);

			string expectedEnd = to_iso_string(end);
			string actualEnd = to_iso_string(task->getTaskEndTime());
			Assert::AreEqual(expectedEnd, actualEnd);

			string expectedDeadline = to_iso_string(deadline);
			string actualDeadline = to_iso_string(task->getTaskDeadline());
			Assert::AreEqual(expectedDeadline, actualDeadline);
		}

		TEST_METHOD(Datetime_EndIdentifier) {
			Task* task = new Task;
			string parameters = "meeting on 23 dec from 12:30pm - 1:30pm";
			datetime.addTaskDatetime(task, parameters);

			date startDate(2014, 12, 23);
			time_duration startTime(12, 30, 0);
			ptime start(startDate, startTime);

			date endDate(2014, 12, 23);
			time_duration endTime(13, 30, 0);
			ptime end(endDate, endTime);

			ptime deadline;

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);

			string expectedEnd = to_iso_string(end);
			string actualEnd = to_iso_string(task->getTaskEndTime());
			Assert::AreEqual(expectedEnd, actualEnd);

			string expectedDeadline = to_iso_string(deadline);
			string actualDeadline = to_iso_string(task->getTaskDeadline());
			Assert::AreEqual(expectedDeadline, actualDeadline);
		}

		TEST_METHOD(Datetime_DeadlineIdentifier) {
			Task* task = new Task;
			string parameters = "meeting by 25 dec 2014 3pm";
			datetime.addTaskDatetime(task, parameters);

			ptime start;
			ptime end;
			date deadlineDate(2014, 12, 25);
			time_duration deadlineTime(15, 0, 0);
			ptime deadline(deadlineDate, deadlineTime);

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);

			string expectedEnd = to_iso_string(end);
			string actualEnd = to_iso_string(task->getTaskEndTime());
			Assert::AreEqual(expectedEnd, actualEnd);

			string expectedDeadline = to_iso_string(deadline);
			string actualDeadline = to_iso_string(task->getTaskDeadline());
			Assert::AreEqual(expectedDeadline, actualDeadline);
		}

		TEST_METHOD(Datetime_StartEndIdentifier) {
			Task* task = new Task;
			string parameters = "meeting from 31 oct 2014 3pm to 31 oct 2014 4pm";
			datetime.addTaskDatetime(task, parameters);

			date startDate(2014, 10, 31);
			time_duration startTime(15, 0, 0);
			ptime start(startDate, startTime);
			date endDate(2014, 10, 31);
			time_duration endTime(16, 0, 0);
			ptime end(endDate, endTime);
			ptime deadline;

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task->getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);

			string expectedEnd = to_iso_string(end);
			string actualEnd = to_iso_string(task->getTaskEndTime());
			Assert::AreEqual(expectedEnd, actualEnd);

			string expectedDeadline = to_iso_string(deadline);
			string actualDeadline = to_iso_string(task->getTaskDeadline());
			Assert::AreEqual(expectedDeadline, actualDeadline);
		}
	};
	
	//Unit tests for the entire LogicParser component.
	TEST_CLASS(ParserTest) {
	public:
		LogicParser parser;
		Command* command;

		TEST_METHOD(Parser_addInvalidInput) {
			command = parser.getCommandFromUserInput("    ");
			Assert::AreEqual(command->getParsedStatus(), false);
			command = parser.getCommandFromUserInput("");
			Assert::AreEqual(command->getParsedStatus(), false);
		}

		TEST_METHOD(Parser_addValidInput) {
			command = parser.getCommandFromUserInput("meeting for cs2103 #cs2103");
			Task task = command->getCurrentTask();

			string expected = "meeting for cs2103";
			size_t expectedSize = 1;
			string expectedTag = "#cs2103";

			Assert::AreEqual(true, command->getParsedStatus());
			Assert::AreEqual(expected, task.getTaskName());
			Assert::AreEqual(expectedSize, task.getTaskTags().size());
			Assert::AreEqual(expectedTag, task.getTaskTags()[0]);
		}

		TEST_METHOD(Parser_addFixedTime) {
			command = parser.getCommandFromUserInput("meeting 9 dec 6am to 815pm #cs2103");
			Task task = command->getCurrentTask();

			string expectedName = "meeting";
			size_t expectedTagSize = 1;
			string expectedTag = "#cs2103";

			date startDate(2014, 12, 9);
			time_duration startTime(6, 0, 0);
			ptime start(startDate, startTime);

			date endDate(2014, 12, 9);
			time_duration endTime(20, 15, 0);
			ptime end(endDate, endTime);

			Assert::AreEqual(true, command->getParsedStatus());
			Assert::AreEqual(expectedName, task.getTaskName());
			Assert::AreEqual(expectedTagSize, task.getTaskTags().size());
			Assert::AreEqual(expectedTag, task.getTaskTags()[0]);


			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task.getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);

			string expectedEnd = to_iso_string(end);
			string actualEnd = to_iso_string(task.getTaskEndTime());
			Assert::AreEqual(expectedEnd, actualEnd);
		}

		TEST_METHOD(Parser_addDeadline) {
			command = parser.getCommandFromUserInput("finish report by 11 dec "
													 "#cs2103 #important and "
													 "message group");
			Task task = command->getCurrentTask();

			string expectedName = "finish report and message group";
			size_t expectedTagSize = 2;
			string expectedTag1 = "#cs2103";
			string expectedTag2 = "#important";

			date deadlineDate(2014, 12, 11);
			time_duration deadlineTime(0, 0, 1);
			ptime deadline(deadlineDate, deadlineTime);

			Assert::AreEqual(true, command->getParsedStatus());
			Assert::AreEqual(expectedName, task.getTaskName());
			Assert::AreEqual(expectedTagSize, task.getTaskTags().size());
			Assert::AreEqual(expectedTag1, task.getTaskTags()[0]);
			Assert::AreEqual(expectedTag2, task.getTaskTags()[1]);

			string expectedDeadline = to_iso_string(deadline);
			string actualDeadline = to_iso_string(task.getTaskDeadline());
			Assert::AreEqual(expectedDeadline, actualDeadline);
		}

		TEST_METHOD(Parser_addlongInput) {
			string input = "This is a super"
				" duper long task name that I added just to test parsers "
				"behaviour and it continues on and on and on and on and "
				"on and on and on and on and on and on and on and on and "
				"on and on and on and on and on and on and on and on and "
				"on and on and on and on and on and on and on and on and "
				"on and on and on and on and on and on and on and on and "
				"on and on and on and on and on and on and on and on and "
				"on and on and on and on and on and on and on and on and "
				"on and on and on and on and on and on and on and on and "
				"on and on and on and on and on and on and on and on and "
				"on and on and on and on and on and on and on and on and "
				"on and on and on and on and on and on and on and on and "
				"on and on and on and on and on and on and on and on and "
				"on and on and on and on and on and on and on and on and "
				"on and on and on and on and on and on and on and on";

			command = parser.getCommandFromUserInput(input);
			Task task = command->getCurrentTask();

			Assert::AreEqual(true, command->getParsedStatus());
			Assert::AreEqual(input, task.getTaskName());
		}

		TEST_METHOD(Parser_addNonexistentValidDate_Fail) {
			command = parser.getCommandFromUserInput("group meeting #ie2101 30 feb 2015");

			Assert::AreEqual(false, command->getParsedStatus());
		}

		TEST_METHOD(Parser_addNonexistentInvalidDate) {
			command = parser.getCommandFromUserInput("group meeting #ie2101 32 feb 2015");
			Task task = command->getCurrentTask();

			//2015 is recognised as a 24hour time
			string expected = "group meeting 32 feb";

			Assert::AreEqual(true, command->getParsedStatus());
			Assert::AreEqual(expected, task.getTaskName());
		}

		TEST_METHOD(Parser_addOnlyTag_Fail) {
			command = parser.getCommandFromUserInput("#ie2101");

			Assert::AreEqual(false, command->getParsedStatus());
		}
	
		TEST_METHOD(Parser_addOnlyDate_Fail) {
			command = parser.getCommandFromUserInput("25 feb 2014");

			Assert::AreEqual(false, command->getParsedStatus());
		}

		TEST_METHOD(Parser_done) {
			command = parser.getCommandFromUserInput("/done 1");

			int expectedIndex = 1;

			Assert::AreEqual(true, command->getParsedStatus());
			Assert::AreEqual(expectedIndex, command->getTaskIndex());
		}

		TEST_METHOD(Parser_undone) {
			command = parser.getCommandFromUserInput("/undone 146");

			int expectedIndex = 146;

			Assert::AreEqual(true, command->getParsedStatus());
			Assert::AreEqual(expectedIndex, command->getTaskIndex());
		}

		TEST_METHOD(Parser_undone_Fail) {
			command = parser.getCommandFromUserInput("/undone 1 123");

			Assert::AreEqual(false, command->getParsedStatus());
		}

		TEST_METHOD(Parser_delete) {
			command = parser.getCommandFromUserInput("/delete 213");

			int expectedIndex = 213;

			Assert::AreEqual(true, command->getParsedStatus());
			Assert::AreEqual(expectedIndex, command->getTaskIndex());
		}

		TEST_METHOD(Parser_delete_Fail) {
			command = parser.getCommandFromUserInput("/done abc");

			Assert::AreEqual(false, command->getParsedStatus());
		}

		TEST_METHOD(Parser_filter) {
			command = parser.getCommandFromUserInput("/filter clear");

			int expectedDone = Status::DONE_BOTH;
			int expectedType = Type::ALL_TYPES;
			date start(neg_infin);
			date end(pos_infin);

			Assert::AreEqual(true, command->getParsedStatus());
			Assert::AreEqual(expectedDone, command->getDoneFilter());
			Assert::AreEqual(expectedType, command->getTypeFilter());

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(command->getStartDateFilter());
			Assert::AreEqual(expectedStart, actualStart);

			string expectedEnd = to_iso_string(end);
			string actualEnd = to_iso_string(command->getEndDateFilter());
			Assert::AreEqual(expectedEnd, actualEnd);
		}

		TEST_METHOD(Parser_filterNoValidFilterApplied) {
			command = parser.getCommandFromUserInput("/filter all stuff");

			int expectedDone = Status::STATUS_NOT_SET;
			int expectedType = Type::TYPE_NOT_SET;
			date start;
			date end(pos_infin);

			Assert::AreEqual(true, command->getParsedStatus());
			Assert::AreEqual(expectedDone, command->getDoneFilter());
			Assert::AreEqual(expectedType, command->getTypeFilter());

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(command->getStartDateFilter());
			Assert::AreEqual(expectedStart, actualStart);

			string expectedEnd = to_iso_string(end);
			string actualEnd = to_iso_string(command->getEndDateFilter());
			Assert::AreEqual(expectedEnd, actualEnd);
		}

		TEST_METHOD(Parser_edit) {
			command = parser.getCommandFromUserInput("/edit 4 meeting 9 dec 615pm");
			Task task = command->getCurrentTask();

			string expectedName = "meeting";
			int expectedIndex = 4;
			string expectedTag = "#cs2103";

			date startDate(2014, 12, 9);
			time_duration startTime(18, 15, 0);
			ptime start(startDate, startTime);

			Assert::AreEqual(true, command->getParsedStatus());
			Assert::AreEqual(expectedName, task.getTaskName());
			Assert::AreEqual(expectedIndex, command->getTaskIndex());

			string expectedStart = to_iso_string(start);
			string actualStart = to_iso_string(task.getTaskStartTime());
			Assert::AreEqual(expectedStart, actualStart);
		}

		TEST_METHOD(Parser_editNoIndex_Fail) {
			command = parser.getCommandFromUserInput("/edit meeting 9 dec 615pm");

			Assert::AreEqual(false, command->getParsedStatus());
		}

		TEST_METHOD(Parser_editNoTask_Fail) {
			command = parser.getCommandFromUserInput("/edit 9");

			Assert::AreEqual(false, command->getParsedStatus());
		}

		TEST_METHOD(Parser_undo) {
			command = parser.getCommandFromUserInput("/undo");

			Assert::AreEqual(true, command->getParsedStatus());
		}

		TEST_METHOD(Parser_undo_Fail) {
			command = parser.getCommandFromUserInput("/undo something");

			Assert::AreEqual(false, command->getParsedStatus());
		}

		TEST_METHOD(Parser_redo) {
			command = parser.getCommandFromUserInput("/redo");

			Assert::AreEqual(true, command->getParsedStatus());
		}

		TEST_METHOD(Parser_redo_Fail) {
			command = parser.getCommandFromUserInput("/redo blah");

			Assert::AreEqual(false, command->getParsedStatus());
		}

		TEST_METHOD(Parser_search) {
			command = parser.getCommandFromUserInput("/search meeting");

			string expected = "meeting";

			Assert::AreEqual(true, command->getParsedStatus());
			Assert::AreEqual(expected, command->getSearchKeyword());
		}
	};
}
	// End of segment: ./\ParserUnitTests\ParserTest.cpp





